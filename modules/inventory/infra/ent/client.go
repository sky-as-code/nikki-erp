// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/attribute"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/attributegroup"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/attributevalue"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/product"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/productcategory"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/unit"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/unitcategory"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/variant"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/variantattributerel"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Attribute is the client for interacting with the Attribute builders.
	Attribute *AttributeClient
	// AttributeGroup is the client for interacting with the AttributeGroup builders.
	AttributeGroup *AttributeGroupClient
	// AttributeValue is the client for interacting with the AttributeValue builders.
	AttributeValue *AttributeValueClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// ProductCategory is the client for interacting with the ProductCategory builders.
	ProductCategory *ProductCategoryClient
	// Unit is the client for interacting with the Unit builders.
	Unit *UnitClient
	// UnitCategory is the client for interacting with the UnitCategory builders.
	UnitCategory *UnitCategoryClient
	// Variant is the client for interacting with the Variant builders.
	Variant *VariantClient
	// VariantAttributeRel is the client for interacting with the VariantAttributeRel builders.
	VariantAttributeRel *VariantAttributeRelClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Attribute = NewAttributeClient(c.config)
	c.AttributeGroup = NewAttributeGroupClient(c.config)
	c.AttributeValue = NewAttributeValueClient(c.config)
	c.Product = NewProductClient(c.config)
	c.ProductCategory = NewProductCategoryClient(c.config)
	c.Unit = NewUnitClient(c.config)
	c.UnitCategory = NewUnitCategoryClient(c.config)
	c.Variant = NewVariantClient(c.config)
	c.VariantAttributeRel = NewVariantAttributeRelClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		Attribute:           NewAttributeClient(cfg),
		AttributeGroup:      NewAttributeGroupClient(cfg),
		AttributeValue:      NewAttributeValueClient(cfg),
		Product:             NewProductClient(cfg),
		ProductCategory:     NewProductCategoryClient(cfg),
		Unit:                NewUnitClient(cfg),
		UnitCategory:        NewUnitCategoryClient(cfg),
		Variant:             NewVariantClient(cfg),
		VariantAttributeRel: NewVariantAttributeRelClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		Attribute:           NewAttributeClient(cfg),
		AttributeGroup:      NewAttributeGroupClient(cfg),
		AttributeValue:      NewAttributeValueClient(cfg),
		Product:             NewProductClient(cfg),
		ProductCategory:     NewProductCategoryClient(cfg),
		Unit:                NewUnitClient(cfg),
		UnitCategory:        NewUnitCategoryClient(cfg),
		Variant:             NewVariantClient(cfg),
		VariantAttributeRel: NewVariantAttributeRelClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Attribute.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Attribute, c.AttributeGroup, c.AttributeValue, c.Product, c.ProductCategory,
		c.Unit, c.UnitCategory, c.Variant, c.VariantAttributeRel,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Attribute, c.AttributeGroup, c.AttributeValue, c.Product, c.ProductCategory,
		c.Unit, c.UnitCategory, c.Variant, c.VariantAttributeRel,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AttributeMutation:
		return c.Attribute.mutate(ctx, m)
	case *AttributeGroupMutation:
		return c.AttributeGroup.mutate(ctx, m)
	case *AttributeValueMutation:
		return c.AttributeValue.mutate(ctx, m)
	case *ProductMutation:
		return c.Product.mutate(ctx, m)
	case *ProductCategoryMutation:
		return c.ProductCategory.mutate(ctx, m)
	case *UnitMutation:
		return c.Unit.mutate(ctx, m)
	case *UnitCategoryMutation:
		return c.UnitCategory.mutate(ctx, m)
	case *VariantMutation:
		return c.Variant.mutate(ctx, m)
	case *VariantAttributeRelMutation:
		return c.VariantAttributeRel.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AttributeClient is a client for the Attribute schema.
type AttributeClient struct {
	config
}

// NewAttributeClient returns a client for the Attribute from the given config.
func NewAttributeClient(c config) *AttributeClient {
	return &AttributeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attribute.Hooks(f(g(h())))`.
func (c *AttributeClient) Use(hooks ...Hook) {
	c.hooks.Attribute = append(c.hooks.Attribute, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `attribute.Intercept(f(g(h())))`.
func (c *AttributeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Attribute = append(c.inters.Attribute, interceptors...)
}

// Create returns a builder for creating a Attribute entity.
func (c *AttributeClient) Create() *AttributeCreate {
	mutation := newAttributeMutation(c.config, OpCreate)
	return &AttributeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Attribute entities.
func (c *AttributeClient) CreateBulk(builders ...*AttributeCreate) *AttributeCreateBulk {
	return &AttributeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AttributeClient) MapCreateBulk(slice any, setFunc func(*AttributeCreate, int)) *AttributeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AttributeCreateBulk{err: fmt.Errorf("calling to AttributeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AttributeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AttributeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Attribute.
func (c *AttributeClient) Update() *AttributeUpdate {
	mutation := newAttributeMutation(c.config, OpUpdate)
	return &AttributeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttributeClient) UpdateOne(a *Attribute) *AttributeUpdateOne {
	mutation := newAttributeMutation(c.config, OpUpdateOne, withAttribute(a))
	return &AttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttributeClient) UpdateOneID(id string) *AttributeUpdateOne {
	mutation := newAttributeMutation(c.config, OpUpdateOne, withAttributeID(id))
	return &AttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Attribute.
func (c *AttributeClient) Delete() *AttributeDelete {
	mutation := newAttributeMutation(c.config, OpDelete)
	return &AttributeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AttributeClient) DeleteOne(a *Attribute) *AttributeDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AttributeClient) DeleteOneID(id string) *AttributeDeleteOne {
	builder := c.Delete().Where(attribute.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttributeDeleteOne{builder}
}

// Query returns a query builder for Attribute.
func (c *AttributeClient) Query() *AttributeQuery {
	return &AttributeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAttribute},
		inters: c.Interceptors(),
	}
}

// Get returns a Attribute entity by its id.
func (c *AttributeClient) Get(ctx context.Context, id string) (*Attribute, error) {
	return c.Query().Where(attribute.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttributeClient) GetX(ctx context.Context, id string) *Attribute {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttributeGroup queries the attribute_group edge of a Attribute.
func (c *AttributeClient) QueryAttributeGroup(a *Attribute) *AttributeGroupQuery {
	query := (&AttributeGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attribute.Table, attribute.FieldID, id),
			sqlgraph.To(attributegroup.Table, attributegroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attribute.AttributeGroupTable, attribute.AttributeGroupColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the product edge of a Attribute.
func (c *AttributeClient) QueryProduct(a *Attribute) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attribute.Table, attribute.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attribute.ProductTable, attribute.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttributeValues queries the attribute_values edge of a Attribute.
func (c *AttributeClient) QueryAttributeValues(a *Attribute) *AttributeValueQuery {
	query := (&AttributeValueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attribute.Table, attribute.FieldID, id),
			sqlgraph.To(attributevalue.Table, attributevalue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, attribute.AttributeValuesTable, attribute.AttributeValuesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AttributeClient) Hooks() []Hook {
	return c.hooks.Attribute
}

// Interceptors returns the client interceptors.
func (c *AttributeClient) Interceptors() []Interceptor {
	return c.inters.Attribute
}

func (c *AttributeClient) mutate(ctx context.Context, m *AttributeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AttributeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AttributeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AttributeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Attribute mutation op: %q", m.Op())
	}
}

// AttributeGroupClient is a client for the AttributeGroup schema.
type AttributeGroupClient struct {
	config
}

// NewAttributeGroupClient returns a client for the AttributeGroup from the given config.
func NewAttributeGroupClient(c config) *AttributeGroupClient {
	return &AttributeGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attributegroup.Hooks(f(g(h())))`.
func (c *AttributeGroupClient) Use(hooks ...Hook) {
	c.hooks.AttributeGroup = append(c.hooks.AttributeGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `attributegroup.Intercept(f(g(h())))`.
func (c *AttributeGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.AttributeGroup = append(c.inters.AttributeGroup, interceptors...)
}

// Create returns a builder for creating a AttributeGroup entity.
func (c *AttributeGroupClient) Create() *AttributeGroupCreate {
	mutation := newAttributeGroupMutation(c.config, OpCreate)
	return &AttributeGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AttributeGroup entities.
func (c *AttributeGroupClient) CreateBulk(builders ...*AttributeGroupCreate) *AttributeGroupCreateBulk {
	return &AttributeGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AttributeGroupClient) MapCreateBulk(slice any, setFunc func(*AttributeGroupCreate, int)) *AttributeGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AttributeGroupCreateBulk{err: fmt.Errorf("calling to AttributeGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AttributeGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AttributeGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AttributeGroup.
func (c *AttributeGroupClient) Update() *AttributeGroupUpdate {
	mutation := newAttributeGroupMutation(c.config, OpUpdate)
	return &AttributeGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttributeGroupClient) UpdateOne(ag *AttributeGroup) *AttributeGroupUpdateOne {
	mutation := newAttributeGroupMutation(c.config, OpUpdateOne, withAttributeGroup(ag))
	return &AttributeGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttributeGroupClient) UpdateOneID(id string) *AttributeGroupUpdateOne {
	mutation := newAttributeGroupMutation(c.config, OpUpdateOne, withAttributeGroupID(id))
	return &AttributeGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AttributeGroup.
func (c *AttributeGroupClient) Delete() *AttributeGroupDelete {
	mutation := newAttributeGroupMutation(c.config, OpDelete)
	return &AttributeGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AttributeGroupClient) DeleteOne(ag *AttributeGroup) *AttributeGroupDeleteOne {
	return c.DeleteOneID(ag.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AttributeGroupClient) DeleteOneID(id string) *AttributeGroupDeleteOne {
	builder := c.Delete().Where(attributegroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttributeGroupDeleteOne{builder}
}

// Query returns a query builder for AttributeGroup.
func (c *AttributeGroupClient) Query() *AttributeGroupQuery {
	return &AttributeGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAttributeGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a AttributeGroup entity by its id.
func (c *AttributeGroupClient) Get(ctx context.Context, id string) (*AttributeGroup, error) {
	return c.Query().Where(attributegroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttributeGroupClient) GetX(ctx context.Context, id string) *AttributeGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttribute queries the attribute edge of a AttributeGroup.
func (c *AttributeGroupClient) QueryAttribute(ag *AttributeGroup) *AttributeQuery {
	query := (&AttributeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ag.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attributegroup.Table, attributegroup.FieldID, id),
			sqlgraph.To(attribute.Table, attribute.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, attributegroup.AttributeTable, attributegroup.AttributeColumn),
		)
		fromV = sqlgraph.Neighbors(ag.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the product edge of a AttributeGroup.
func (c *AttributeGroupClient) QueryProduct(ag *AttributeGroup) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ag.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attributegroup.Table, attributegroup.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attributegroup.ProductTable, attributegroup.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(ag.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AttributeGroupClient) Hooks() []Hook {
	return c.hooks.AttributeGroup
}

// Interceptors returns the client interceptors.
func (c *AttributeGroupClient) Interceptors() []Interceptor {
	return c.inters.AttributeGroup
}

func (c *AttributeGroupClient) mutate(ctx context.Context, m *AttributeGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AttributeGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AttributeGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AttributeGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AttributeGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AttributeGroup mutation op: %q", m.Op())
	}
}

// AttributeValueClient is a client for the AttributeValue schema.
type AttributeValueClient struct {
	config
}

// NewAttributeValueClient returns a client for the AttributeValue from the given config.
func NewAttributeValueClient(c config) *AttributeValueClient {
	return &AttributeValueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attributevalue.Hooks(f(g(h())))`.
func (c *AttributeValueClient) Use(hooks ...Hook) {
	c.hooks.AttributeValue = append(c.hooks.AttributeValue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `attributevalue.Intercept(f(g(h())))`.
func (c *AttributeValueClient) Intercept(interceptors ...Interceptor) {
	c.inters.AttributeValue = append(c.inters.AttributeValue, interceptors...)
}

// Create returns a builder for creating a AttributeValue entity.
func (c *AttributeValueClient) Create() *AttributeValueCreate {
	mutation := newAttributeValueMutation(c.config, OpCreate)
	return &AttributeValueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AttributeValue entities.
func (c *AttributeValueClient) CreateBulk(builders ...*AttributeValueCreate) *AttributeValueCreateBulk {
	return &AttributeValueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AttributeValueClient) MapCreateBulk(slice any, setFunc func(*AttributeValueCreate, int)) *AttributeValueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AttributeValueCreateBulk{err: fmt.Errorf("calling to AttributeValueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AttributeValueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AttributeValueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AttributeValue.
func (c *AttributeValueClient) Update() *AttributeValueUpdate {
	mutation := newAttributeValueMutation(c.config, OpUpdate)
	return &AttributeValueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttributeValueClient) UpdateOne(av *AttributeValue) *AttributeValueUpdateOne {
	mutation := newAttributeValueMutation(c.config, OpUpdateOne, withAttributeValue(av))
	return &AttributeValueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttributeValueClient) UpdateOneID(id string) *AttributeValueUpdateOne {
	mutation := newAttributeValueMutation(c.config, OpUpdateOne, withAttributeValueID(id))
	return &AttributeValueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AttributeValue.
func (c *AttributeValueClient) Delete() *AttributeValueDelete {
	mutation := newAttributeValueMutation(c.config, OpDelete)
	return &AttributeValueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AttributeValueClient) DeleteOne(av *AttributeValue) *AttributeValueDeleteOne {
	return c.DeleteOneID(av.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AttributeValueClient) DeleteOneID(id string) *AttributeValueDeleteOne {
	builder := c.Delete().Where(attributevalue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttributeValueDeleteOne{builder}
}

// Query returns a query builder for AttributeValue.
func (c *AttributeValueClient) Query() *AttributeValueQuery {
	return &AttributeValueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAttributeValue},
		inters: c.Interceptors(),
	}
}

// Get returns a AttributeValue entity by its id.
func (c *AttributeValueClient) Get(ctx context.Context, id string) (*AttributeValue, error) {
	return c.Query().Where(attributevalue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttributeValueClient) GetX(ctx context.Context, id string) *AttributeValue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttribute queries the attribute edge of a AttributeValue.
func (c *AttributeValueClient) QueryAttribute(av *AttributeValue) *AttributeQuery {
	query := (&AttributeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := av.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attributevalue.Table, attributevalue.FieldID, id),
			sqlgraph.To(attribute.Table, attribute.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attributevalue.AttributeTable, attributevalue.AttributeColumn),
		)
		fromV = sqlgraph.Neighbors(av.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVariant queries the variant edge of a AttributeValue.
func (c *AttributeValueClient) QueryVariant(av *AttributeValue) *VariantQuery {
	query := (&VariantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := av.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attributevalue.Table, attributevalue.FieldID, id),
			sqlgraph.To(variant.Table, variant.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, attributevalue.VariantTable, attributevalue.VariantPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(av.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVariantAttributeRel queries the variant_attribute_rel edge of a AttributeValue.
func (c *AttributeValueClient) QueryVariantAttributeRel(av *AttributeValue) *VariantAttributeRelQuery {
	query := (&VariantAttributeRelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := av.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attributevalue.Table, attributevalue.FieldID, id),
			sqlgraph.To(variantattributerel.Table, variantattributerel.AttributeValueColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, attributevalue.VariantAttributeRelTable, attributevalue.VariantAttributeRelColumn),
		)
		fromV = sqlgraph.Neighbors(av.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AttributeValueClient) Hooks() []Hook {
	return c.hooks.AttributeValue
}

// Interceptors returns the client interceptors.
func (c *AttributeValueClient) Interceptors() []Interceptor {
	return c.inters.AttributeValue
}

func (c *AttributeValueClient) mutate(ctx context.Context, m *AttributeValueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AttributeValueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AttributeValueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AttributeValueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AttributeValueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AttributeValue mutation op: %q", m.Op())
	}
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `product.Intercept(f(g(h())))`.
func (c *ProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.Product = append(c.inters.Product, interceptors...)
}

// Create returns a builder for creating a Product entity.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Product entities.
func (c *ProductClient) CreateBulk(builders ...*ProductCreate) *ProductCreateBulk {
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductClient) MapCreateBulk(slice any, setFunc func(*ProductCreate, int)) *ProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCreateBulk{err: fmt.Errorf("calling to ProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id string) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductClient) DeleteOneID(id string) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Query returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id string) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id string) *Product {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVariant queries the variant edge of a Product.
func (c *ProductClient) QueryVariant(pr *Product) *VariantQuery {
	query := (&VariantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(variant.Table, variant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, product.VariantTable, product.VariantColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttribute queries the attribute edge of a Product.
func (c *ProductClient) QueryAttribute(pr *Product) *AttributeQuery {
	query := (&AttributeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(attribute.Table, attribute.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, product.AttributeTable, product.AttributeColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttributeGroup queries the attribute_group edge of a Product.
func (c *ProductClient) QueryAttributeGroup(pr *Product) *AttributeGroupQuery {
	query := (&AttributeGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(attributegroup.Table, attributegroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, product.AttributeGroupTable, product.AttributeGroupColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUnit queries the unit edge of a Product.
func (c *ProductClient) QueryUnit(pr *Product) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, product.UnitTable, product.UnitColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}

// Interceptors returns the client interceptors.
func (c *ProductClient) Interceptors() []Interceptor {
	return c.inters.Product
}

func (c *ProductClient) mutate(ctx context.Context, m *ProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Product mutation op: %q", m.Op())
	}
}

// ProductCategoryClient is a client for the ProductCategory schema.
type ProductCategoryClient struct {
	config
}

// NewProductCategoryClient returns a client for the ProductCategory from the given config.
func NewProductCategoryClient(c config) *ProductCategoryClient {
	return &ProductCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productcategory.Hooks(f(g(h())))`.
func (c *ProductCategoryClient) Use(hooks ...Hook) {
	c.hooks.ProductCategory = append(c.hooks.ProductCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productcategory.Intercept(f(g(h())))`.
func (c *ProductCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductCategory = append(c.inters.ProductCategory, interceptors...)
}

// Create returns a builder for creating a ProductCategory entity.
func (c *ProductCategoryClient) Create() *ProductCategoryCreate {
	mutation := newProductCategoryMutation(c.config, OpCreate)
	return &ProductCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductCategory entities.
func (c *ProductCategoryClient) CreateBulk(builders ...*ProductCategoryCreate) *ProductCategoryCreateBulk {
	return &ProductCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductCategoryClient) MapCreateBulk(slice any, setFunc func(*ProductCategoryCreate, int)) *ProductCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCategoryCreateBulk{err: fmt.Errorf("calling to ProductCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductCategory.
func (c *ProductCategoryClient) Update() *ProductCategoryUpdate {
	mutation := newProductCategoryMutation(c.config, OpUpdate)
	return &ProductCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductCategoryClient) UpdateOne(pc *ProductCategory) *ProductCategoryUpdateOne {
	mutation := newProductCategoryMutation(c.config, OpUpdateOne, withProductCategory(pc))
	return &ProductCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductCategoryClient) UpdateOneID(id string) *ProductCategoryUpdateOne {
	mutation := newProductCategoryMutation(c.config, OpUpdateOne, withProductCategoryID(id))
	return &ProductCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductCategory.
func (c *ProductCategoryClient) Delete() *ProductCategoryDelete {
	mutation := newProductCategoryMutation(c.config, OpDelete)
	return &ProductCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductCategoryClient) DeleteOne(pc *ProductCategory) *ProductCategoryDeleteOne {
	return c.DeleteOneID(pc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductCategoryClient) DeleteOneID(id string) *ProductCategoryDeleteOne {
	builder := c.Delete().Where(productcategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductCategoryDeleteOne{builder}
}

// Query returns a query builder for ProductCategory.
func (c *ProductCategoryClient) Query() *ProductCategoryQuery {
	return &ProductCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductCategory entity by its id.
func (c *ProductCategoryClient) Get(ctx context.Context, id string) (*ProductCategory, error) {
	return c.Query().Where(productcategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductCategoryClient) GetX(ctx context.Context, id string) *ProductCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProductCategoryClient) Hooks() []Hook {
	return c.hooks.ProductCategory
}

// Interceptors returns the client interceptors.
func (c *ProductCategoryClient) Interceptors() []Interceptor {
	return c.inters.ProductCategory
}

func (c *ProductCategoryClient) mutate(ctx context.Context, m *ProductCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductCategory mutation op: %q", m.Op())
	}
}

// UnitClient is a client for the Unit schema.
type UnitClient struct {
	config
}

// NewUnitClient returns a client for the Unit from the given config.
func NewUnitClient(c config) *UnitClient {
	return &UnitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `unit.Hooks(f(g(h())))`.
func (c *UnitClient) Use(hooks ...Hook) {
	c.hooks.Unit = append(c.hooks.Unit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `unit.Intercept(f(g(h())))`.
func (c *UnitClient) Intercept(interceptors ...Interceptor) {
	c.inters.Unit = append(c.inters.Unit, interceptors...)
}

// Create returns a builder for creating a Unit entity.
func (c *UnitClient) Create() *UnitCreate {
	mutation := newUnitMutation(c.config, OpCreate)
	return &UnitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Unit entities.
func (c *UnitClient) CreateBulk(builders ...*UnitCreate) *UnitCreateBulk {
	return &UnitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UnitClient) MapCreateBulk(slice any, setFunc func(*UnitCreate, int)) *UnitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UnitCreateBulk{err: fmt.Errorf("calling to UnitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UnitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UnitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Unit.
func (c *UnitClient) Update() *UnitUpdate {
	mutation := newUnitMutation(c.config, OpUpdate)
	return &UnitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UnitClient) UpdateOne(u *Unit) *UnitUpdateOne {
	mutation := newUnitMutation(c.config, OpUpdateOne, withUnit(u))
	return &UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UnitClient) UpdateOneID(id string) *UnitUpdateOne {
	mutation := newUnitMutation(c.config, OpUpdateOne, withUnitID(id))
	return &UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Unit.
func (c *UnitClient) Delete() *UnitDelete {
	mutation := newUnitMutation(c.config, OpDelete)
	return &UnitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UnitClient) DeleteOne(u *Unit) *UnitDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UnitClient) DeleteOneID(id string) *UnitDeleteOne {
	builder := c.Delete().Where(unit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UnitDeleteOne{builder}
}

// Query returns a query builder for Unit.
func (c *UnitClient) Query() *UnitQuery {
	return &UnitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUnit},
		inters: c.Interceptors(),
	}
}

// Get returns a Unit entity by its id.
func (c *UnitClient) Get(ctx context.Context, id string) (*Unit, error) {
	return c.Query().Where(unit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UnitClient) GetX(ctx context.Context, id string) *Unit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a Unit.
func (c *UnitClient) QueryProduct(u *Unit) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, unit.ProductTable, unit.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUnitCategory queries the unit_category edge of a Unit.
func (c *UnitClient) QueryUnitCategory(u *Unit) *UnitCategoryQuery {
	query := (&UnitCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(unitcategory.Table, unitcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, unit.UnitCategoryTable, unit.UnitCategoryColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UnitClient) Hooks() []Hook {
	return c.hooks.Unit
}

// Interceptors returns the client interceptors.
func (c *UnitClient) Interceptors() []Interceptor {
	return c.inters.Unit
}

func (c *UnitClient) mutate(ctx context.Context, m *UnitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UnitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UnitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UnitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Unit mutation op: %q", m.Op())
	}
}

// UnitCategoryClient is a client for the UnitCategory schema.
type UnitCategoryClient struct {
	config
}

// NewUnitCategoryClient returns a client for the UnitCategory from the given config.
func NewUnitCategoryClient(c config) *UnitCategoryClient {
	return &UnitCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `unitcategory.Hooks(f(g(h())))`.
func (c *UnitCategoryClient) Use(hooks ...Hook) {
	c.hooks.UnitCategory = append(c.hooks.UnitCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `unitcategory.Intercept(f(g(h())))`.
func (c *UnitCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.UnitCategory = append(c.inters.UnitCategory, interceptors...)
}

// Create returns a builder for creating a UnitCategory entity.
func (c *UnitCategoryClient) Create() *UnitCategoryCreate {
	mutation := newUnitCategoryMutation(c.config, OpCreate)
	return &UnitCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UnitCategory entities.
func (c *UnitCategoryClient) CreateBulk(builders ...*UnitCategoryCreate) *UnitCategoryCreateBulk {
	return &UnitCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UnitCategoryClient) MapCreateBulk(slice any, setFunc func(*UnitCategoryCreate, int)) *UnitCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UnitCategoryCreateBulk{err: fmt.Errorf("calling to UnitCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UnitCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UnitCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UnitCategory.
func (c *UnitCategoryClient) Update() *UnitCategoryUpdate {
	mutation := newUnitCategoryMutation(c.config, OpUpdate)
	return &UnitCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UnitCategoryClient) UpdateOne(uc *UnitCategory) *UnitCategoryUpdateOne {
	mutation := newUnitCategoryMutation(c.config, OpUpdateOne, withUnitCategory(uc))
	return &UnitCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UnitCategoryClient) UpdateOneID(id string) *UnitCategoryUpdateOne {
	mutation := newUnitCategoryMutation(c.config, OpUpdateOne, withUnitCategoryID(id))
	return &UnitCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UnitCategory.
func (c *UnitCategoryClient) Delete() *UnitCategoryDelete {
	mutation := newUnitCategoryMutation(c.config, OpDelete)
	return &UnitCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UnitCategoryClient) DeleteOne(uc *UnitCategory) *UnitCategoryDeleteOne {
	return c.DeleteOneID(uc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UnitCategoryClient) DeleteOneID(id string) *UnitCategoryDeleteOne {
	builder := c.Delete().Where(unitcategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UnitCategoryDeleteOne{builder}
}

// Query returns a query builder for UnitCategory.
func (c *UnitCategoryClient) Query() *UnitCategoryQuery {
	return &UnitCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUnitCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a UnitCategory entity by its id.
func (c *UnitCategoryClient) Get(ctx context.Context, id string) (*UnitCategory, error) {
	return c.Query().Where(unitcategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UnitCategoryClient) GetX(ctx context.Context, id string) *UnitCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUnit queries the unit edge of a UnitCategory.
func (c *UnitCategoryClient) QueryUnit(uc *UnitCategory) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unitcategory.Table, unitcategory.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, unitcategory.UnitTable, unitcategory.UnitColumn),
		)
		fromV = sqlgraph.Neighbors(uc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UnitCategoryClient) Hooks() []Hook {
	return c.hooks.UnitCategory
}

// Interceptors returns the client interceptors.
func (c *UnitCategoryClient) Interceptors() []Interceptor {
	return c.inters.UnitCategory
}

func (c *UnitCategoryClient) mutate(ctx context.Context, m *UnitCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UnitCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UnitCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UnitCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UnitCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UnitCategory mutation op: %q", m.Op())
	}
}

// VariantClient is a client for the Variant schema.
type VariantClient struct {
	config
}

// NewVariantClient returns a client for the Variant from the given config.
func NewVariantClient(c config) *VariantClient {
	return &VariantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `variant.Hooks(f(g(h())))`.
func (c *VariantClient) Use(hooks ...Hook) {
	c.hooks.Variant = append(c.hooks.Variant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `variant.Intercept(f(g(h())))`.
func (c *VariantClient) Intercept(interceptors ...Interceptor) {
	c.inters.Variant = append(c.inters.Variant, interceptors...)
}

// Create returns a builder for creating a Variant entity.
func (c *VariantClient) Create() *VariantCreate {
	mutation := newVariantMutation(c.config, OpCreate)
	return &VariantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Variant entities.
func (c *VariantClient) CreateBulk(builders ...*VariantCreate) *VariantCreateBulk {
	return &VariantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VariantClient) MapCreateBulk(slice any, setFunc func(*VariantCreate, int)) *VariantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VariantCreateBulk{err: fmt.Errorf("calling to VariantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VariantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VariantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Variant.
func (c *VariantClient) Update() *VariantUpdate {
	mutation := newVariantMutation(c.config, OpUpdate)
	return &VariantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VariantClient) UpdateOne(v *Variant) *VariantUpdateOne {
	mutation := newVariantMutation(c.config, OpUpdateOne, withVariant(v))
	return &VariantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VariantClient) UpdateOneID(id string) *VariantUpdateOne {
	mutation := newVariantMutation(c.config, OpUpdateOne, withVariantID(id))
	return &VariantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Variant.
func (c *VariantClient) Delete() *VariantDelete {
	mutation := newVariantMutation(c.config, OpDelete)
	return &VariantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VariantClient) DeleteOne(v *Variant) *VariantDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VariantClient) DeleteOneID(id string) *VariantDeleteOne {
	builder := c.Delete().Where(variant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VariantDeleteOne{builder}
}

// Query returns a query builder for Variant.
func (c *VariantClient) Query() *VariantQuery {
	return &VariantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVariant},
		inters: c.Interceptors(),
	}
}

// Get returns a Variant entity by its id.
func (c *VariantClient) Get(ctx context.Context, id string) (*Variant, error) {
	return c.Query().Where(variant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VariantClient) GetX(ctx context.Context, id string) *Variant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a Variant.
func (c *VariantClient) QueryProduct(v *Variant) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(variant.Table, variant.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, variant.ProductTable, variant.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttributeValue queries the attribute_value edge of a Variant.
func (c *VariantClient) QueryAttributeValue(v *Variant) *AttributeValueQuery {
	query := (&AttributeValueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(variant.Table, variant.FieldID, id),
			sqlgraph.To(attributevalue.Table, attributevalue.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, variant.AttributeValueTable, variant.AttributeValuePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVariantAttributeRel queries the variant_attribute_rel edge of a Variant.
func (c *VariantClient) QueryVariantAttributeRel(v *Variant) *VariantAttributeRelQuery {
	query := (&VariantAttributeRelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(variant.Table, variant.FieldID, id),
			sqlgraph.To(variantattributerel.Table, variantattributerel.VariantColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, variant.VariantAttributeRelTable, variant.VariantAttributeRelColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VariantClient) Hooks() []Hook {
	return c.hooks.Variant
}

// Interceptors returns the client interceptors.
func (c *VariantClient) Interceptors() []Interceptor {
	return c.inters.Variant
}

func (c *VariantClient) mutate(ctx context.Context, m *VariantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VariantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VariantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VariantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VariantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Variant mutation op: %q", m.Op())
	}
}

// VariantAttributeRelClient is a client for the VariantAttributeRel schema.
type VariantAttributeRelClient struct {
	config
}

// NewVariantAttributeRelClient returns a client for the VariantAttributeRel from the given config.
func NewVariantAttributeRelClient(c config) *VariantAttributeRelClient {
	return &VariantAttributeRelClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `variantattributerel.Hooks(f(g(h())))`.
func (c *VariantAttributeRelClient) Use(hooks ...Hook) {
	c.hooks.VariantAttributeRel = append(c.hooks.VariantAttributeRel, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `variantattributerel.Intercept(f(g(h())))`.
func (c *VariantAttributeRelClient) Intercept(interceptors ...Interceptor) {
	c.inters.VariantAttributeRel = append(c.inters.VariantAttributeRel, interceptors...)
}

// Create returns a builder for creating a VariantAttributeRel entity.
func (c *VariantAttributeRelClient) Create() *VariantAttributeRelCreate {
	mutation := newVariantAttributeRelMutation(c.config, OpCreate)
	return &VariantAttributeRelCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VariantAttributeRel entities.
func (c *VariantAttributeRelClient) CreateBulk(builders ...*VariantAttributeRelCreate) *VariantAttributeRelCreateBulk {
	return &VariantAttributeRelCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VariantAttributeRelClient) MapCreateBulk(slice any, setFunc func(*VariantAttributeRelCreate, int)) *VariantAttributeRelCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VariantAttributeRelCreateBulk{err: fmt.Errorf("calling to VariantAttributeRelClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VariantAttributeRelCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VariantAttributeRelCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VariantAttributeRel.
func (c *VariantAttributeRelClient) Update() *VariantAttributeRelUpdate {
	mutation := newVariantAttributeRelMutation(c.config, OpUpdate)
	return &VariantAttributeRelUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VariantAttributeRelClient) UpdateOne(_var *VariantAttributeRel) *VariantAttributeRelUpdateOne {
	mutation := newVariantAttributeRelMutation(c.config, OpUpdateOne)
	mutation.variant = &_var.VariantID
	mutation.attribute_value = &_var.AttributeValueID
	return &VariantAttributeRelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VariantAttributeRel.
func (c *VariantAttributeRelClient) Delete() *VariantAttributeRelDelete {
	mutation := newVariantAttributeRelMutation(c.config, OpDelete)
	return &VariantAttributeRelDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for VariantAttributeRel.
func (c *VariantAttributeRelClient) Query() *VariantAttributeRelQuery {
	return &VariantAttributeRelQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVariantAttributeRel},
		inters: c.Interceptors(),
	}
}

// QueryVariant queries the variant edge of a VariantAttributeRel.
func (c *VariantAttributeRelClient) QueryVariant(_var *VariantAttributeRel) *VariantQuery {
	return c.Query().
		Where(variantattributerel.VariantID(_var.VariantID), variantattributerel.AttributeValueID(_var.AttributeValueID)).
		QueryVariant()
}

// QueryAttributeValue queries the attribute_value edge of a VariantAttributeRel.
func (c *VariantAttributeRelClient) QueryAttributeValue(_var *VariantAttributeRel) *AttributeValueQuery {
	return c.Query().
		Where(variantattributerel.VariantID(_var.VariantID), variantattributerel.AttributeValueID(_var.AttributeValueID)).
		QueryAttributeValue()
}

// Hooks returns the client hooks.
func (c *VariantAttributeRelClient) Hooks() []Hook {
	return c.hooks.VariantAttributeRel
}

// Interceptors returns the client interceptors.
func (c *VariantAttributeRelClient) Interceptors() []Interceptor {
	return c.inters.VariantAttributeRel
}

func (c *VariantAttributeRelClient) mutate(ctx context.Context, m *VariantAttributeRelMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VariantAttributeRelCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VariantAttributeRelUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VariantAttributeRelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VariantAttributeRelDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VariantAttributeRel mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Attribute, AttributeGroup, AttributeValue, Product, ProductCategory, Unit,
		UnitCategory, Variant, VariantAttributeRel []ent.Hook
	}
	inters struct {
		Attribute, AttributeGroup, AttributeValue, Product, ProductCategory, Unit,
		UnitCategory, Variant, VariantAttributeRel []ent.Interceptor
	}
)
