// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/sky-as-code/nikki-erp/common/model"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/attribute"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/attributegroup"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/attributevalue"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/predicate"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/product"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/productcategory"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/unit"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/unitcategory"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/variant"
	"github.com/sky-as-code/nikki-erp/modules/inventory/infra/ent/variantattributerel"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttribute           = "Attribute"
	TypeAttributeGroup      = "AttributeGroup"
	TypeAttributeValue      = "AttributeValue"
	TypeProduct             = "Product"
	TypeProductCategory     = "ProductCategory"
	TypeUnit                = "Unit"
	TypeUnitCategory        = "UnitCategory"
	TypeVariant             = "Variant"
	TypeVariantAttributeRel = "VariantAttributeRel"
)

// AttributeMutation represents an operation that mutates the Attribute nodes in the graph.
type AttributeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	code_name               *string
	created_at              *time.Time
	data_type               *string
	display_name            *model.LangJson
	enum_value_sort         *bool
	enum_value              *model.LangJson
	etag                    *string
	is_enum                 *bool
	is_required             *bool
	sort_index              *int
	addsort_index           *int
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	attribute_group         *string
	clearedattribute_group  bool
	product                 *string
	clearedproduct          bool
	attribute_values        map[string]struct{}
	removedattribute_values map[string]struct{}
	clearedattribute_values bool
	done                    bool
	oldValue                func(context.Context) (*Attribute, error)
	predicates              []predicate.Attribute
}

var _ ent.Mutation = (*AttributeMutation)(nil)

// attributeOption allows management of the mutation configuration using functional options.
type attributeOption func(*AttributeMutation)

// newAttributeMutation creates new mutation for the Attribute entity.
func newAttributeMutation(c config, op Op, opts ...attributeOption) *AttributeMutation {
	m := &AttributeMutation{
		config:        c,
		op:            op,
		typ:           TypeAttribute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttributeID sets the ID field of the mutation.
func withAttributeID(id string) attributeOption {
	return func(m *AttributeMutation) {
		var (
			err   error
			once  sync.Once
			value *Attribute
		)
		m.oldValue = func(ctx context.Context) (*Attribute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attribute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttribute sets the old Attribute of the mutation.
func withAttribute(node *Attribute) attributeOption {
	return func(m *AttributeMutation) {
		m.oldValue = func(context.Context) (*Attribute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttributeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttributeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attribute entities.
func (m *AttributeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttributeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttributeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attribute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCodeName sets the "code_name" field.
func (m *AttributeMutation) SetCodeName(s string) {
	m.code_name = &s
}

// CodeName returns the value of the "code_name" field in the mutation.
func (m *AttributeMutation) CodeName() (r string, exists bool) {
	v := m.code_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeName returns the old "code_name" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldCodeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeName: %w", err)
	}
	return oldValue.CodeName, nil
}

// ResetCodeName resets all changes to the "code_name" field.
func (m *AttributeMutation) ResetCodeName() {
	m.code_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AttributeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttributeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttributeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDataType sets the "data_type" field.
func (m *AttributeMutation) SetDataType(s string) {
	m.data_type = &s
}

// DataType returns the value of the "data_type" field in the mutation.
func (m *AttributeMutation) DataType() (r string, exists bool) {
	v := m.data_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDataType returns the old "data_type" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldDataType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataType: %w", err)
	}
	return oldValue.DataType, nil
}

// ResetDataType resets all changes to the "data_type" field.
func (m *AttributeMutation) ResetDataType() {
	m.data_type = nil
}

// SetDisplayName sets the "display_name" field.
func (m *AttributeMutation) SetDisplayName(mj model.LangJson) {
	m.display_name = &mj
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *AttributeMutation) DisplayName() (r model.LangJson, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldDisplayName(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *AttributeMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[attribute.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *AttributeMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[attribute.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *AttributeMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, attribute.FieldDisplayName)
}

// SetEnumValueSort sets the "enum_value_sort" field.
func (m *AttributeMutation) SetEnumValueSort(b bool) {
	m.enum_value_sort = &b
}

// EnumValueSort returns the value of the "enum_value_sort" field in the mutation.
func (m *AttributeMutation) EnumValueSort() (r bool, exists bool) {
	v := m.enum_value_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumValueSort returns the old "enum_value_sort" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldEnumValueSort(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnumValueSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnumValueSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumValueSort: %w", err)
	}
	return oldValue.EnumValueSort, nil
}

// ResetEnumValueSort resets all changes to the "enum_value_sort" field.
func (m *AttributeMutation) ResetEnumValueSort() {
	m.enum_value_sort = nil
}

// SetEnumValue sets the "enum_value" field.
func (m *AttributeMutation) SetEnumValue(mj model.LangJson) {
	m.enum_value = &mj
}

// EnumValue returns the value of the "enum_value" field in the mutation.
func (m *AttributeMutation) EnumValue() (r model.LangJson, exists bool) {
	v := m.enum_value
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumValue returns the old "enum_value" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldEnumValue(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnumValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnumValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumValue: %w", err)
	}
	return oldValue.EnumValue, nil
}

// ClearEnumValue clears the value of the "enum_value" field.
func (m *AttributeMutation) ClearEnumValue() {
	m.enum_value = nil
	m.clearedFields[attribute.FieldEnumValue] = struct{}{}
}

// EnumValueCleared returns if the "enum_value" field was cleared in this mutation.
func (m *AttributeMutation) EnumValueCleared() bool {
	_, ok := m.clearedFields[attribute.FieldEnumValue]
	return ok
}

// ResetEnumValue resets all changes to the "enum_value" field.
func (m *AttributeMutation) ResetEnumValue() {
	m.enum_value = nil
	delete(m.clearedFields, attribute.FieldEnumValue)
}

// SetEtag sets the "etag" field.
func (m *AttributeMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *AttributeMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *AttributeMutation) ResetEtag() {
	m.etag = nil
}

// SetGroupID sets the "group_id" field.
func (m *AttributeMutation) SetGroupID(s string) {
	m.attribute_group = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *AttributeMutation) GroupID() (r string, exists bool) {
	v := m.attribute_group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldGroupID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *AttributeMutation) ClearGroupID() {
	m.attribute_group = nil
	m.clearedFields[attribute.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *AttributeMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[attribute.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *AttributeMutation) ResetGroupID() {
	m.attribute_group = nil
	delete(m.clearedFields, attribute.FieldGroupID)
}

// SetIsEnum sets the "is_enum" field.
func (m *AttributeMutation) SetIsEnum(b bool) {
	m.is_enum = &b
}

// IsEnum returns the value of the "is_enum" field in the mutation.
func (m *AttributeMutation) IsEnum() (r bool, exists bool) {
	v := m.is_enum
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnum returns the old "is_enum" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldIsEnum(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnum: %w", err)
	}
	return oldValue.IsEnum, nil
}

// ResetIsEnum resets all changes to the "is_enum" field.
func (m *AttributeMutation) ResetIsEnum() {
	m.is_enum = nil
}

// SetIsRequired sets the "is_required" field.
func (m *AttributeMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *AttributeMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *AttributeMutation) ResetIsRequired() {
	m.is_required = nil
}

// SetProductID sets the "product_id" field.
func (m *AttributeMutation) SetProductID(s string) {
	m.product = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *AttributeMutation) ProductID() (r string, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *AttributeMutation) ResetProductID() {
	m.product = nil
}

// SetSortIndex sets the "sort_index" field.
func (m *AttributeMutation) SetSortIndex(i int) {
	m.sort_index = &i
	m.addsort_index = nil
}

// SortIndex returns the value of the "sort_index" field in the mutation.
func (m *AttributeMutation) SortIndex() (r int, exists bool) {
	v := m.sort_index
	if v == nil {
		return
	}
	return *v, true
}

// OldSortIndex returns the old "sort_index" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldSortIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortIndex: %w", err)
	}
	return oldValue.SortIndex, nil
}

// AddSortIndex adds i to the "sort_index" field.
func (m *AttributeMutation) AddSortIndex(i int) {
	if m.addsort_index != nil {
		*m.addsort_index += i
	} else {
		m.addsort_index = &i
	}
}

// AddedSortIndex returns the value that was added to the "sort_index" field in this mutation.
func (m *AttributeMutation) AddedSortIndex() (r int, exists bool) {
	v := m.addsort_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortIndex resets all changes to the "sort_index" field.
func (m *AttributeMutation) ResetSortIndex() {
	m.sort_index = nil
	m.addsort_index = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttributeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttributeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AttributeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[attribute.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AttributeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[attribute.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttributeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, attribute.FieldUpdatedAt)
}

// SetAttributeGroupID sets the "attribute_group" edge to the AttributeGroup entity by id.
func (m *AttributeMutation) SetAttributeGroupID(id string) {
	m.attribute_group = &id
}

// ClearAttributeGroup clears the "attribute_group" edge to the AttributeGroup entity.
func (m *AttributeMutation) ClearAttributeGroup() {
	m.clearedattribute_group = true
	m.clearedFields[attribute.FieldGroupID] = struct{}{}
}

// AttributeGroupCleared reports if the "attribute_group" edge to the AttributeGroup entity was cleared.
func (m *AttributeMutation) AttributeGroupCleared() bool {
	return m.GroupIDCleared() || m.clearedattribute_group
}

// AttributeGroupID returns the "attribute_group" edge ID in the mutation.
func (m *AttributeMutation) AttributeGroupID() (id string, exists bool) {
	if m.attribute_group != nil {
		return *m.attribute_group, true
	}
	return
}

// AttributeGroupIDs returns the "attribute_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttributeGroupID instead. It exists only for internal usage by the builders.
func (m *AttributeMutation) AttributeGroupIDs() (ids []string) {
	if id := m.attribute_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttributeGroup resets all changes to the "attribute_group" edge.
func (m *AttributeMutation) ResetAttributeGroup() {
	m.attribute_group = nil
	m.clearedattribute_group = false
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *AttributeMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[attribute.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *AttributeMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *AttributeMutation) ProductIDs() (ids []string) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *AttributeMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// AddAttributeValueIDs adds the "attribute_values" edge to the AttributeValue entity by ids.
func (m *AttributeMutation) AddAttributeValueIDs(ids ...string) {
	if m.attribute_values == nil {
		m.attribute_values = make(map[string]struct{})
	}
	for i := range ids {
		m.attribute_values[ids[i]] = struct{}{}
	}
}

// ClearAttributeValues clears the "attribute_values" edge to the AttributeValue entity.
func (m *AttributeMutation) ClearAttributeValues() {
	m.clearedattribute_values = true
}

// AttributeValuesCleared reports if the "attribute_values" edge to the AttributeValue entity was cleared.
func (m *AttributeMutation) AttributeValuesCleared() bool {
	return m.clearedattribute_values
}

// RemoveAttributeValueIDs removes the "attribute_values" edge to the AttributeValue entity by IDs.
func (m *AttributeMutation) RemoveAttributeValueIDs(ids ...string) {
	if m.removedattribute_values == nil {
		m.removedattribute_values = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.attribute_values, ids[i])
		m.removedattribute_values[ids[i]] = struct{}{}
	}
}

// RemovedAttributeValues returns the removed IDs of the "attribute_values" edge to the AttributeValue entity.
func (m *AttributeMutation) RemovedAttributeValuesIDs() (ids []string) {
	for id := range m.removedattribute_values {
		ids = append(ids, id)
	}
	return
}

// AttributeValuesIDs returns the "attribute_values" edge IDs in the mutation.
func (m *AttributeMutation) AttributeValuesIDs() (ids []string) {
	for id := range m.attribute_values {
		ids = append(ids, id)
	}
	return
}

// ResetAttributeValues resets all changes to the "attribute_values" edge.
func (m *AttributeMutation) ResetAttributeValues() {
	m.attribute_values = nil
	m.clearedattribute_values = false
	m.removedattribute_values = nil
}

// Where appends a list predicates to the AttributeMutation builder.
func (m *AttributeMutation) Where(ps ...predicate.Attribute) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttributeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttributeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attribute, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttributeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttributeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attribute).
func (m *AttributeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttributeMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.code_name != nil {
		fields = append(fields, attribute.FieldCodeName)
	}
	if m.created_at != nil {
		fields = append(fields, attribute.FieldCreatedAt)
	}
	if m.data_type != nil {
		fields = append(fields, attribute.FieldDataType)
	}
	if m.display_name != nil {
		fields = append(fields, attribute.FieldDisplayName)
	}
	if m.enum_value_sort != nil {
		fields = append(fields, attribute.FieldEnumValueSort)
	}
	if m.enum_value != nil {
		fields = append(fields, attribute.FieldEnumValue)
	}
	if m.etag != nil {
		fields = append(fields, attribute.FieldEtag)
	}
	if m.attribute_group != nil {
		fields = append(fields, attribute.FieldGroupID)
	}
	if m.is_enum != nil {
		fields = append(fields, attribute.FieldIsEnum)
	}
	if m.is_required != nil {
		fields = append(fields, attribute.FieldIsRequired)
	}
	if m.product != nil {
		fields = append(fields, attribute.FieldProductID)
	}
	if m.sort_index != nil {
		fields = append(fields, attribute.FieldSortIndex)
	}
	if m.updated_at != nil {
		fields = append(fields, attribute.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttributeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attribute.FieldCodeName:
		return m.CodeName()
	case attribute.FieldCreatedAt:
		return m.CreatedAt()
	case attribute.FieldDataType:
		return m.DataType()
	case attribute.FieldDisplayName:
		return m.DisplayName()
	case attribute.FieldEnumValueSort:
		return m.EnumValueSort()
	case attribute.FieldEnumValue:
		return m.EnumValue()
	case attribute.FieldEtag:
		return m.Etag()
	case attribute.FieldGroupID:
		return m.GroupID()
	case attribute.FieldIsEnum:
		return m.IsEnum()
	case attribute.FieldIsRequired:
		return m.IsRequired()
	case attribute.FieldProductID:
		return m.ProductID()
	case attribute.FieldSortIndex:
		return m.SortIndex()
	case attribute.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttributeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attribute.FieldCodeName:
		return m.OldCodeName(ctx)
	case attribute.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attribute.FieldDataType:
		return m.OldDataType(ctx)
	case attribute.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case attribute.FieldEnumValueSort:
		return m.OldEnumValueSort(ctx)
	case attribute.FieldEnumValue:
		return m.OldEnumValue(ctx)
	case attribute.FieldEtag:
		return m.OldEtag(ctx)
	case attribute.FieldGroupID:
		return m.OldGroupID(ctx)
	case attribute.FieldIsEnum:
		return m.OldIsEnum(ctx)
	case attribute.FieldIsRequired:
		return m.OldIsRequired(ctx)
	case attribute.FieldProductID:
		return m.OldProductID(ctx)
	case attribute.FieldSortIndex:
		return m.OldSortIndex(ctx)
	case attribute.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Attribute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attribute.FieldCodeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeName(v)
		return nil
	case attribute.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attribute.FieldDataType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataType(v)
		return nil
	case attribute.FieldDisplayName:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case attribute.FieldEnumValueSort:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumValueSort(v)
		return nil
	case attribute.FieldEnumValue:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumValue(v)
		return nil
	case attribute.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case attribute.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case attribute.FieldIsEnum:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnum(v)
		return nil
	case attribute.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	case attribute.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case attribute.FieldSortIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortIndex(v)
		return nil
	case attribute.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttributeMutation) AddedFields() []string {
	var fields []string
	if m.addsort_index != nil {
		fields = append(fields, attribute.FieldSortIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttributeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attribute.FieldSortIndex:
		return m.AddedSortIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attribute.FieldSortIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Attribute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttributeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attribute.FieldDisplayName) {
		fields = append(fields, attribute.FieldDisplayName)
	}
	if m.FieldCleared(attribute.FieldEnumValue) {
		fields = append(fields, attribute.FieldEnumValue)
	}
	if m.FieldCleared(attribute.FieldGroupID) {
		fields = append(fields, attribute.FieldGroupID)
	}
	if m.FieldCleared(attribute.FieldUpdatedAt) {
		fields = append(fields, attribute.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttributeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttributeMutation) ClearField(name string) error {
	switch name {
	case attribute.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case attribute.FieldEnumValue:
		m.ClearEnumValue()
		return nil
	case attribute.FieldGroupID:
		m.ClearGroupID()
		return nil
	case attribute.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Attribute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttributeMutation) ResetField(name string) error {
	switch name {
	case attribute.FieldCodeName:
		m.ResetCodeName()
		return nil
	case attribute.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attribute.FieldDataType:
		m.ResetDataType()
		return nil
	case attribute.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case attribute.FieldEnumValueSort:
		m.ResetEnumValueSort()
		return nil
	case attribute.FieldEnumValue:
		m.ResetEnumValue()
		return nil
	case attribute.FieldEtag:
		m.ResetEtag()
		return nil
	case attribute.FieldGroupID:
		m.ResetGroupID()
		return nil
	case attribute.FieldIsEnum:
		m.ResetIsEnum()
		return nil
	case attribute.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	case attribute.FieldProductID:
		m.ResetProductID()
		return nil
	case attribute.FieldSortIndex:
		m.ResetSortIndex()
		return nil
	case attribute.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttributeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.attribute_group != nil {
		edges = append(edges, attribute.EdgeAttributeGroup)
	}
	if m.product != nil {
		edges = append(edges, attribute.EdgeProduct)
	}
	if m.attribute_values != nil {
		edges = append(edges, attribute.EdgeAttributeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttributeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attribute.EdgeAttributeGroup:
		if id := m.attribute_group; id != nil {
			return []ent.Value{*id}
		}
	case attribute.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case attribute.EdgeAttributeValues:
		ids := make([]ent.Value, 0, len(m.attribute_values))
		for id := range m.attribute_values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttributeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedattribute_values != nil {
		edges = append(edges, attribute.EdgeAttributeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttributeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case attribute.EdgeAttributeValues:
		ids := make([]ent.Value, 0, len(m.removedattribute_values))
		for id := range m.removedattribute_values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttributeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedattribute_group {
		edges = append(edges, attribute.EdgeAttributeGroup)
	}
	if m.clearedproduct {
		edges = append(edges, attribute.EdgeProduct)
	}
	if m.clearedattribute_values {
		edges = append(edges, attribute.EdgeAttributeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttributeMutation) EdgeCleared(name string) bool {
	switch name {
	case attribute.EdgeAttributeGroup:
		return m.clearedattribute_group
	case attribute.EdgeProduct:
		return m.clearedproduct
	case attribute.EdgeAttributeValues:
		return m.clearedattribute_values
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttributeMutation) ClearEdge(name string) error {
	switch name {
	case attribute.EdgeAttributeGroup:
		m.ClearAttributeGroup()
		return nil
	case attribute.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Attribute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttributeMutation) ResetEdge(name string) error {
	switch name {
	case attribute.EdgeAttributeGroup:
		m.ResetAttributeGroup()
		return nil
	case attribute.EdgeProduct:
		m.ResetProduct()
		return nil
	case attribute.EdgeAttributeValues:
		m.ResetAttributeValues()
		return nil
	}
	return fmt.Errorf("unknown Attribute edge %s", name)
}

// AttributeGroupMutation represents an operation that mutates the AttributeGroup nodes in the graph.
type AttributeGroupMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	index            *int
	addindex         *int
	name             *model.LangJson
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	attribute        map[string]struct{}
	removedattribute map[string]struct{}
	clearedattribute bool
	product          *string
	clearedproduct   bool
	done             bool
	oldValue         func(context.Context) (*AttributeGroup, error)
	predicates       []predicate.AttributeGroup
}

var _ ent.Mutation = (*AttributeGroupMutation)(nil)

// attributegroupOption allows management of the mutation configuration using functional options.
type attributegroupOption func(*AttributeGroupMutation)

// newAttributeGroupMutation creates new mutation for the AttributeGroup entity.
func newAttributeGroupMutation(c config, op Op, opts ...attributegroupOption) *AttributeGroupMutation {
	m := &AttributeGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeAttributeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttributeGroupID sets the ID field of the mutation.
func withAttributeGroupID(id string) attributegroupOption {
	return func(m *AttributeGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *AttributeGroup
		)
		m.oldValue = func(ctx context.Context) (*AttributeGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AttributeGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttributeGroup sets the old AttributeGroup of the mutation.
func withAttributeGroup(node *AttributeGroup) attributegroupOption {
	return func(m *AttributeGroupMutation) {
		m.oldValue = func(context.Context) (*AttributeGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttributeGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttributeGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AttributeGroup entities.
func (m *AttributeGroupMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttributeGroupMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttributeGroupMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AttributeGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttributeGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttributeGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AttributeGroup entity.
// If the AttributeGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttributeGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetIndex sets the "index" field.
func (m *AttributeGroupMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *AttributeGroupMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the AttributeGroup entity.
// If the AttributeGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeGroupMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *AttributeGroupMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *AttributeGroupMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *AttributeGroupMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetName sets the "name" field.
func (m *AttributeGroupMutation) SetName(mj model.LangJson) {
	m.name = &mj
}

// Name returns the value of the "name" field in the mutation.
func (m *AttributeGroupMutation) Name() (r model.LangJson, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AttributeGroup entity.
// If the AttributeGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeGroupMutation) OldName(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AttributeGroupMutation) ResetName() {
	m.name = nil
}

// SetProductID sets the "product_id" field.
func (m *AttributeGroupMutation) SetProductID(s string) {
	m.product = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *AttributeGroupMutation) ProductID() (r string, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the AttributeGroup entity.
// If the AttributeGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeGroupMutation) OldProductID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *AttributeGroupMutation) ClearProductID() {
	m.product = nil
	m.clearedFields[attributegroup.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *AttributeGroupMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[attributegroup.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *AttributeGroupMutation) ResetProductID() {
	m.product = nil
	delete(m.clearedFields, attributegroup.FieldProductID)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttributeGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttributeGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AttributeGroup entity.
// If the AttributeGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeGroupMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AttributeGroupMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[attributegroup.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AttributeGroupMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[attributegroup.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttributeGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, attributegroup.FieldUpdatedAt)
}

// AddAttributeIDs adds the "attribute" edge to the Attribute entity by ids.
func (m *AttributeGroupMutation) AddAttributeIDs(ids ...string) {
	if m.attribute == nil {
		m.attribute = make(map[string]struct{})
	}
	for i := range ids {
		m.attribute[ids[i]] = struct{}{}
	}
}

// ClearAttribute clears the "attribute" edge to the Attribute entity.
func (m *AttributeGroupMutation) ClearAttribute() {
	m.clearedattribute = true
}

// AttributeCleared reports if the "attribute" edge to the Attribute entity was cleared.
func (m *AttributeGroupMutation) AttributeCleared() bool {
	return m.clearedattribute
}

// RemoveAttributeIDs removes the "attribute" edge to the Attribute entity by IDs.
func (m *AttributeGroupMutation) RemoveAttributeIDs(ids ...string) {
	if m.removedattribute == nil {
		m.removedattribute = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.attribute, ids[i])
		m.removedattribute[ids[i]] = struct{}{}
	}
}

// RemovedAttribute returns the removed IDs of the "attribute" edge to the Attribute entity.
func (m *AttributeGroupMutation) RemovedAttributeIDs() (ids []string) {
	for id := range m.removedattribute {
		ids = append(ids, id)
	}
	return
}

// AttributeIDs returns the "attribute" edge IDs in the mutation.
func (m *AttributeGroupMutation) AttributeIDs() (ids []string) {
	for id := range m.attribute {
		ids = append(ids, id)
	}
	return
}

// ResetAttribute resets all changes to the "attribute" edge.
func (m *AttributeGroupMutation) ResetAttribute() {
	m.attribute = nil
	m.clearedattribute = false
	m.removedattribute = nil
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *AttributeGroupMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[attributegroup.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *AttributeGroupMutation) ProductCleared() bool {
	return m.ProductIDCleared() || m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *AttributeGroupMutation) ProductIDs() (ids []string) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *AttributeGroupMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the AttributeGroupMutation builder.
func (m *AttributeGroupMutation) Where(ps ...predicate.AttributeGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttributeGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttributeGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AttributeGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttributeGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttributeGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AttributeGroup).
func (m *AttributeGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttributeGroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, attributegroup.FieldCreatedAt)
	}
	if m.index != nil {
		fields = append(fields, attributegroup.FieldIndex)
	}
	if m.name != nil {
		fields = append(fields, attributegroup.FieldName)
	}
	if m.product != nil {
		fields = append(fields, attributegroup.FieldProductID)
	}
	if m.updated_at != nil {
		fields = append(fields, attributegroup.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttributeGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attributegroup.FieldCreatedAt:
		return m.CreatedAt()
	case attributegroup.FieldIndex:
		return m.Index()
	case attributegroup.FieldName:
		return m.Name()
	case attributegroup.FieldProductID:
		return m.ProductID()
	case attributegroup.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttributeGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attributegroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attributegroup.FieldIndex:
		return m.OldIndex(ctx)
	case attributegroup.FieldName:
		return m.OldName(ctx)
	case attributegroup.FieldProductID:
		return m.OldProductID(ctx)
	case attributegroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AttributeGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attributegroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attributegroup.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case attributegroup.FieldName:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case attributegroup.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case attributegroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AttributeGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttributeGroupMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, attributegroup.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttributeGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attributegroup.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attributegroup.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AttributeGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttributeGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attributegroup.FieldProductID) {
		fields = append(fields, attributegroup.FieldProductID)
	}
	if m.FieldCleared(attributegroup.FieldUpdatedAt) {
		fields = append(fields, attributegroup.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttributeGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttributeGroupMutation) ClearField(name string) error {
	switch name {
	case attributegroup.FieldProductID:
		m.ClearProductID()
		return nil
	case attributegroup.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AttributeGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttributeGroupMutation) ResetField(name string) error {
	switch name {
	case attributegroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attributegroup.FieldIndex:
		m.ResetIndex()
		return nil
	case attributegroup.FieldName:
		m.ResetName()
		return nil
	case attributegroup.FieldProductID:
		m.ResetProductID()
		return nil
	case attributegroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AttributeGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttributeGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attribute != nil {
		edges = append(edges, attributegroup.EdgeAttribute)
	}
	if m.product != nil {
		edges = append(edges, attributegroup.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttributeGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attributegroup.EdgeAttribute:
		ids := make([]ent.Value, 0, len(m.attribute))
		for id := range m.attribute {
			ids = append(ids, id)
		}
		return ids
	case attributegroup.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttributeGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedattribute != nil {
		edges = append(edges, attributegroup.EdgeAttribute)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttributeGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case attributegroup.EdgeAttribute:
		ids := make([]ent.Value, 0, len(m.removedattribute))
		for id := range m.removedattribute {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttributeGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattribute {
		edges = append(edges, attributegroup.EdgeAttribute)
	}
	if m.clearedproduct {
		edges = append(edges, attributegroup.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttributeGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case attributegroup.EdgeAttribute:
		return m.clearedattribute
	case attributegroup.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttributeGroupMutation) ClearEdge(name string) error {
	switch name {
	case attributegroup.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown AttributeGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttributeGroupMutation) ResetEdge(name string) error {
	switch name {
	case attributegroup.EdgeAttribute:
		m.ResetAttribute()
		return nil
	case attributegroup.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown AttributeGroup edge %s", name)
}

// AttributeValueMutation represents an operation that mutates the AttributeValue nodes in the graph.
type AttributeValueMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	value_text       *model.LangJson
	value_number     *float64
	addvalue_number  *float64
	value_bool       *bool
	value_ref        *string
	variant_count    *int
	addvariant_count *int
	etag             *string
	clearedFields    map[string]struct{}
	attribute        *string
	clearedattribute bool
	variant          map[string]struct{}
	removedvariant   map[string]struct{}
	clearedvariant   bool
	done             bool
	oldValue         func(context.Context) (*AttributeValue, error)
	predicates       []predicate.AttributeValue
}

var _ ent.Mutation = (*AttributeValueMutation)(nil)

// attributevalueOption allows management of the mutation configuration using functional options.
type attributevalueOption func(*AttributeValueMutation)

// newAttributeValueMutation creates new mutation for the AttributeValue entity.
func newAttributeValueMutation(c config, op Op, opts ...attributevalueOption) *AttributeValueMutation {
	m := &AttributeValueMutation{
		config:        c,
		op:            op,
		typ:           TypeAttributeValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttributeValueID sets the ID field of the mutation.
func withAttributeValueID(id string) attributevalueOption {
	return func(m *AttributeValueMutation) {
		var (
			err   error
			once  sync.Once
			value *AttributeValue
		)
		m.oldValue = func(ctx context.Context) (*AttributeValue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AttributeValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttributeValue sets the old AttributeValue of the mutation.
func withAttributeValue(node *AttributeValue) attributevalueOption {
	return func(m *AttributeValueMutation) {
		m.oldValue = func(context.Context) (*AttributeValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttributeValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttributeValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AttributeValue entities.
func (m *AttributeValueMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttributeValueMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttributeValueMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AttributeValue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAttributeID sets the "attribute_id" field.
func (m *AttributeValueMutation) SetAttributeID(s string) {
	m.attribute = &s
}

// AttributeID returns the value of the "attribute_id" field in the mutation.
func (m *AttributeValueMutation) AttributeID() (r string, exists bool) {
	v := m.attribute
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributeID returns the old "attribute_id" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldAttributeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributeID: %w", err)
	}
	return oldValue.AttributeID, nil
}

// ResetAttributeID resets all changes to the "attribute_id" field.
func (m *AttributeValueMutation) ResetAttributeID() {
	m.attribute = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AttributeValueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttributeValueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttributeValueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttributeValueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttributeValueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AttributeValueMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[attributevalue.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AttributeValueMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[attributevalue.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttributeValueMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, attributevalue.FieldUpdatedAt)
}

// SetValueText sets the "value_text" field.
func (m *AttributeValueMutation) SetValueText(mj model.LangJson) {
	m.value_text = &mj
}

// ValueText returns the value of the "value_text" field in the mutation.
func (m *AttributeValueMutation) ValueText() (r model.LangJson, exists bool) {
	v := m.value_text
	if v == nil {
		return
	}
	return *v, true
}

// OldValueText returns the old "value_text" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldValueText(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueText: %w", err)
	}
	return oldValue.ValueText, nil
}

// ResetValueText resets all changes to the "value_text" field.
func (m *AttributeValueMutation) ResetValueText() {
	m.value_text = nil
}

// SetValueNumber sets the "value_number" field.
func (m *AttributeValueMutation) SetValueNumber(f float64) {
	m.value_number = &f
	m.addvalue_number = nil
}

// ValueNumber returns the value of the "value_number" field in the mutation.
func (m *AttributeValueMutation) ValueNumber() (r float64, exists bool) {
	v := m.value_number
	if v == nil {
		return
	}
	return *v, true
}

// OldValueNumber returns the old "value_number" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldValueNumber(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueNumber: %w", err)
	}
	return oldValue.ValueNumber, nil
}

// AddValueNumber adds f to the "value_number" field.
func (m *AttributeValueMutation) AddValueNumber(f float64) {
	if m.addvalue_number != nil {
		*m.addvalue_number += f
	} else {
		m.addvalue_number = &f
	}
}

// AddedValueNumber returns the value that was added to the "value_number" field in this mutation.
func (m *AttributeValueMutation) AddedValueNumber() (r float64, exists bool) {
	v := m.addvalue_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetValueNumber resets all changes to the "value_number" field.
func (m *AttributeValueMutation) ResetValueNumber() {
	m.value_number = nil
	m.addvalue_number = nil
}

// SetValueBool sets the "value_bool" field.
func (m *AttributeValueMutation) SetValueBool(b bool) {
	m.value_bool = &b
}

// ValueBool returns the value of the "value_bool" field in the mutation.
func (m *AttributeValueMutation) ValueBool() (r bool, exists bool) {
	v := m.value_bool
	if v == nil {
		return
	}
	return *v, true
}

// OldValueBool returns the old "value_bool" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldValueBool(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueBool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueBool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueBool: %w", err)
	}
	return oldValue.ValueBool, nil
}

// ResetValueBool resets all changes to the "value_bool" field.
func (m *AttributeValueMutation) ResetValueBool() {
	m.value_bool = nil
}

// SetValueRef sets the "value_ref" field.
func (m *AttributeValueMutation) SetValueRef(s string) {
	m.value_ref = &s
}

// ValueRef returns the value of the "value_ref" field in the mutation.
func (m *AttributeValueMutation) ValueRef() (r string, exists bool) {
	v := m.value_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldValueRef returns the old "value_ref" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldValueRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueRef: %w", err)
	}
	return oldValue.ValueRef, nil
}

// ResetValueRef resets all changes to the "value_ref" field.
func (m *AttributeValueMutation) ResetValueRef() {
	m.value_ref = nil
}

// SetVariantCount sets the "variant_count" field.
func (m *AttributeValueMutation) SetVariantCount(i int) {
	m.variant_count = &i
	m.addvariant_count = nil
}

// VariantCount returns the value of the "variant_count" field in the mutation.
func (m *AttributeValueMutation) VariantCount() (r int, exists bool) {
	v := m.variant_count
	if v == nil {
		return
	}
	return *v, true
}

// OldVariantCount returns the old "variant_count" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldVariantCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariantCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariantCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariantCount: %w", err)
	}
	return oldValue.VariantCount, nil
}

// AddVariantCount adds i to the "variant_count" field.
func (m *AttributeValueMutation) AddVariantCount(i int) {
	if m.addvariant_count != nil {
		*m.addvariant_count += i
	} else {
		m.addvariant_count = &i
	}
}

// AddedVariantCount returns the value that was added to the "variant_count" field in this mutation.
func (m *AttributeValueMutation) AddedVariantCount() (r int, exists bool) {
	v := m.addvariant_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetVariantCount resets all changes to the "variant_count" field.
func (m *AttributeValueMutation) ResetVariantCount() {
	m.variant_count = nil
	m.addvariant_count = nil
}

// SetEtag sets the "etag" field.
func (m *AttributeValueMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *AttributeValueMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *AttributeValueMutation) ResetEtag() {
	m.etag = nil
}

// ClearAttribute clears the "attribute" edge to the Attribute entity.
func (m *AttributeValueMutation) ClearAttribute() {
	m.clearedattribute = true
	m.clearedFields[attributevalue.FieldAttributeID] = struct{}{}
}

// AttributeCleared reports if the "attribute" edge to the Attribute entity was cleared.
func (m *AttributeValueMutation) AttributeCleared() bool {
	return m.clearedattribute
}

// AttributeIDs returns the "attribute" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttributeID instead. It exists only for internal usage by the builders.
func (m *AttributeValueMutation) AttributeIDs() (ids []string) {
	if id := m.attribute; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttribute resets all changes to the "attribute" edge.
func (m *AttributeValueMutation) ResetAttribute() {
	m.attribute = nil
	m.clearedattribute = false
}

// AddVariantIDs adds the "variant" edge to the Variant entity by ids.
func (m *AttributeValueMutation) AddVariantIDs(ids ...string) {
	if m.variant == nil {
		m.variant = make(map[string]struct{})
	}
	for i := range ids {
		m.variant[ids[i]] = struct{}{}
	}
}

// ClearVariant clears the "variant" edge to the Variant entity.
func (m *AttributeValueMutation) ClearVariant() {
	m.clearedvariant = true
}

// VariantCleared reports if the "variant" edge to the Variant entity was cleared.
func (m *AttributeValueMutation) VariantCleared() bool {
	return m.clearedvariant
}

// RemoveVariantIDs removes the "variant" edge to the Variant entity by IDs.
func (m *AttributeValueMutation) RemoveVariantIDs(ids ...string) {
	if m.removedvariant == nil {
		m.removedvariant = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.variant, ids[i])
		m.removedvariant[ids[i]] = struct{}{}
	}
}

// RemovedVariant returns the removed IDs of the "variant" edge to the Variant entity.
func (m *AttributeValueMutation) RemovedVariantIDs() (ids []string) {
	for id := range m.removedvariant {
		ids = append(ids, id)
	}
	return
}

// VariantIDs returns the "variant" edge IDs in the mutation.
func (m *AttributeValueMutation) VariantIDs() (ids []string) {
	for id := range m.variant {
		ids = append(ids, id)
	}
	return
}

// ResetVariant resets all changes to the "variant" edge.
func (m *AttributeValueMutation) ResetVariant() {
	m.variant = nil
	m.clearedvariant = false
	m.removedvariant = nil
}

// Where appends a list predicates to the AttributeValueMutation builder.
func (m *AttributeValueMutation) Where(ps ...predicate.AttributeValue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttributeValueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttributeValueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AttributeValue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttributeValueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttributeValueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AttributeValue).
func (m *AttributeValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttributeValueMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.attribute != nil {
		fields = append(fields, attributevalue.FieldAttributeID)
	}
	if m.created_at != nil {
		fields = append(fields, attributevalue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attributevalue.FieldUpdatedAt)
	}
	if m.value_text != nil {
		fields = append(fields, attributevalue.FieldValueText)
	}
	if m.value_number != nil {
		fields = append(fields, attributevalue.FieldValueNumber)
	}
	if m.value_bool != nil {
		fields = append(fields, attributevalue.FieldValueBool)
	}
	if m.value_ref != nil {
		fields = append(fields, attributevalue.FieldValueRef)
	}
	if m.variant_count != nil {
		fields = append(fields, attributevalue.FieldVariantCount)
	}
	if m.etag != nil {
		fields = append(fields, attributevalue.FieldEtag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttributeValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attributevalue.FieldAttributeID:
		return m.AttributeID()
	case attributevalue.FieldCreatedAt:
		return m.CreatedAt()
	case attributevalue.FieldUpdatedAt:
		return m.UpdatedAt()
	case attributevalue.FieldValueText:
		return m.ValueText()
	case attributevalue.FieldValueNumber:
		return m.ValueNumber()
	case attributevalue.FieldValueBool:
		return m.ValueBool()
	case attributevalue.FieldValueRef:
		return m.ValueRef()
	case attributevalue.FieldVariantCount:
		return m.VariantCount()
	case attributevalue.FieldEtag:
		return m.Etag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttributeValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attributevalue.FieldAttributeID:
		return m.OldAttributeID(ctx)
	case attributevalue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attributevalue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attributevalue.FieldValueText:
		return m.OldValueText(ctx)
	case attributevalue.FieldValueNumber:
		return m.OldValueNumber(ctx)
	case attributevalue.FieldValueBool:
		return m.OldValueBool(ctx)
	case attributevalue.FieldValueRef:
		return m.OldValueRef(ctx)
	case attributevalue.FieldVariantCount:
		return m.OldVariantCount(ctx)
	case attributevalue.FieldEtag:
		return m.OldEtag(ctx)
	}
	return nil, fmt.Errorf("unknown AttributeValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attributevalue.FieldAttributeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributeID(v)
		return nil
	case attributevalue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attributevalue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attributevalue.FieldValueText:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueText(v)
		return nil
	case attributevalue.FieldValueNumber:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueNumber(v)
		return nil
	case attributevalue.FieldValueBool:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueBool(v)
		return nil
	case attributevalue.FieldValueRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueRef(v)
		return nil
	case attributevalue.FieldVariantCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariantCount(v)
		return nil
	case attributevalue.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	}
	return fmt.Errorf("unknown AttributeValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttributeValueMutation) AddedFields() []string {
	var fields []string
	if m.addvalue_number != nil {
		fields = append(fields, attributevalue.FieldValueNumber)
	}
	if m.addvariant_count != nil {
		fields = append(fields, attributevalue.FieldVariantCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttributeValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attributevalue.FieldValueNumber:
		return m.AddedValueNumber()
	case attributevalue.FieldVariantCount:
		return m.AddedVariantCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attributevalue.FieldValueNumber:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValueNumber(v)
		return nil
	case attributevalue.FieldVariantCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVariantCount(v)
		return nil
	}
	return fmt.Errorf("unknown AttributeValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttributeValueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attributevalue.FieldUpdatedAt) {
		fields = append(fields, attributevalue.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttributeValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttributeValueMutation) ClearField(name string) error {
	switch name {
	case attributevalue.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AttributeValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttributeValueMutation) ResetField(name string) error {
	switch name {
	case attributevalue.FieldAttributeID:
		m.ResetAttributeID()
		return nil
	case attributevalue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attributevalue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attributevalue.FieldValueText:
		m.ResetValueText()
		return nil
	case attributevalue.FieldValueNumber:
		m.ResetValueNumber()
		return nil
	case attributevalue.FieldValueBool:
		m.ResetValueBool()
		return nil
	case attributevalue.FieldValueRef:
		m.ResetValueRef()
		return nil
	case attributevalue.FieldVariantCount:
		m.ResetVariantCount()
		return nil
	case attributevalue.FieldEtag:
		m.ResetEtag()
		return nil
	}
	return fmt.Errorf("unknown AttributeValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttributeValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attribute != nil {
		edges = append(edges, attributevalue.EdgeAttribute)
	}
	if m.variant != nil {
		edges = append(edges, attributevalue.EdgeVariant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttributeValueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attributevalue.EdgeAttribute:
		if id := m.attribute; id != nil {
			return []ent.Value{*id}
		}
	case attributevalue.EdgeVariant:
		ids := make([]ent.Value, 0, len(m.variant))
		for id := range m.variant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttributeValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvariant != nil {
		edges = append(edges, attributevalue.EdgeVariant)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttributeValueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case attributevalue.EdgeVariant:
		ids := make([]ent.Value, 0, len(m.removedvariant))
		for id := range m.removedvariant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttributeValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattribute {
		edges = append(edges, attributevalue.EdgeAttribute)
	}
	if m.clearedvariant {
		edges = append(edges, attributevalue.EdgeVariant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttributeValueMutation) EdgeCleared(name string) bool {
	switch name {
	case attributevalue.EdgeAttribute:
		return m.clearedattribute
	case attributevalue.EdgeVariant:
		return m.clearedvariant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttributeValueMutation) ClearEdge(name string) error {
	switch name {
	case attributevalue.EdgeAttribute:
		m.ClearAttribute()
		return nil
	}
	return fmt.Errorf("unknown AttributeValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttributeValueMutation) ResetEdge(name string) error {
	switch name {
	case attributevalue.EdgeAttribute:
		m.ResetAttribute()
		return nil
	case attributevalue.EdgeVariant:
		m.ResetVariant()
		return nil
	}
	return fmt.Errorf("unknown AttributeValue edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	default_variant_id     *string
	description            *model.LangJson
	etag                   *string
	name                   *model.LangJson
	org_id                 *string
	status                 *string
	tag_ids                *string
	thumbnail_url          *string
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	variant                map[string]struct{}
	removedvariant         map[string]struct{}
	clearedvariant         bool
	attribute              map[string]struct{}
	removedattribute       map[string]struct{}
	clearedattribute       bool
	attribute_group        map[string]struct{}
	removedattribute_group map[string]struct{}
	clearedattribute_group bool
	unit                   *string
	clearedunit            bool
	done                   bool
	oldValue               func(context.Context) (*Product, error)
	predicates             []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id string) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDefaultVariantID sets the "default_variant_id" field.
func (m *ProductMutation) SetDefaultVariantID(s string) {
	m.default_variant_id = &s
}

// DefaultVariantID returns the value of the "default_variant_id" field in the mutation.
func (m *ProductMutation) DefaultVariantID() (r string, exists bool) {
	v := m.default_variant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultVariantID returns the old "default_variant_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDefaultVariantID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultVariantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultVariantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultVariantID: %w", err)
	}
	return oldValue.DefaultVariantID, nil
}

// ClearDefaultVariantID clears the value of the "default_variant_id" field.
func (m *ProductMutation) ClearDefaultVariantID() {
	m.default_variant_id = nil
	m.clearedFields[product.FieldDefaultVariantID] = struct{}{}
}

// DefaultVariantIDCleared returns if the "default_variant_id" field was cleared in this mutation.
func (m *ProductMutation) DefaultVariantIDCleared() bool {
	_, ok := m.clearedFields[product.FieldDefaultVariantID]
	return ok
}

// ResetDefaultVariantID resets all changes to the "default_variant_id" field.
func (m *ProductMutation) ResetDefaultVariantID() {
	m.default_variant_id = nil
	delete(m.clearedFields, product.FieldDefaultVariantID)
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(mj model.LangJson) {
	m.description = &mj
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r model.LangJson, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// SetEtag sets the "etag" field.
func (m *ProductMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *ProductMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *ProductMutation) ResetEtag() {
	m.etag = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(mj model.LangJson) {
	m.name = &mj
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r model.LangJson, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetOrgID sets the "org_id" field.
func (m *ProductMutation) SetOrgID(s string) {
	m.org_id = &s
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *ProductMutation) OrgID() (r string, exists bool) {
	v := m.org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldOrgID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *ProductMutation) ResetOrgID() {
	m.org_id = nil
}

// SetStatus sets the "status" field.
func (m *ProductMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductMutation) ResetStatus() {
	m.status = nil
}

// SetTagIds sets the "tag_ids" field.
func (m *ProductMutation) SetTagIds(s string) {
	m.tag_ids = &s
}

// TagIds returns the value of the "tag_ids" field in the mutation.
func (m *ProductMutation) TagIds() (r string, exists bool) {
	v := m.tag_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldTagIds returns the old "tag_ids" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldTagIds(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagIds: %w", err)
	}
	return oldValue.TagIds, nil
}

// ClearTagIds clears the value of the "tag_ids" field.
func (m *ProductMutation) ClearTagIds() {
	m.tag_ids = nil
	m.clearedFields[product.FieldTagIds] = struct{}{}
}

// TagIdsCleared returns if the "tag_ids" field was cleared in this mutation.
func (m *ProductMutation) TagIdsCleared() bool {
	_, ok := m.clearedFields[product.FieldTagIds]
	return ok
}

// ResetTagIds resets all changes to the "tag_ids" field.
func (m *ProductMutation) ResetTagIds() {
	m.tag_ids = nil
	delete(m.clearedFields, product.FieldTagIds)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *ProductMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *ProductMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldThumbnailURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *ProductMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[product.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *ProductMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[product.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *ProductMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, product.FieldThumbnailURL)
}

// SetUnitID sets the "unit_id" field.
func (m *ProductMutation) SetUnitID(s string) {
	m.unit = &s
}

// UnitID returns the value of the "unit_id" field in the mutation.
func (m *ProductMutation) UnitID() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitID returns the old "unit_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitID: %w", err)
	}
	return oldValue.UnitID, nil
}

// ResetUnitID resets all changes to the "unit_id" field.
func (m *ProductMutation) ResetUnitID() {
	m.unit = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[product.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, product.FieldUpdatedAt)
}

// AddVariantIDs adds the "variant" edge to the Variant entity by ids.
func (m *ProductMutation) AddVariantIDs(ids ...string) {
	if m.variant == nil {
		m.variant = make(map[string]struct{})
	}
	for i := range ids {
		m.variant[ids[i]] = struct{}{}
	}
}

// ClearVariant clears the "variant" edge to the Variant entity.
func (m *ProductMutation) ClearVariant() {
	m.clearedvariant = true
}

// VariantCleared reports if the "variant" edge to the Variant entity was cleared.
func (m *ProductMutation) VariantCleared() bool {
	return m.clearedvariant
}

// RemoveVariantIDs removes the "variant" edge to the Variant entity by IDs.
func (m *ProductMutation) RemoveVariantIDs(ids ...string) {
	if m.removedvariant == nil {
		m.removedvariant = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.variant, ids[i])
		m.removedvariant[ids[i]] = struct{}{}
	}
}

// RemovedVariant returns the removed IDs of the "variant" edge to the Variant entity.
func (m *ProductMutation) RemovedVariantIDs() (ids []string) {
	for id := range m.removedvariant {
		ids = append(ids, id)
	}
	return
}

// VariantIDs returns the "variant" edge IDs in the mutation.
func (m *ProductMutation) VariantIDs() (ids []string) {
	for id := range m.variant {
		ids = append(ids, id)
	}
	return
}

// ResetVariant resets all changes to the "variant" edge.
func (m *ProductMutation) ResetVariant() {
	m.variant = nil
	m.clearedvariant = false
	m.removedvariant = nil
}

// AddAttributeIDs adds the "attribute" edge to the Attribute entity by ids.
func (m *ProductMutation) AddAttributeIDs(ids ...string) {
	if m.attribute == nil {
		m.attribute = make(map[string]struct{})
	}
	for i := range ids {
		m.attribute[ids[i]] = struct{}{}
	}
}

// ClearAttribute clears the "attribute" edge to the Attribute entity.
func (m *ProductMutation) ClearAttribute() {
	m.clearedattribute = true
}

// AttributeCleared reports if the "attribute" edge to the Attribute entity was cleared.
func (m *ProductMutation) AttributeCleared() bool {
	return m.clearedattribute
}

// RemoveAttributeIDs removes the "attribute" edge to the Attribute entity by IDs.
func (m *ProductMutation) RemoveAttributeIDs(ids ...string) {
	if m.removedattribute == nil {
		m.removedattribute = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.attribute, ids[i])
		m.removedattribute[ids[i]] = struct{}{}
	}
}

// RemovedAttribute returns the removed IDs of the "attribute" edge to the Attribute entity.
func (m *ProductMutation) RemovedAttributeIDs() (ids []string) {
	for id := range m.removedattribute {
		ids = append(ids, id)
	}
	return
}

// AttributeIDs returns the "attribute" edge IDs in the mutation.
func (m *ProductMutation) AttributeIDs() (ids []string) {
	for id := range m.attribute {
		ids = append(ids, id)
	}
	return
}

// ResetAttribute resets all changes to the "attribute" edge.
func (m *ProductMutation) ResetAttribute() {
	m.attribute = nil
	m.clearedattribute = false
	m.removedattribute = nil
}

// AddAttributeGroupIDs adds the "attribute_group" edge to the AttributeGroup entity by ids.
func (m *ProductMutation) AddAttributeGroupIDs(ids ...string) {
	if m.attribute_group == nil {
		m.attribute_group = make(map[string]struct{})
	}
	for i := range ids {
		m.attribute_group[ids[i]] = struct{}{}
	}
}

// ClearAttributeGroup clears the "attribute_group" edge to the AttributeGroup entity.
func (m *ProductMutation) ClearAttributeGroup() {
	m.clearedattribute_group = true
}

// AttributeGroupCleared reports if the "attribute_group" edge to the AttributeGroup entity was cleared.
func (m *ProductMutation) AttributeGroupCleared() bool {
	return m.clearedattribute_group
}

// RemoveAttributeGroupIDs removes the "attribute_group" edge to the AttributeGroup entity by IDs.
func (m *ProductMutation) RemoveAttributeGroupIDs(ids ...string) {
	if m.removedattribute_group == nil {
		m.removedattribute_group = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.attribute_group, ids[i])
		m.removedattribute_group[ids[i]] = struct{}{}
	}
}

// RemovedAttributeGroup returns the removed IDs of the "attribute_group" edge to the AttributeGroup entity.
func (m *ProductMutation) RemovedAttributeGroupIDs() (ids []string) {
	for id := range m.removedattribute_group {
		ids = append(ids, id)
	}
	return
}

// AttributeGroupIDs returns the "attribute_group" edge IDs in the mutation.
func (m *ProductMutation) AttributeGroupIDs() (ids []string) {
	for id := range m.attribute_group {
		ids = append(ids, id)
	}
	return
}

// ResetAttributeGroup resets all changes to the "attribute_group" edge.
func (m *ProductMutation) ResetAttributeGroup() {
	m.attribute_group = nil
	m.clearedattribute_group = false
	m.removedattribute_group = nil
}

// ClearUnit clears the "unit" edge to the Unit entity.
func (m *ProductMutation) ClearUnit() {
	m.clearedunit = true
	m.clearedFields[product.FieldUnitID] = struct{}{}
}

// UnitCleared reports if the "unit" edge to the Unit entity was cleared.
func (m *ProductMutation) UnitCleared() bool {
	return m.clearedunit
}

// UnitIDs returns the "unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UnitID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) UnitIDs() (ids []string) {
	if id := m.unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnit resets all changes to the "unit" edge.
func (m *ProductMutation) ResetUnit() {
	m.unit = nil
	m.clearedunit = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.default_variant_id != nil {
		fields = append(fields, product.FieldDefaultVariantID)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.etag != nil {
		fields = append(fields, product.FieldEtag)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.org_id != nil {
		fields = append(fields, product.FieldOrgID)
	}
	if m.status != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.tag_ids != nil {
		fields = append(fields, product.FieldTagIds)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, product.FieldThumbnailURL)
	}
	if m.unit != nil {
		fields = append(fields, product.FieldUnitID)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldDefaultVariantID:
		return m.DefaultVariantID()
	case product.FieldDescription:
		return m.Description()
	case product.FieldEtag:
		return m.Etag()
	case product.FieldName:
		return m.Name()
	case product.FieldOrgID:
		return m.OrgID()
	case product.FieldStatus:
		return m.Status()
	case product.FieldTagIds:
		return m.TagIds()
	case product.FieldThumbnailURL:
		return m.ThumbnailURL()
	case product.FieldUnitID:
		return m.UnitID()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldDefaultVariantID:
		return m.OldDefaultVariantID(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldEtag:
		return m.OldEtag(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldOrgID:
		return m.OldOrgID(ctx)
	case product.FieldStatus:
		return m.OldStatus(ctx)
	case product.FieldTagIds:
		return m.OldTagIds(ctx)
	case product.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case product.FieldUnitID:
		return m.OldUnitID(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldDefaultVariantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultVariantID(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case product.FieldName:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldOrgID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case product.FieldTagIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagIds(v)
		return nil
	case product.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case product.FieldUnitID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitID(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDefaultVariantID) {
		fields = append(fields, product.FieldDefaultVariantID)
	}
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	if m.FieldCleared(product.FieldTagIds) {
		fields = append(fields, product.FieldTagIds)
	}
	if m.FieldCleared(product.FieldThumbnailURL) {
		fields = append(fields, product.FieldThumbnailURL)
	}
	if m.FieldCleared(product.FieldUpdatedAt) {
		fields = append(fields, product.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDefaultVariantID:
		m.ClearDefaultVariantID()
		return nil
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	case product.FieldTagIds:
		m.ClearTagIds()
		return nil
	case product.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case product.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldDefaultVariantID:
		m.ResetDefaultVariantID()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldEtag:
		m.ResetEtag()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldOrgID:
		m.ResetOrgID()
		return nil
	case product.FieldStatus:
		m.ResetStatus()
		return nil
	case product.FieldTagIds:
		m.ResetTagIds()
		return nil
	case product.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case product.FieldUnitID:
		m.ResetUnitID()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.variant != nil {
		edges = append(edges, product.EdgeVariant)
	}
	if m.attribute != nil {
		edges = append(edges, product.EdgeAttribute)
	}
	if m.attribute_group != nil {
		edges = append(edges, product.EdgeAttributeGroup)
	}
	if m.unit != nil {
		edges = append(edges, product.EdgeUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeVariant:
		ids := make([]ent.Value, 0, len(m.variant))
		for id := range m.variant {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeAttribute:
		ids := make([]ent.Value, 0, len(m.attribute))
		for id := range m.attribute {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeAttributeGroup:
		ids := make([]ent.Value, 0, len(m.attribute_group))
		for id := range m.attribute_group {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeUnit:
		if id := m.unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedvariant != nil {
		edges = append(edges, product.EdgeVariant)
	}
	if m.removedattribute != nil {
		edges = append(edges, product.EdgeAttribute)
	}
	if m.removedattribute_group != nil {
		edges = append(edges, product.EdgeAttributeGroup)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeVariant:
		ids := make([]ent.Value, 0, len(m.removedvariant))
		for id := range m.removedvariant {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeAttribute:
		ids := make([]ent.Value, 0, len(m.removedattribute))
		for id := range m.removedattribute {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeAttributeGroup:
		ids := make([]ent.Value, 0, len(m.removedattribute_group))
		for id := range m.removedattribute_group {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedvariant {
		edges = append(edges, product.EdgeVariant)
	}
	if m.clearedattribute {
		edges = append(edges, product.EdgeAttribute)
	}
	if m.clearedattribute_group {
		edges = append(edges, product.EdgeAttributeGroup)
	}
	if m.clearedunit {
		edges = append(edges, product.EdgeUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeVariant:
		return m.clearedvariant
	case product.EdgeAttribute:
		return m.clearedattribute
	case product.EdgeAttributeGroup:
		return m.clearedattribute_group
	case product.EdgeUnit:
		return m.clearedunit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeUnit:
		m.ClearUnit()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeVariant:
		m.ResetVariant()
		return nil
	case product.EdgeAttribute:
		m.ResetAttribute()
		return nil
	case product.EdgeAttributeGroup:
		m.ResetAttributeGroup()
		return nil
	case product.EdgeUnit:
		m.ResetUnit()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductCategoryMutation represents an operation that mutates the ProductCategory nodes in the graph.
type ProductCategoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	code_name       *string
	created_at      *time.Time
	data_type       *string
	display_name    *model.LangJson
	enum_value_sort *bool
	enum_value      *model.LangJson
	etag            *string
	group_id        *string
	is_enum         *bool
	is_required     *bool
	product_id      *string
	sort_index      *int
	addsort_index   *int
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ProductCategory, error)
	predicates      []predicate.ProductCategory
}

var _ ent.Mutation = (*ProductCategoryMutation)(nil)

// productcategoryOption allows management of the mutation configuration using functional options.
type productcategoryOption func(*ProductCategoryMutation)

// newProductCategoryMutation creates new mutation for the ProductCategory entity.
func newProductCategoryMutation(c config, op Op, opts ...productcategoryOption) *ProductCategoryMutation {
	m := &ProductCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryID sets the ID field of the mutation.
func withProductCategoryID(id string) productcategoryOption {
	return func(m *ProductCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategory
		)
		m.oldValue = func(ctx context.Context) (*ProductCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategory sets the old ProductCategory of the mutation.
func withProductCategory(node *ProductCategory) productcategoryOption {
	return func(m *ProductCategoryMutation) {
		m.oldValue = func(context.Context) (*ProductCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductCategory entities.
func (m *ProductCategoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCategoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductCategoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCodeName sets the "code_name" field.
func (m *ProductCategoryMutation) SetCodeName(s string) {
	m.code_name = &s
}

// CodeName returns the value of the "code_name" field in the mutation.
func (m *ProductCategoryMutation) CodeName() (r string, exists bool) {
	v := m.code_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeName returns the old "code_name" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldCodeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeName: %w", err)
	}
	return oldValue.CodeName, nil
}

// ResetCodeName resets all changes to the "code_name" field.
func (m *ProductCategoryMutation) ResetCodeName() {
	m.code_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDataType sets the "data_type" field.
func (m *ProductCategoryMutation) SetDataType(s string) {
	m.data_type = &s
}

// DataType returns the value of the "data_type" field in the mutation.
func (m *ProductCategoryMutation) DataType() (r string, exists bool) {
	v := m.data_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDataType returns the old "data_type" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldDataType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataType: %w", err)
	}
	return oldValue.DataType, nil
}

// ResetDataType resets all changes to the "data_type" field.
func (m *ProductCategoryMutation) ResetDataType() {
	m.data_type = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ProductCategoryMutation) SetDisplayName(mj model.LangJson) {
	m.display_name = &mj
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProductCategoryMutation) DisplayName() (r model.LangJson, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldDisplayName(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ProductCategoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[productcategory.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ProductCategoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProductCategoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, productcategory.FieldDisplayName)
}

// SetEnumValueSort sets the "enum_value_sort" field.
func (m *ProductCategoryMutation) SetEnumValueSort(b bool) {
	m.enum_value_sort = &b
}

// EnumValueSort returns the value of the "enum_value_sort" field in the mutation.
func (m *ProductCategoryMutation) EnumValueSort() (r bool, exists bool) {
	v := m.enum_value_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumValueSort returns the old "enum_value_sort" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldEnumValueSort(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnumValueSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnumValueSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumValueSort: %w", err)
	}
	return oldValue.EnumValueSort, nil
}

// ResetEnumValueSort resets all changes to the "enum_value_sort" field.
func (m *ProductCategoryMutation) ResetEnumValueSort() {
	m.enum_value_sort = nil
}

// SetEnumValue sets the "enum_value" field.
func (m *ProductCategoryMutation) SetEnumValue(mj model.LangJson) {
	m.enum_value = &mj
}

// EnumValue returns the value of the "enum_value" field in the mutation.
func (m *ProductCategoryMutation) EnumValue() (r model.LangJson, exists bool) {
	v := m.enum_value
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumValue returns the old "enum_value" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldEnumValue(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnumValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnumValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumValue: %w", err)
	}
	return oldValue.EnumValue, nil
}

// ClearEnumValue clears the value of the "enum_value" field.
func (m *ProductCategoryMutation) ClearEnumValue() {
	m.enum_value = nil
	m.clearedFields[productcategory.FieldEnumValue] = struct{}{}
}

// EnumValueCleared returns if the "enum_value" field was cleared in this mutation.
func (m *ProductCategoryMutation) EnumValueCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldEnumValue]
	return ok
}

// ResetEnumValue resets all changes to the "enum_value" field.
func (m *ProductCategoryMutation) ResetEnumValue() {
	m.enum_value = nil
	delete(m.clearedFields, productcategory.FieldEnumValue)
}

// SetEtag sets the "etag" field.
func (m *ProductCategoryMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *ProductCategoryMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *ProductCategoryMutation) ResetEtag() {
	m.etag = nil
}

// SetGroupID sets the "group_id" field.
func (m *ProductCategoryMutation) SetGroupID(s string) {
	m.group_id = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *ProductCategoryMutation) GroupID() (r string, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldGroupID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *ProductCategoryMutation) ClearGroupID() {
	m.group_id = nil
	m.clearedFields[productcategory.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *ProductCategoryMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *ProductCategoryMutation) ResetGroupID() {
	m.group_id = nil
	delete(m.clearedFields, productcategory.FieldGroupID)
}

// SetIsEnum sets the "is_enum" field.
func (m *ProductCategoryMutation) SetIsEnum(b bool) {
	m.is_enum = &b
}

// IsEnum returns the value of the "is_enum" field in the mutation.
func (m *ProductCategoryMutation) IsEnum() (r bool, exists bool) {
	v := m.is_enum
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnum returns the old "is_enum" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldIsEnum(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnum: %w", err)
	}
	return oldValue.IsEnum, nil
}

// ResetIsEnum resets all changes to the "is_enum" field.
func (m *ProductCategoryMutation) ResetIsEnum() {
	m.is_enum = nil
}

// SetIsRequired sets the "is_required" field.
func (m *ProductCategoryMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *ProductCategoryMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *ProductCategoryMutation) ResetIsRequired() {
	m.is_required = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductCategoryMutation) SetProductID(s string) {
	m.product_id = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductCategoryMutation) ProductID() (r string, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductCategoryMutation) ResetProductID() {
	m.product_id = nil
}

// SetSortIndex sets the "sort_index" field.
func (m *ProductCategoryMutation) SetSortIndex(i int) {
	m.sort_index = &i
	m.addsort_index = nil
}

// SortIndex returns the value of the "sort_index" field in the mutation.
func (m *ProductCategoryMutation) SortIndex() (r int, exists bool) {
	v := m.sort_index
	if v == nil {
		return
	}
	return *v, true
}

// OldSortIndex returns the old "sort_index" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldSortIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortIndex: %w", err)
	}
	return oldValue.SortIndex, nil
}

// AddSortIndex adds i to the "sort_index" field.
func (m *ProductCategoryMutation) AddSortIndex(i int) {
	if m.addsort_index != nil {
		*m.addsort_index += i
	} else {
		m.addsort_index = &i
	}
}

// AddedSortIndex returns the value that was added to the "sort_index" field in this mutation.
func (m *ProductCategoryMutation) AddedSortIndex() (r int, exists bool) {
	v := m.addsort_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortIndex resets all changes to the "sort_index" field.
func (m *ProductCategoryMutation) ResetSortIndex() {
	m.sort_index = nil
	m.addsort_index = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductCategoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[productcategory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductCategoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, productcategory.FieldUpdatedAt)
}

// Where appends a list predicates to the ProductCategoryMutation builder.
func (m *ProductCategoryMutation) Where(ps ...predicate.ProductCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductCategory).
func (m *ProductCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.code_name != nil {
		fields = append(fields, productcategory.FieldCodeName)
	}
	if m.created_at != nil {
		fields = append(fields, productcategory.FieldCreatedAt)
	}
	if m.data_type != nil {
		fields = append(fields, productcategory.FieldDataType)
	}
	if m.display_name != nil {
		fields = append(fields, productcategory.FieldDisplayName)
	}
	if m.enum_value_sort != nil {
		fields = append(fields, productcategory.FieldEnumValueSort)
	}
	if m.enum_value != nil {
		fields = append(fields, productcategory.FieldEnumValue)
	}
	if m.etag != nil {
		fields = append(fields, productcategory.FieldEtag)
	}
	if m.group_id != nil {
		fields = append(fields, productcategory.FieldGroupID)
	}
	if m.is_enum != nil {
		fields = append(fields, productcategory.FieldIsEnum)
	}
	if m.is_required != nil {
		fields = append(fields, productcategory.FieldIsRequired)
	}
	if m.product_id != nil {
		fields = append(fields, productcategory.FieldProductID)
	}
	if m.sort_index != nil {
		fields = append(fields, productcategory.FieldSortIndex)
	}
	if m.updated_at != nil {
		fields = append(fields, productcategory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategory.FieldCodeName:
		return m.CodeName()
	case productcategory.FieldCreatedAt:
		return m.CreatedAt()
	case productcategory.FieldDataType:
		return m.DataType()
	case productcategory.FieldDisplayName:
		return m.DisplayName()
	case productcategory.FieldEnumValueSort:
		return m.EnumValueSort()
	case productcategory.FieldEnumValue:
		return m.EnumValue()
	case productcategory.FieldEtag:
		return m.Etag()
	case productcategory.FieldGroupID:
		return m.GroupID()
	case productcategory.FieldIsEnum:
		return m.IsEnum()
	case productcategory.FieldIsRequired:
		return m.IsRequired()
	case productcategory.FieldProductID:
		return m.ProductID()
	case productcategory.FieldSortIndex:
		return m.SortIndex()
	case productcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategory.FieldCodeName:
		return m.OldCodeName(ctx)
	case productcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productcategory.FieldDataType:
		return m.OldDataType(ctx)
	case productcategory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case productcategory.FieldEnumValueSort:
		return m.OldEnumValueSort(ctx)
	case productcategory.FieldEnumValue:
		return m.OldEnumValue(ctx)
	case productcategory.FieldEtag:
		return m.OldEtag(ctx)
	case productcategory.FieldGroupID:
		return m.OldGroupID(ctx)
	case productcategory.FieldIsEnum:
		return m.OldIsEnum(ctx)
	case productcategory.FieldIsRequired:
		return m.OldIsRequired(ctx)
	case productcategory.FieldProductID:
		return m.OldProductID(ctx)
	case productcategory.FieldSortIndex:
		return m.OldSortIndex(ctx)
	case productcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategory.FieldCodeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeName(v)
		return nil
	case productcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productcategory.FieldDataType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataType(v)
		return nil
	case productcategory.FieldDisplayName:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case productcategory.FieldEnumValueSort:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumValueSort(v)
		return nil
	case productcategory.FieldEnumValue:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumValue(v)
		return nil
	case productcategory.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case productcategory.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case productcategory.FieldIsEnum:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnum(v)
		return nil
	case productcategory.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	case productcategory.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productcategory.FieldSortIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortIndex(v)
		return nil
	case productcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addsort_index != nil {
		fields = append(fields, productcategory.FieldSortIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productcategory.FieldSortIndex:
		return m.AddedSortIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productcategory.FieldSortIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortIndex(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productcategory.FieldDisplayName) {
		fields = append(fields, productcategory.FieldDisplayName)
	}
	if m.FieldCleared(productcategory.FieldEnumValue) {
		fields = append(fields, productcategory.FieldEnumValue)
	}
	if m.FieldCleared(productcategory.FieldGroupID) {
		fields = append(fields, productcategory.FieldGroupID)
	}
	if m.FieldCleared(productcategory.FieldUpdatedAt) {
		fields = append(fields, productcategory.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryMutation) ClearField(name string) error {
	switch name {
	case productcategory.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case productcategory.FieldEnumValue:
		m.ClearEnumValue()
		return nil
	case productcategory.FieldGroupID:
		m.ClearGroupID()
		return nil
	case productcategory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryMutation) ResetField(name string) error {
	switch name {
	case productcategory.FieldCodeName:
		m.ResetCodeName()
		return nil
	case productcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productcategory.FieldDataType:
		m.ResetDataType()
		return nil
	case productcategory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case productcategory.FieldEnumValueSort:
		m.ResetEnumValueSort()
		return nil
	case productcategory.FieldEnumValue:
		m.ResetEnumValue()
		return nil
	case productcategory.FieldEtag:
		m.ResetEtag()
		return nil
	case productcategory.FieldGroupID:
		m.ResetGroupID()
		return nil
	case productcategory.FieldIsEnum:
		m.ResetIsEnum()
		return nil
	case productcategory.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	case productcategory.FieldProductID:
		m.ResetProductID()
		return nil
	case productcategory.FieldSortIndex:
		m.ResetSortIndex()
		return nil
	case productcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductCategory edge %s", name)
}

// UnitMutation represents an operation that mutates the Unit nodes in the graph.
type UnitMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	base_unit            *string
	created_at           *time.Time
	etag                 *string
	multiplier           *int
	addmultiplier        *int
	org_id               *string
	name                 *model.LangJson
	status               *string
	symbol               *string
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	product              map[string]struct{}
	removedproduct       map[string]struct{}
	clearedproduct       bool
	unit_category        *string
	clearedunit_category bool
	done                 bool
	oldValue             func(context.Context) (*Unit, error)
	predicates           []predicate.Unit
}

var _ ent.Mutation = (*UnitMutation)(nil)

// unitOption allows management of the mutation configuration using functional options.
type unitOption func(*UnitMutation)

// newUnitMutation creates new mutation for the Unit entity.
func newUnitMutation(c config, op Op, opts ...unitOption) *UnitMutation {
	m := &UnitMutation{
		config:        c,
		op:            op,
		typ:           TypeUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUnitID sets the ID field of the mutation.
func withUnitID(id string) unitOption {
	return func(m *UnitMutation) {
		var (
			err   error
			once  sync.Once
			value *Unit
		)
		m.oldValue = func(ctx context.Context) (*Unit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Unit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUnit sets the old Unit of the mutation.
func withUnit(node *Unit) unitOption {
	return func(m *UnitMutation) {
		m.oldValue = func(context.Context) (*Unit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Unit entities.
func (m *UnitMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UnitMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UnitMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Unit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaseUnit sets the "base_unit" field.
func (m *UnitMutation) SetBaseUnit(s string) {
	m.base_unit = &s
}

// BaseUnit returns the value of the "base_unit" field in the mutation.
func (m *UnitMutation) BaseUnit() (r string, exists bool) {
	v := m.base_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseUnit returns the old "base_unit" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldBaseUnit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseUnit: %w", err)
	}
	return oldValue.BaseUnit, nil
}

// ClearBaseUnit clears the value of the "base_unit" field.
func (m *UnitMutation) ClearBaseUnit() {
	m.base_unit = nil
	m.clearedFields[unit.FieldBaseUnit] = struct{}{}
}

// BaseUnitCleared returns if the "base_unit" field was cleared in this mutation.
func (m *UnitMutation) BaseUnitCleared() bool {
	_, ok := m.clearedFields[unit.FieldBaseUnit]
	return ok
}

// ResetBaseUnit resets all changes to the "base_unit" field.
func (m *UnitMutation) ResetBaseUnit() {
	m.base_unit = nil
	delete(m.clearedFields, unit.FieldBaseUnit)
}

// SetCategoryID sets the "category_id" field.
func (m *UnitMutation) SetCategoryID(s string) {
	m.unit_category = &s
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *UnitMutation) CategoryID() (r string, exists bool) {
	v := m.unit_category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldCategoryID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *UnitMutation) ClearCategoryID() {
	m.unit_category = nil
	m.clearedFields[unit.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *UnitMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[unit.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *UnitMutation) ResetCategoryID() {
	m.unit_category = nil
	delete(m.clearedFields, unit.FieldCategoryID)
}

// SetCreatedAt sets the "created_at" field.
func (m *UnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UnitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEtag sets the "etag" field.
func (m *UnitMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *UnitMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *UnitMutation) ResetEtag() {
	m.etag = nil
}

// SetMultiplier sets the "multiplier" field.
func (m *UnitMutation) SetMultiplier(i int) {
	m.multiplier = &i
	m.addmultiplier = nil
}

// Multiplier returns the value of the "multiplier" field in the mutation.
func (m *UnitMutation) Multiplier() (r int, exists bool) {
	v := m.multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiplier returns the old "multiplier" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldMultiplier(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiplier: %w", err)
	}
	return oldValue.Multiplier, nil
}

// AddMultiplier adds i to the "multiplier" field.
func (m *UnitMutation) AddMultiplier(i int) {
	if m.addmultiplier != nil {
		*m.addmultiplier += i
	} else {
		m.addmultiplier = &i
	}
}

// AddedMultiplier returns the value that was added to the "multiplier" field in this mutation.
func (m *UnitMutation) AddedMultiplier() (r int, exists bool) {
	v := m.addmultiplier
	if v == nil {
		return
	}
	return *v, true
}

// ClearMultiplier clears the value of the "multiplier" field.
func (m *UnitMutation) ClearMultiplier() {
	m.multiplier = nil
	m.addmultiplier = nil
	m.clearedFields[unit.FieldMultiplier] = struct{}{}
}

// MultiplierCleared returns if the "multiplier" field was cleared in this mutation.
func (m *UnitMutation) MultiplierCleared() bool {
	_, ok := m.clearedFields[unit.FieldMultiplier]
	return ok
}

// ResetMultiplier resets all changes to the "multiplier" field.
func (m *UnitMutation) ResetMultiplier() {
	m.multiplier = nil
	m.addmultiplier = nil
	delete(m.clearedFields, unit.FieldMultiplier)
}

// SetOrgID sets the "org_id" field.
func (m *UnitMutation) SetOrgID(s string) {
	m.org_id = &s
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *UnitMutation) OrgID() (r string, exists bool) {
	v := m.org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldOrgID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ClearOrgID clears the value of the "org_id" field.
func (m *UnitMutation) ClearOrgID() {
	m.org_id = nil
	m.clearedFields[unit.FieldOrgID] = struct{}{}
}

// OrgIDCleared returns if the "org_id" field was cleared in this mutation.
func (m *UnitMutation) OrgIDCleared() bool {
	_, ok := m.clearedFields[unit.FieldOrgID]
	return ok
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *UnitMutation) ResetOrgID() {
	m.org_id = nil
	delete(m.clearedFields, unit.FieldOrgID)
}

// SetName sets the "name" field.
func (m *UnitMutation) SetName(mj model.LangJson) {
	m.name = &mj
}

// Name returns the value of the "name" field in the mutation.
func (m *UnitMutation) Name() (r model.LangJson, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldName(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UnitMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *UnitMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UnitMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UnitMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[unit.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UnitMutation) StatusCleared() bool {
	_, ok := m.clearedFields[unit.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UnitMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, unit.FieldStatus)
}

// SetSymbol sets the "symbol" field.
func (m *UnitMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *UnitMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *UnitMutation) ResetSymbol() {
	m.symbol = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UnitMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[unit.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UnitMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[unit.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, unit.FieldUpdatedAt)
}

// AddProductIDs adds the "product" edge to the Product entity by ids.
func (m *UnitMutation) AddProductIDs(ids ...string) {
	if m.product == nil {
		m.product = make(map[string]struct{})
	}
	for i := range ids {
		m.product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *UnitMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *UnitMutation) ProductCleared() bool {
	return m.clearedproduct
}

// RemoveProductIDs removes the "product" edge to the Product entity by IDs.
func (m *UnitMutation) RemoveProductIDs(ids ...string) {
	if m.removedproduct == nil {
		m.removedproduct = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.product, ids[i])
		m.removedproduct[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "product" edge to the Product entity.
func (m *UnitMutation) RemovedProductIDs() (ids []string) {
	for id := range m.removedproduct {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
func (m *UnitMutation) ProductIDs() (ids []string) {
	for id := range m.product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *UnitMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
	m.removedproduct = nil
}

// SetUnitCategoryID sets the "unit_category" edge to the UnitCategory entity by id.
func (m *UnitMutation) SetUnitCategoryID(id string) {
	m.unit_category = &id
}

// ClearUnitCategory clears the "unit_category" edge to the UnitCategory entity.
func (m *UnitMutation) ClearUnitCategory() {
	m.clearedunit_category = true
	m.clearedFields[unit.FieldCategoryID] = struct{}{}
}

// UnitCategoryCleared reports if the "unit_category" edge to the UnitCategory entity was cleared.
func (m *UnitMutation) UnitCategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedunit_category
}

// UnitCategoryID returns the "unit_category" edge ID in the mutation.
func (m *UnitMutation) UnitCategoryID() (id string, exists bool) {
	if m.unit_category != nil {
		return *m.unit_category, true
	}
	return
}

// UnitCategoryIDs returns the "unit_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UnitCategoryID instead. It exists only for internal usage by the builders.
func (m *UnitMutation) UnitCategoryIDs() (ids []string) {
	if id := m.unit_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnitCategory resets all changes to the "unit_category" edge.
func (m *UnitMutation) ResetUnitCategory() {
	m.unit_category = nil
	m.clearedunit_category = false
}

// Where appends a list predicates to the UnitMutation builder.
func (m *UnitMutation) Where(ps ...predicate.Unit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Unit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Unit).
func (m *UnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UnitMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.base_unit != nil {
		fields = append(fields, unit.FieldBaseUnit)
	}
	if m.unit_category != nil {
		fields = append(fields, unit.FieldCategoryID)
	}
	if m.created_at != nil {
		fields = append(fields, unit.FieldCreatedAt)
	}
	if m.etag != nil {
		fields = append(fields, unit.FieldEtag)
	}
	if m.multiplier != nil {
		fields = append(fields, unit.FieldMultiplier)
	}
	if m.org_id != nil {
		fields = append(fields, unit.FieldOrgID)
	}
	if m.name != nil {
		fields = append(fields, unit.FieldName)
	}
	if m.status != nil {
		fields = append(fields, unit.FieldStatus)
	}
	if m.symbol != nil {
		fields = append(fields, unit.FieldSymbol)
	}
	if m.updated_at != nil {
		fields = append(fields, unit.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case unit.FieldBaseUnit:
		return m.BaseUnit()
	case unit.FieldCategoryID:
		return m.CategoryID()
	case unit.FieldCreatedAt:
		return m.CreatedAt()
	case unit.FieldEtag:
		return m.Etag()
	case unit.FieldMultiplier:
		return m.Multiplier()
	case unit.FieldOrgID:
		return m.OrgID()
	case unit.FieldName:
		return m.Name()
	case unit.FieldStatus:
		return m.Status()
	case unit.FieldSymbol:
		return m.Symbol()
	case unit.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case unit.FieldBaseUnit:
		return m.OldBaseUnit(ctx)
	case unit.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case unit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case unit.FieldEtag:
		return m.OldEtag(ctx)
	case unit.FieldMultiplier:
		return m.OldMultiplier(ctx)
	case unit.FieldOrgID:
		return m.OldOrgID(ctx)
	case unit.FieldName:
		return m.OldName(ctx)
	case unit.FieldStatus:
		return m.OldStatus(ctx)
	case unit.FieldSymbol:
		return m.OldSymbol(ctx)
	case unit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Unit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case unit.FieldBaseUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseUnit(v)
		return nil
	case unit.FieldCategoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case unit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case unit.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case unit.FieldMultiplier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiplier(v)
		return nil
	case unit.FieldOrgID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case unit.FieldName:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case unit.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case unit.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case unit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Unit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UnitMutation) AddedFields() []string {
	var fields []string
	if m.addmultiplier != nil {
		fields = append(fields, unit.FieldMultiplier)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case unit.FieldMultiplier:
		return m.AddedMultiplier()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case unit.FieldMultiplier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMultiplier(v)
		return nil
	}
	return fmt.Errorf("unknown Unit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(unit.FieldBaseUnit) {
		fields = append(fields, unit.FieldBaseUnit)
	}
	if m.FieldCleared(unit.FieldCategoryID) {
		fields = append(fields, unit.FieldCategoryID)
	}
	if m.FieldCleared(unit.FieldMultiplier) {
		fields = append(fields, unit.FieldMultiplier)
	}
	if m.FieldCleared(unit.FieldOrgID) {
		fields = append(fields, unit.FieldOrgID)
	}
	if m.FieldCleared(unit.FieldStatus) {
		fields = append(fields, unit.FieldStatus)
	}
	if m.FieldCleared(unit.FieldUpdatedAt) {
		fields = append(fields, unit.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UnitMutation) ClearField(name string) error {
	switch name {
	case unit.FieldBaseUnit:
		m.ClearBaseUnit()
		return nil
	case unit.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case unit.FieldMultiplier:
		m.ClearMultiplier()
		return nil
	case unit.FieldOrgID:
		m.ClearOrgID()
		return nil
	case unit.FieldStatus:
		m.ClearStatus()
		return nil
	case unit.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Unit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UnitMutation) ResetField(name string) error {
	switch name {
	case unit.FieldBaseUnit:
		m.ResetBaseUnit()
		return nil
	case unit.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case unit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case unit.FieldEtag:
		m.ResetEtag()
		return nil
	case unit.FieldMultiplier:
		m.ResetMultiplier()
		return nil
	case unit.FieldOrgID:
		m.ResetOrgID()
		return nil
	case unit.FieldName:
		m.ResetName()
		return nil
	case unit.FieldStatus:
		m.ResetStatus()
		return nil
	case unit.FieldSymbol:
		m.ResetSymbol()
		return nil
	case unit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Unit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, unit.EdgeProduct)
	}
	if m.unit_category != nil {
		edges = append(edges, unit.EdgeUnitCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case unit.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.product))
		for id := range m.product {
			ids = append(ids, id)
		}
		return ids
	case unit.EdgeUnitCategory:
		if id := m.unit_category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproduct != nil {
		edges = append(edges, unit.EdgeProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case unit.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removedproduct))
		for id := range m.removedproduct {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, unit.EdgeProduct)
	}
	if m.clearedunit_category {
		edges = append(edges, unit.EdgeUnitCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UnitMutation) EdgeCleared(name string) bool {
	switch name {
	case unit.EdgeProduct:
		return m.clearedproduct
	case unit.EdgeUnitCategory:
		return m.clearedunit_category
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UnitMutation) ClearEdge(name string) error {
	switch name {
	case unit.EdgeUnitCategory:
		m.ClearUnitCategory()
		return nil
	}
	return fmt.Errorf("unknown Unit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UnitMutation) ResetEdge(name string) error {
	switch name {
	case unit.EdgeProduct:
		m.ResetProduct()
		return nil
	case unit.EdgeUnitCategory:
		m.ResetUnitCategory()
		return nil
	}
	return fmt.Errorf("unknown Unit edge %s", name)
}

// UnitCategoryMutation represents an operation that mutates the UnitCategory nodes in the graph.
type UnitCategoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	default_variant_id *string
	description        *model.LangJson
	etag               *string
	name               *model.LangJson
	org_id             *string
	status             *string
	tag_ids            *string
	thumbnail_url      *string
	unit_id            *string
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	unit               map[string]struct{}
	removedunit        map[string]struct{}
	clearedunit        bool
	done               bool
	oldValue           func(context.Context) (*UnitCategory, error)
	predicates         []predicate.UnitCategory
}

var _ ent.Mutation = (*UnitCategoryMutation)(nil)

// unitcategoryOption allows management of the mutation configuration using functional options.
type unitcategoryOption func(*UnitCategoryMutation)

// newUnitCategoryMutation creates new mutation for the UnitCategory entity.
func newUnitCategoryMutation(c config, op Op, opts ...unitcategoryOption) *UnitCategoryMutation {
	m := &UnitCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeUnitCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUnitCategoryID sets the ID field of the mutation.
func withUnitCategoryID(id string) unitcategoryOption {
	return func(m *UnitCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *UnitCategory
		)
		m.oldValue = func(ctx context.Context) (*UnitCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UnitCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUnitCategory sets the old UnitCategory of the mutation.
func withUnitCategory(node *UnitCategory) unitcategoryOption {
	return func(m *UnitCategoryMutation) {
		m.oldValue = func(context.Context) (*UnitCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UnitCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UnitCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UnitCategory entities.
func (m *UnitCategoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UnitCategoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UnitCategoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UnitCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UnitCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UnitCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UnitCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDefaultVariantID sets the "default_variant_id" field.
func (m *UnitCategoryMutation) SetDefaultVariantID(s string) {
	m.default_variant_id = &s
}

// DefaultVariantID returns the value of the "default_variant_id" field in the mutation.
func (m *UnitCategoryMutation) DefaultVariantID() (r string, exists bool) {
	v := m.default_variant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultVariantID returns the old "default_variant_id" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldDefaultVariantID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultVariantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultVariantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultVariantID: %w", err)
	}
	return oldValue.DefaultVariantID, nil
}

// ClearDefaultVariantID clears the value of the "default_variant_id" field.
func (m *UnitCategoryMutation) ClearDefaultVariantID() {
	m.default_variant_id = nil
	m.clearedFields[unitcategory.FieldDefaultVariantID] = struct{}{}
}

// DefaultVariantIDCleared returns if the "default_variant_id" field was cleared in this mutation.
func (m *UnitCategoryMutation) DefaultVariantIDCleared() bool {
	_, ok := m.clearedFields[unitcategory.FieldDefaultVariantID]
	return ok
}

// ResetDefaultVariantID resets all changes to the "default_variant_id" field.
func (m *UnitCategoryMutation) ResetDefaultVariantID() {
	m.default_variant_id = nil
	delete(m.clearedFields, unitcategory.FieldDefaultVariantID)
}

// SetDescription sets the "description" field.
func (m *UnitCategoryMutation) SetDescription(mj model.LangJson) {
	m.description = &mj
}

// Description returns the value of the "description" field in the mutation.
func (m *UnitCategoryMutation) Description() (r model.LangJson, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldDescription(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UnitCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[unitcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UnitCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[unitcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UnitCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, unitcategory.FieldDescription)
}

// SetEtag sets the "etag" field.
func (m *UnitCategoryMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *UnitCategoryMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *UnitCategoryMutation) ResetEtag() {
	m.etag = nil
}

// SetName sets the "name" field.
func (m *UnitCategoryMutation) SetName(mj model.LangJson) {
	m.name = &mj
}

// Name returns the value of the "name" field in the mutation.
func (m *UnitCategoryMutation) Name() (r model.LangJson, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldName(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UnitCategoryMutation) ResetName() {
	m.name = nil
}

// SetOrgID sets the "org_id" field.
func (m *UnitCategoryMutation) SetOrgID(s string) {
	m.org_id = &s
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *UnitCategoryMutation) OrgID() (r string, exists bool) {
	v := m.org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldOrgID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *UnitCategoryMutation) ResetOrgID() {
	m.org_id = nil
}

// SetStatus sets the "status" field.
func (m *UnitCategoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UnitCategoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UnitCategoryMutation) ResetStatus() {
	m.status = nil
}

// SetTagIds sets the "tag_ids" field.
func (m *UnitCategoryMutation) SetTagIds(s string) {
	m.tag_ids = &s
}

// TagIds returns the value of the "tag_ids" field in the mutation.
func (m *UnitCategoryMutation) TagIds() (r string, exists bool) {
	v := m.tag_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldTagIds returns the old "tag_ids" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldTagIds(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagIds: %w", err)
	}
	return oldValue.TagIds, nil
}

// ClearTagIds clears the value of the "tag_ids" field.
func (m *UnitCategoryMutation) ClearTagIds() {
	m.tag_ids = nil
	m.clearedFields[unitcategory.FieldTagIds] = struct{}{}
}

// TagIdsCleared returns if the "tag_ids" field was cleared in this mutation.
func (m *UnitCategoryMutation) TagIdsCleared() bool {
	_, ok := m.clearedFields[unitcategory.FieldTagIds]
	return ok
}

// ResetTagIds resets all changes to the "tag_ids" field.
func (m *UnitCategoryMutation) ResetTagIds() {
	m.tag_ids = nil
	delete(m.clearedFields, unitcategory.FieldTagIds)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *UnitCategoryMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *UnitCategoryMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldThumbnailURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *UnitCategoryMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[unitcategory.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *UnitCategoryMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[unitcategory.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *UnitCategoryMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, unitcategory.FieldThumbnailURL)
}

// SetUnitID sets the "unit_id" field.
func (m *UnitCategoryMutation) SetUnitID(s string) {
	m.unit_id = &s
}

// UnitID returns the value of the "unit_id" field in the mutation.
func (m *UnitCategoryMutation) UnitID() (r string, exists bool) {
	v := m.unit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitID returns the old "unit_id" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldUnitID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitID: %w", err)
	}
	return oldValue.UnitID, nil
}

// ResetUnitID resets all changes to the "unit_id" field.
func (m *UnitCategoryMutation) ResetUnitID() {
	m.unit_id = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UnitCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UnitCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UnitCategory entity.
// If the UnitCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitCategoryMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UnitCategoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[unitcategory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UnitCategoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[unitcategory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UnitCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, unitcategory.FieldUpdatedAt)
}

// AddUnitIDs adds the "unit" edge to the Unit entity by ids.
func (m *UnitCategoryMutation) AddUnitIDs(ids ...string) {
	if m.unit == nil {
		m.unit = make(map[string]struct{})
	}
	for i := range ids {
		m.unit[ids[i]] = struct{}{}
	}
}

// ClearUnit clears the "unit" edge to the Unit entity.
func (m *UnitCategoryMutation) ClearUnit() {
	m.clearedunit = true
}

// UnitCleared reports if the "unit" edge to the Unit entity was cleared.
func (m *UnitCategoryMutation) UnitCleared() bool {
	return m.clearedunit
}

// RemoveUnitIDs removes the "unit" edge to the Unit entity by IDs.
func (m *UnitCategoryMutation) RemoveUnitIDs(ids ...string) {
	if m.removedunit == nil {
		m.removedunit = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.unit, ids[i])
		m.removedunit[ids[i]] = struct{}{}
	}
}

// RemovedUnit returns the removed IDs of the "unit" edge to the Unit entity.
func (m *UnitCategoryMutation) RemovedUnitIDs() (ids []string) {
	for id := range m.removedunit {
		ids = append(ids, id)
	}
	return
}

// UnitIDs returns the "unit" edge IDs in the mutation.
func (m *UnitCategoryMutation) UnitIDs() (ids []string) {
	for id := range m.unit {
		ids = append(ids, id)
	}
	return
}

// ResetUnit resets all changes to the "unit" edge.
func (m *UnitCategoryMutation) ResetUnit() {
	m.unit = nil
	m.clearedunit = false
	m.removedunit = nil
}

// Where appends a list predicates to the UnitCategoryMutation builder.
func (m *UnitCategoryMutation) Where(ps ...predicate.UnitCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UnitCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UnitCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UnitCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UnitCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UnitCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UnitCategory).
func (m *UnitCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UnitCategoryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, unitcategory.FieldCreatedAt)
	}
	if m.default_variant_id != nil {
		fields = append(fields, unitcategory.FieldDefaultVariantID)
	}
	if m.description != nil {
		fields = append(fields, unitcategory.FieldDescription)
	}
	if m.etag != nil {
		fields = append(fields, unitcategory.FieldEtag)
	}
	if m.name != nil {
		fields = append(fields, unitcategory.FieldName)
	}
	if m.org_id != nil {
		fields = append(fields, unitcategory.FieldOrgID)
	}
	if m.status != nil {
		fields = append(fields, unitcategory.FieldStatus)
	}
	if m.tag_ids != nil {
		fields = append(fields, unitcategory.FieldTagIds)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, unitcategory.FieldThumbnailURL)
	}
	if m.unit_id != nil {
		fields = append(fields, unitcategory.FieldUnitID)
	}
	if m.updated_at != nil {
		fields = append(fields, unitcategory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UnitCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case unitcategory.FieldCreatedAt:
		return m.CreatedAt()
	case unitcategory.FieldDefaultVariantID:
		return m.DefaultVariantID()
	case unitcategory.FieldDescription:
		return m.Description()
	case unitcategory.FieldEtag:
		return m.Etag()
	case unitcategory.FieldName:
		return m.Name()
	case unitcategory.FieldOrgID:
		return m.OrgID()
	case unitcategory.FieldStatus:
		return m.Status()
	case unitcategory.FieldTagIds:
		return m.TagIds()
	case unitcategory.FieldThumbnailURL:
		return m.ThumbnailURL()
	case unitcategory.FieldUnitID:
		return m.UnitID()
	case unitcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UnitCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case unitcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case unitcategory.FieldDefaultVariantID:
		return m.OldDefaultVariantID(ctx)
	case unitcategory.FieldDescription:
		return m.OldDescription(ctx)
	case unitcategory.FieldEtag:
		return m.OldEtag(ctx)
	case unitcategory.FieldName:
		return m.OldName(ctx)
	case unitcategory.FieldOrgID:
		return m.OldOrgID(ctx)
	case unitcategory.FieldStatus:
		return m.OldStatus(ctx)
	case unitcategory.FieldTagIds:
		return m.OldTagIds(ctx)
	case unitcategory.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case unitcategory.FieldUnitID:
		return m.OldUnitID(ctx)
	case unitcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UnitCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnitCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case unitcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case unitcategory.FieldDefaultVariantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultVariantID(v)
		return nil
	case unitcategory.FieldDescription:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case unitcategory.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case unitcategory.FieldName:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case unitcategory.FieldOrgID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case unitcategory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case unitcategory.FieldTagIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagIds(v)
		return nil
	case unitcategory.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case unitcategory.FieldUnitID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitID(v)
		return nil
	case unitcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UnitCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UnitCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UnitCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnitCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UnitCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UnitCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(unitcategory.FieldDefaultVariantID) {
		fields = append(fields, unitcategory.FieldDefaultVariantID)
	}
	if m.FieldCleared(unitcategory.FieldDescription) {
		fields = append(fields, unitcategory.FieldDescription)
	}
	if m.FieldCleared(unitcategory.FieldTagIds) {
		fields = append(fields, unitcategory.FieldTagIds)
	}
	if m.FieldCleared(unitcategory.FieldThumbnailURL) {
		fields = append(fields, unitcategory.FieldThumbnailURL)
	}
	if m.FieldCleared(unitcategory.FieldUpdatedAt) {
		fields = append(fields, unitcategory.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UnitCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UnitCategoryMutation) ClearField(name string) error {
	switch name {
	case unitcategory.FieldDefaultVariantID:
		m.ClearDefaultVariantID()
		return nil
	case unitcategory.FieldDescription:
		m.ClearDescription()
		return nil
	case unitcategory.FieldTagIds:
		m.ClearTagIds()
		return nil
	case unitcategory.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case unitcategory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UnitCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UnitCategoryMutation) ResetField(name string) error {
	switch name {
	case unitcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case unitcategory.FieldDefaultVariantID:
		m.ResetDefaultVariantID()
		return nil
	case unitcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case unitcategory.FieldEtag:
		m.ResetEtag()
		return nil
	case unitcategory.FieldName:
		m.ResetName()
		return nil
	case unitcategory.FieldOrgID:
		m.ResetOrgID()
		return nil
	case unitcategory.FieldStatus:
		m.ResetStatus()
		return nil
	case unitcategory.FieldTagIds:
		m.ResetTagIds()
		return nil
	case unitcategory.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case unitcategory.FieldUnitID:
		m.ResetUnitID()
		return nil
	case unitcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UnitCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UnitCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.unit != nil {
		edges = append(edges, unitcategory.EdgeUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UnitCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case unitcategory.EdgeUnit:
		ids := make([]ent.Value, 0, len(m.unit))
		for id := range m.unit {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UnitCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedunit != nil {
		edges = append(edges, unitcategory.EdgeUnit)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UnitCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case unitcategory.EdgeUnit:
		ids := make([]ent.Value, 0, len(m.removedunit))
		for id := range m.removedunit {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UnitCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedunit {
		edges = append(edges, unitcategory.EdgeUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UnitCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case unitcategory.EdgeUnit:
		return m.clearedunit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UnitCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UnitCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UnitCategoryMutation) ResetEdge(name string) error {
	switch name {
	case unitcategory.EdgeUnit:
		m.ResetUnit()
		return nil
	}
	return fmt.Errorf("unknown UnitCategory edge %s", name)
}

// VariantMutation represents an operation that mutates the Variant nodes in the graph.
type VariantMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	barcode                *string
	created_at             *time.Time
	etag                   *string
	proposed_price         *int
	addproposed_price      *int
	sku                    *string
	status                 *string
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	product                *string
	clearedproduct         bool
	attribute_value        map[string]struct{}
	removedattribute_value map[string]struct{}
	clearedattribute_value bool
	done                   bool
	oldValue               func(context.Context) (*Variant, error)
	predicates             []predicate.Variant
}

var _ ent.Mutation = (*VariantMutation)(nil)

// variantOption allows management of the mutation configuration using functional options.
type variantOption func(*VariantMutation)

// newVariantMutation creates new mutation for the Variant entity.
func newVariantMutation(c config, op Op, opts ...variantOption) *VariantMutation {
	m := &VariantMutation{
		config:        c,
		op:            op,
		typ:           TypeVariant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVariantID sets the ID field of the mutation.
func withVariantID(id string) variantOption {
	return func(m *VariantMutation) {
		var (
			err   error
			once  sync.Once
			value *Variant
		)
		m.oldValue = func(ctx context.Context) (*Variant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Variant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVariant sets the old Variant of the mutation.
func withVariant(node *Variant) variantOption {
	return func(m *VariantMutation) {
		m.oldValue = func(context.Context) (*Variant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VariantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VariantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Variant entities.
func (m *VariantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VariantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VariantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Variant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBarcode sets the "barcode" field.
func (m *VariantMutation) SetBarcode(s string) {
	m.barcode = &s
}

// Barcode returns the value of the "barcode" field in the mutation.
func (m *VariantMutation) Barcode() (r string, exists bool) {
	v := m.barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcode returns the old "barcode" field's value of the Variant entity.
// If the Variant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantMutation) OldBarcode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcode: %w", err)
	}
	return oldValue.Barcode, nil
}

// ClearBarcode clears the value of the "barcode" field.
func (m *VariantMutation) ClearBarcode() {
	m.barcode = nil
	m.clearedFields[variant.FieldBarcode] = struct{}{}
}

// BarcodeCleared returns if the "barcode" field was cleared in this mutation.
func (m *VariantMutation) BarcodeCleared() bool {
	_, ok := m.clearedFields[variant.FieldBarcode]
	return ok
}

// ResetBarcode resets all changes to the "barcode" field.
func (m *VariantMutation) ResetBarcode() {
	m.barcode = nil
	delete(m.clearedFields, variant.FieldBarcode)
}

// SetCreatedAt sets the "created_at" field.
func (m *VariantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VariantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Variant entity.
// If the Variant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VariantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEtag sets the "etag" field.
func (m *VariantMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *VariantMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Variant entity.
// If the Variant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *VariantMutation) ResetEtag() {
	m.etag = nil
}

// SetProposedPrice sets the "proposed_price" field.
func (m *VariantMutation) SetProposedPrice(i int) {
	m.proposed_price = &i
	m.addproposed_price = nil
}

// ProposedPrice returns the value of the "proposed_price" field in the mutation.
func (m *VariantMutation) ProposedPrice() (r int, exists bool) {
	v := m.proposed_price
	if v == nil {
		return
	}
	return *v, true
}

// OldProposedPrice returns the old "proposed_price" field's value of the Variant entity.
// If the Variant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantMutation) OldProposedPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProposedPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProposedPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProposedPrice: %w", err)
	}
	return oldValue.ProposedPrice, nil
}

// AddProposedPrice adds i to the "proposed_price" field.
func (m *VariantMutation) AddProposedPrice(i int) {
	if m.addproposed_price != nil {
		*m.addproposed_price += i
	} else {
		m.addproposed_price = &i
	}
}

// AddedProposedPrice returns the value that was added to the "proposed_price" field in this mutation.
func (m *VariantMutation) AddedProposedPrice() (r int, exists bool) {
	v := m.addproposed_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetProposedPrice resets all changes to the "proposed_price" field.
func (m *VariantMutation) ResetProposedPrice() {
	m.proposed_price = nil
	m.addproposed_price = nil
}

// SetProductID sets the "product_id" field.
func (m *VariantMutation) SetProductID(s string) {
	m.product = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *VariantMutation) ProductID() (r string, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Variant entity.
// If the Variant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *VariantMutation) ResetProductID() {
	m.product = nil
}

// SetSku sets the "sku" field.
func (m *VariantMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *VariantMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Variant entity.
// If the Variant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *VariantMutation) ResetSku() {
	m.sku = nil
}

// SetStatus sets the "status" field.
func (m *VariantMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *VariantMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Variant entity.
// If the Variant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VariantMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VariantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VariantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Variant entity.
// If the Variant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VariantMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *VariantMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[variant.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *VariantMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[variant.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VariantMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, variant.FieldUpdatedAt)
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *VariantMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[variant.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *VariantMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *VariantMutation) ProductIDs() (ids []string) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *VariantMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// AddAttributeValueIDs adds the "attribute_value" edge to the AttributeValue entity by ids.
func (m *VariantMutation) AddAttributeValueIDs(ids ...string) {
	if m.attribute_value == nil {
		m.attribute_value = make(map[string]struct{})
	}
	for i := range ids {
		m.attribute_value[ids[i]] = struct{}{}
	}
}

// ClearAttributeValue clears the "attribute_value" edge to the AttributeValue entity.
func (m *VariantMutation) ClearAttributeValue() {
	m.clearedattribute_value = true
}

// AttributeValueCleared reports if the "attribute_value" edge to the AttributeValue entity was cleared.
func (m *VariantMutation) AttributeValueCleared() bool {
	return m.clearedattribute_value
}

// RemoveAttributeValueIDs removes the "attribute_value" edge to the AttributeValue entity by IDs.
func (m *VariantMutation) RemoveAttributeValueIDs(ids ...string) {
	if m.removedattribute_value == nil {
		m.removedattribute_value = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.attribute_value, ids[i])
		m.removedattribute_value[ids[i]] = struct{}{}
	}
}

// RemovedAttributeValue returns the removed IDs of the "attribute_value" edge to the AttributeValue entity.
func (m *VariantMutation) RemovedAttributeValueIDs() (ids []string) {
	for id := range m.removedattribute_value {
		ids = append(ids, id)
	}
	return
}

// AttributeValueIDs returns the "attribute_value" edge IDs in the mutation.
func (m *VariantMutation) AttributeValueIDs() (ids []string) {
	for id := range m.attribute_value {
		ids = append(ids, id)
	}
	return
}

// ResetAttributeValue resets all changes to the "attribute_value" edge.
func (m *VariantMutation) ResetAttributeValue() {
	m.attribute_value = nil
	m.clearedattribute_value = false
	m.removedattribute_value = nil
}

// Where appends a list predicates to the VariantMutation builder.
func (m *VariantMutation) Where(ps ...predicate.Variant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VariantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VariantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Variant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VariantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VariantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Variant).
func (m *VariantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VariantMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.barcode != nil {
		fields = append(fields, variant.FieldBarcode)
	}
	if m.created_at != nil {
		fields = append(fields, variant.FieldCreatedAt)
	}
	if m.etag != nil {
		fields = append(fields, variant.FieldEtag)
	}
	if m.proposed_price != nil {
		fields = append(fields, variant.FieldProposedPrice)
	}
	if m.product != nil {
		fields = append(fields, variant.FieldProductID)
	}
	if m.sku != nil {
		fields = append(fields, variant.FieldSku)
	}
	if m.status != nil {
		fields = append(fields, variant.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, variant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VariantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case variant.FieldBarcode:
		return m.Barcode()
	case variant.FieldCreatedAt:
		return m.CreatedAt()
	case variant.FieldEtag:
		return m.Etag()
	case variant.FieldProposedPrice:
		return m.ProposedPrice()
	case variant.FieldProductID:
		return m.ProductID()
	case variant.FieldSku:
		return m.Sku()
	case variant.FieldStatus:
		return m.Status()
	case variant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VariantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case variant.FieldBarcode:
		return m.OldBarcode(ctx)
	case variant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case variant.FieldEtag:
		return m.OldEtag(ctx)
	case variant.FieldProposedPrice:
		return m.OldProposedPrice(ctx)
	case variant.FieldProductID:
		return m.OldProductID(ctx)
	case variant.FieldSku:
		return m.OldSku(ctx)
	case variant.FieldStatus:
		return m.OldStatus(ctx)
	case variant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Variant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VariantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case variant.FieldBarcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcode(v)
		return nil
	case variant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case variant.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case variant.FieldProposedPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProposedPrice(v)
		return nil
	case variant.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case variant.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case variant.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case variant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Variant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VariantMutation) AddedFields() []string {
	var fields []string
	if m.addproposed_price != nil {
		fields = append(fields, variant.FieldProposedPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VariantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case variant.FieldProposedPrice:
		return m.AddedProposedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VariantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case variant.FieldProposedPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProposedPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Variant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VariantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(variant.FieldBarcode) {
		fields = append(fields, variant.FieldBarcode)
	}
	if m.FieldCleared(variant.FieldUpdatedAt) {
		fields = append(fields, variant.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VariantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VariantMutation) ClearField(name string) error {
	switch name {
	case variant.FieldBarcode:
		m.ClearBarcode()
		return nil
	case variant.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Variant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VariantMutation) ResetField(name string) error {
	switch name {
	case variant.FieldBarcode:
		m.ResetBarcode()
		return nil
	case variant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case variant.FieldEtag:
		m.ResetEtag()
		return nil
	case variant.FieldProposedPrice:
		m.ResetProposedPrice()
		return nil
	case variant.FieldProductID:
		m.ResetProductID()
		return nil
	case variant.FieldSku:
		m.ResetSku()
		return nil
	case variant.FieldStatus:
		m.ResetStatus()
		return nil
	case variant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Variant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VariantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, variant.EdgeProduct)
	}
	if m.attribute_value != nil {
		edges = append(edges, variant.EdgeAttributeValue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VariantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case variant.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case variant.EdgeAttributeValue:
		ids := make([]ent.Value, 0, len(m.attribute_value))
		for id := range m.attribute_value {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VariantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedattribute_value != nil {
		edges = append(edges, variant.EdgeAttributeValue)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VariantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case variant.EdgeAttributeValue:
		ids := make([]ent.Value, 0, len(m.removedattribute_value))
		for id := range m.removedattribute_value {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VariantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, variant.EdgeProduct)
	}
	if m.clearedattribute_value {
		edges = append(edges, variant.EdgeAttributeValue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VariantMutation) EdgeCleared(name string) bool {
	switch name {
	case variant.EdgeProduct:
		return m.clearedproduct
	case variant.EdgeAttributeValue:
		return m.clearedattribute_value
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VariantMutation) ClearEdge(name string) error {
	switch name {
	case variant.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Variant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VariantMutation) ResetEdge(name string) error {
	switch name {
	case variant.EdgeProduct:
		m.ResetProduct()
		return nil
	case variant.EdgeAttributeValue:
		m.ResetAttributeValue()
		return nil
	}
	return fmt.Errorf("unknown Variant edge %s", name)
}

// VariantAttributeRelMutation represents an operation that mutates the VariantAttributeRel nodes in the graph.
type VariantAttributeRelMutation struct {
	config
	op                     Op
	typ                    string
	clearedFields          map[string]struct{}
	variant                *string
	clearedvariant         bool
	attribute_value        *string
	clearedattribute_value bool
	done                   bool
	oldValue               func(context.Context) (*VariantAttributeRel, error)
	predicates             []predicate.VariantAttributeRel
}

var _ ent.Mutation = (*VariantAttributeRelMutation)(nil)

// variantattributerelOption allows management of the mutation configuration using functional options.
type variantattributerelOption func(*VariantAttributeRelMutation)

// newVariantAttributeRelMutation creates new mutation for the VariantAttributeRel entity.
func newVariantAttributeRelMutation(c config, op Op, opts ...variantattributerelOption) *VariantAttributeRelMutation {
	m := &VariantAttributeRelMutation{
		config:        c,
		op:            op,
		typ:           TypeVariantAttributeRel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VariantAttributeRelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VariantAttributeRelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetVariantID sets the "variant_id" field.
func (m *VariantAttributeRelMutation) SetVariantID(s string) {
	m.variant = &s
}

// VariantID returns the value of the "variant_id" field in the mutation.
func (m *VariantAttributeRelMutation) VariantID() (r string, exists bool) {
	v := m.variant
	if v == nil {
		return
	}
	return *v, true
}

// ResetVariantID resets all changes to the "variant_id" field.
func (m *VariantAttributeRelMutation) ResetVariantID() {
	m.variant = nil
}

// SetAttributeValueID sets the "attribute_value_id" field.
func (m *VariantAttributeRelMutation) SetAttributeValueID(s string) {
	m.attribute_value = &s
}

// AttributeValueID returns the value of the "attribute_value_id" field in the mutation.
func (m *VariantAttributeRelMutation) AttributeValueID() (r string, exists bool) {
	v := m.attribute_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttributeValueID resets all changes to the "attribute_value_id" field.
func (m *VariantAttributeRelMutation) ResetAttributeValueID() {
	m.attribute_value = nil
}

// ClearVariant clears the "variant" edge to the Variant entity.
func (m *VariantAttributeRelMutation) ClearVariant() {
	m.clearedvariant = true
	m.clearedFields[variantattributerel.FieldVariantID] = struct{}{}
}

// VariantCleared reports if the "variant" edge to the Variant entity was cleared.
func (m *VariantAttributeRelMutation) VariantCleared() bool {
	return m.clearedvariant
}

// VariantIDs returns the "variant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VariantID instead. It exists only for internal usage by the builders.
func (m *VariantAttributeRelMutation) VariantIDs() (ids []string) {
	if id := m.variant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVariant resets all changes to the "variant" edge.
func (m *VariantAttributeRelMutation) ResetVariant() {
	m.variant = nil
	m.clearedvariant = false
}

// ClearAttributeValue clears the "attribute_value" edge to the AttributeValue entity.
func (m *VariantAttributeRelMutation) ClearAttributeValue() {
	m.clearedattribute_value = true
	m.clearedFields[variantattributerel.FieldAttributeValueID] = struct{}{}
}

// AttributeValueCleared reports if the "attribute_value" edge to the AttributeValue entity was cleared.
func (m *VariantAttributeRelMutation) AttributeValueCleared() bool {
	return m.clearedattribute_value
}

// AttributeValueIDs returns the "attribute_value" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttributeValueID instead. It exists only for internal usage by the builders.
func (m *VariantAttributeRelMutation) AttributeValueIDs() (ids []string) {
	if id := m.attribute_value; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttributeValue resets all changes to the "attribute_value" edge.
func (m *VariantAttributeRelMutation) ResetAttributeValue() {
	m.attribute_value = nil
	m.clearedattribute_value = false
}

// Where appends a list predicates to the VariantAttributeRelMutation builder.
func (m *VariantAttributeRelMutation) Where(ps ...predicate.VariantAttributeRel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VariantAttributeRelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VariantAttributeRelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VariantAttributeRel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VariantAttributeRelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VariantAttributeRelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VariantAttributeRel).
func (m *VariantAttributeRelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VariantAttributeRelMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.variant != nil {
		fields = append(fields, variantattributerel.FieldVariantID)
	}
	if m.attribute_value != nil {
		fields = append(fields, variantattributerel.FieldAttributeValueID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VariantAttributeRelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case variantattributerel.FieldVariantID:
		return m.VariantID()
	case variantattributerel.FieldAttributeValueID:
		return m.AttributeValueID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VariantAttributeRelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema VariantAttributeRel does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VariantAttributeRelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case variantattributerel.FieldVariantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariantID(v)
		return nil
	case variantattributerel.FieldAttributeValueID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributeValueID(v)
		return nil
	}
	return fmt.Errorf("unknown VariantAttributeRel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VariantAttributeRelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VariantAttributeRelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VariantAttributeRelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VariantAttributeRel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VariantAttributeRelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VariantAttributeRelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VariantAttributeRelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VariantAttributeRel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VariantAttributeRelMutation) ResetField(name string) error {
	switch name {
	case variantattributerel.FieldVariantID:
		m.ResetVariantID()
		return nil
	case variantattributerel.FieldAttributeValueID:
		m.ResetAttributeValueID()
		return nil
	}
	return fmt.Errorf("unknown VariantAttributeRel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VariantAttributeRelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.variant != nil {
		edges = append(edges, variantattributerel.EdgeVariant)
	}
	if m.attribute_value != nil {
		edges = append(edges, variantattributerel.EdgeAttributeValue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VariantAttributeRelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case variantattributerel.EdgeVariant:
		if id := m.variant; id != nil {
			return []ent.Value{*id}
		}
	case variantattributerel.EdgeAttributeValue:
		if id := m.attribute_value; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VariantAttributeRelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VariantAttributeRelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VariantAttributeRelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvariant {
		edges = append(edges, variantattributerel.EdgeVariant)
	}
	if m.clearedattribute_value {
		edges = append(edges, variantattributerel.EdgeAttributeValue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VariantAttributeRelMutation) EdgeCleared(name string) bool {
	switch name {
	case variantattributerel.EdgeVariant:
		return m.clearedvariant
	case variantattributerel.EdgeAttributeValue:
		return m.clearedattribute_value
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VariantAttributeRelMutation) ClearEdge(name string) error {
	switch name {
	case variantattributerel.EdgeVariant:
		m.ClearVariant()
		return nil
	case variantattributerel.EdgeAttributeValue:
		m.ClearAttributeValue()
		return nil
	}
	return fmt.Errorf("unknown VariantAttributeRel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VariantAttributeRelMutation) ResetEdge(name string) error {
	switch name {
	case variantattributerel.EdgeVariant:
		m.ResetVariant()
		return nil
	case variantattributerel.EdgeAttributeValue:
		m.ResetAttributeValue()
		return nil
	}
	return fmt.Errorf("unknown VariantAttributeRel edge %s", name)
}
