// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/action"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/entitlement"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/entitlementassignment"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/grantrequest"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/grantresponse"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/permissionhistory"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/predicate"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/resource"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/revokerequest"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/role"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/rolerolesuite"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/rolesuite"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/rolesuiteuser"
	"github.com/sky-as-code/nikki-erp/modules/authorize/infra/ent/roleuser"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAction                    = "Action"
	TypeEffectiveGroupEntitlement = "EffectiveGroupEntitlement"
	TypeEffectiveUserEntitlement  = "EffectiveUserEntitlement"
	TypeEntitlement               = "Entitlement"
	TypeEntitlementAssignment     = "EntitlementAssignment"
	TypeGrantRequest              = "GrantRequest"
	TypeGrantResponse             = "GrantResponse"
	TypePermissionHistory         = "PermissionHistory"
	TypeResource                  = "Resource"
	TypeRevokeRequest             = "RevokeRequest"
	TypeRole                      = "Role"
	TypeRoleRoleSuite             = "RoleRoleSuite"
	TypeRoleSuite                 = "RoleSuite"
	TypeRoleSuiteUser             = "RoleSuiteUser"
	TypeRoleUser                  = "RoleUser"
)

// ActionMutation represents an operation that mutates the Action nodes in the graph.
type ActionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	created_by          *string
	name                *string
	etag                *string
	description         *string
	clearedFields       map[string]struct{}
	entitlements        map[string]struct{}
	removedentitlements map[string]struct{}
	clearedentitlements bool
	resource            *string
	clearedresource     bool
	done                bool
	oldValue            func(context.Context) (*Action, error)
	predicates          []predicate.Action
}

var _ ent.Mutation = (*ActionMutation)(nil)

// actionOption allows management of the mutation configuration using functional options.
type actionOption func(*ActionMutation)

// newActionMutation creates new mutation for the Action entity.
func newActionMutation(c config, op Op, opts ...actionOption) *ActionMutation {
	m := &ActionMutation{
		config:        c,
		op:            op,
		typ:           TypeAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionID sets the ID field of the mutation.
func withActionID(id string) actionOption {
	return func(m *ActionMutation) {
		var (
			err   error
			once  sync.Once
			value *Action
		)
		m.oldValue = func(ctx context.Context) (*Action, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Action.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAction sets the old Action of the mutation.
func withAction(node *Action) actionOption {
	return func(m *ActionMutation) {
		m.oldValue = func(context.Context) (*Action, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Action entities.
func (m *ActionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Action.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ActionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ActionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ActionMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetName sets the "name" field.
func (m *ActionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActionMutation) ResetName() {
	m.name = nil
}

// SetEtag sets the "etag" field.
func (m *ActionMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *ActionMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *ActionMutation) ResetEtag() {
	m.etag = nil
}

// SetResourceID sets the "resource_id" field.
func (m *ActionMutation) SetResourceID(s string) {
	m.resource = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ActionMutation) ResourceID() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ActionMutation) ResetResourceID() {
	m.resource = nil
}

// SetDescription sets the "description" field.
func (m *ActionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ActionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ActionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[action.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ActionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[action.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ActionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, action.FieldDescription)
}

// AddEntitlementIDs adds the "entitlements" edge to the Entitlement entity by ids.
func (m *ActionMutation) AddEntitlementIDs(ids ...string) {
	if m.entitlements == nil {
		m.entitlements = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlements[ids[i]] = struct{}{}
	}
}

// ClearEntitlements clears the "entitlements" edge to the Entitlement entity.
func (m *ActionMutation) ClearEntitlements() {
	m.clearedentitlements = true
}

// EntitlementsCleared reports if the "entitlements" edge to the Entitlement entity was cleared.
func (m *ActionMutation) EntitlementsCleared() bool {
	return m.clearedentitlements
}

// RemoveEntitlementIDs removes the "entitlements" edge to the Entitlement entity by IDs.
func (m *ActionMutation) RemoveEntitlementIDs(ids ...string) {
	if m.removedentitlements == nil {
		m.removedentitlements = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlements, ids[i])
		m.removedentitlements[ids[i]] = struct{}{}
	}
}

// RemovedEntitlements returns the removed IDs of the "entitlements" edge to the Entitlement entity.
func (m *ActionMutation) RemovedEntitlementsIDs() (ids []string) {
	for id := range m.removedentitlements {
		ids = append(ids, id)
	}
	return
}

// EntitlementsIDs returns the "entitlements" edge IDs in the mutation.
func (m *ActionMutation) EntitlementsIDs() (ids []string) {
	for id := range m.entitlements {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlements resets all changes to the "entitlements" edge.
func (m *ActionMutation) ResetEntitlements() {
	m.entitlements = nil
	m.clearedentitlements = false
	m.removedentitlements = nil
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *ActionMutation) ClearResource() {
	m.clearedresource = true
	m.clearedFields[action.FieldResourceID] = struct{}{}
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *ActionMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *ActionMutation) ResourceIDs() (ids []string) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *ActionMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the ActionMutation builder.
func (m *ActionMutation) Where(ps ...predicate.Action) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Action, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Action).
func (m *ActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, action.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, action.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, action.FieldName)
	}
	if m.etag != nil {
		fields = append(fields, action.FieldEtag)
	}
	if m.resource != nil {
		fields = append(fields, action.FieldResourceID)
	}
	if m.description != nil {
		fields = append(fields, action.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case action.FieldCreatedAt:
		return m.CreatedAt()
	case action.FieldCreatedBy:
		return m.CreatedBy()
	case action.FieldName:
		return m.Name()
	case action.FieldEtag:
		return m.Etag()
	case action.FieldResourceID:
		return m.ResourceID()
	case action.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case action.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case action.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case action.FieldName:
		return m.OldName(ctx)
	case action.FieldEtag:
		return m.OldEtag(ctx)
	case action.FieldResourceID:
		return m.OldResourceID(ctx)
	case action.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Action field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case action.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case action.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case action.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case action.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case action.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case action.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Action field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Action numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(action.FieldDescription) {
		fields = append(fields, action.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionMutation) ClearField(name string) error {
	switch name {
	case action.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Action nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionMutation) ResetField(name string) error {
	switch name {
	case action.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case action.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case action.FieldName:
		m.ResetName()
		return nil
	case action.FieldEtag:
		m.ResetEtag()
		return nil
	case action.FieldResourceID:
		m.ResetResourceID()
		return nil
	case action.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Action field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.entitlements != nil {
		edges = append(edges, action.EdgeEntitlements)
	}
	if m.resource != nil {
		edges = append(edges, action.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case action.EdgeEntitlements:
		ids := make([]ent.Value, 0, len(m.entitlements))
		for id := range m.entitlements {
			ids = append(ids, id)
		}
		return ids
	case action.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedentitlements != nil {
		edges = append(edges, action.EdgeEntitlements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case action.EdgeEntitlements:
		ids := make([]ent.Value, 0, len(m.removedentitlements))
		for id := range m.removedentitlements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedentitlements {
		edges = append(edges, action.EdgeEntitlements)
	}
	if m.clearedresource {
		edges = append(edges, action.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionMutation) EdgeCleared(name string) bool {
	switch name {
	case action.EdgeEntitlements:
		return m.clearedentitlements
	case action.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionMutation) ClearEdge(name string) error {
	switch name {
	case action.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown Action unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionMutation) ResetEdge(name string) error {
	switch name {
	case action.EdgeEntitlements:
		m.ResetEntitlements()
		return nil
	case action.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown Action edge %s", name)
}

// EntitlementMutation represents an operation that mutates the Entitlement nodes in the graph.
type EntitlementMutation struct {
	config
	op                             Op
	typ                            string
	id                             *string
	action_expr                    *string
	created_at                     *time.Time
	created_by                     *string
	name                           *string
	description                    *string
	etag                           *string
	scope_ref                      *string
	clearedFields                  map[string]struct{}
	permission_histories           map[string]struct{}
	removedpermission_histories    map[string]struct{}
	clearedpermission_histories    bool
	entitlement_assignments        map[string]struct{}
	removedentitlement_assignments map[string]struct{}
	clearedentitlement_assignments bool
	action                         *string
	clearedaction                  bool
	resource                       *string
	clearedresource                bool
	done                           bool
	oldValue                       func(context.Context) (*Entitlement, error)
	predicates                     []predicate.Entitlement
}

var _ ent.Mutation = (*EntitlementMutation)(nil)

// entitlementOption allows management of the mutation configuration using functional options.
type entitlementOption func(*EntitlementMutation)

// newEntitlementMutation creates new mutation for the Entitlement entity.
func newEntitlementMutation(c config, op Op, opts ...entitlementOption) *EntitlementMutation {
	m := &EntitlementMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementID sets the ID field of the mutation.
func withEntitlementID(id string) entitlementOption {
	return func(m *EntitlementMutation) {
		var (
			err   error
			once  sync.Once
			value *Entitlement
		)
		m.oldValue = func(ctx context.Context) (*Entitlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entitlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlement sets the old Entitlement of the mutation.
func withEntitlement(node *Entitlement) entitlementOption {
	return func(m *EntitlementMutation) {
		m.oldValue = func(context.Context) (*Entitlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entitlement entities.
func (m *EntitlementMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entitlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActionID sets the "action_id" field.
func (m *EntitlementMutation) SetActionID(s string) {
	m.action = &s
}

// ActionID returns the value of the "action_id" field in the mutation.
func (m *EntitlementMutation) ActionID() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldActionID returns the old "action_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldActionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionID: %w", err)
	}
	return oldValue.ActionID, nil
}

// ClearActionID clears the value of the "action_id" field.
func (m *EntitlementMutation) ClearActionID() {
	m.action = nil
	m.clearedFields[entitlement.FieldActionID] = struct{}{}
}

// ActionIDCleared returns if the "action_id" field was cleared in this mutation.
func (m *EntitlementMutation) ActionIDCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldActionID]
	return ok
}

// ResetActionID resets all changes to the "action_id" field.
func (m *EntitlementMutation) ResetActionID() {
	m.action = nil
	delete(m.clearedFields, entitlement.FieldActionID)
}

// SetActionExpr sets the "action_expr" field.
func (m *EntitlementMutation) SetActionExpr(s string) {
	m.action_expr = &s
}

// ActionExpr returns the value of the "action_expr" field in the mutation.
func (m *EntitlementMutation) ActionExpr() (r string, exists bool) {
	v := m.action_expr
	if v == nil {
		return
	}
	return *v, true
}

// OldActionExpr returns the old "action_expr" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldActionExpr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionExpr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionExpr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionExpr: %w", err)
	}
	return oldValue.ActionExpr, nil
}

// ResetActionExpr resets all changes to the "action_expr" field.
func (m *EntitlementMutation) ResetActionExpr() {
	m.action_expr = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EntitlementMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntitlementMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntitlementMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetName sets the "name" field.
func (m *EntitlementMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntitlementMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntitlementMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EntitlementMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EntitlementMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EntitlementMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[entitlement.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EntitlementMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EntitlementMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, entitlement.FieldDescription)
}

// SetEtag sets the "etag" field.
func (m *EntitlementMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *EntitlementMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *EntitlementMutation) ResetEtag() {
	m.etag = nil
}

// SetResourceID sets the "resource_id" field.
func (m *EntitlementMutation) SetResourceID(s string) {
	m.resource = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *EntitlementMutation) ResourceID() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldResourceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *EntitlementMutation) ClearResourceID() {
	m.resource = nil
	m.clearedFields[entitlement.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *EntitlementMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *EntitlementMutation) ResetResourceID() {
	m.resource = nil
	delete(m.clearedFields, entitlement.FieldResourceID)
}

// SetScopeRef sets the "scope_ref" field.
func (m *EntitlementMutation) SetScopeRef(s string) {
	m.scope_ref = &s
}

// ScopeRef returns the value of the "scope_ref" field in the mutation.
func (m *EntitlementMutation) ScopeRef() (r string, exists bool) {
	v := m.scope_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeRef returns the old "scope_ref" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldScopeRef(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeRef: %w", err)
	}
	return oldValue.ScopeRef, nil
}

// ClearScopeRef clears the value of the "scope_ref" field.
func (m *EntitlementMutation) ClearScopeRef() {
	m.scope_ref = nil
	m.clearedFields[entitlement.FieldScopeRef] = struct{}{}
}

// ScopeRefCleared returns if the "scope_ref" field was cleared in this mutation.
func (m *EntitlementMutation) ScopeRefCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldScopeRef]
	return ok
}

// ResetScopeRef resets all changes to the "scope_ref" field.
func (m *EntitlementMutation) ResetScopeRef() {
	m.scope_ref = nil
	delete(m.clearedFields, entitlement.FieldScopeRef)
}

// AddPermissionHistoryIDs adds the "permission_histories" edge to the PermissionHistory entity by ids.
func (m *EntitlementMutation) AddPermissionHistoryIDs(ids ...string) {
	if m.permission_histories == nil {
		m.permission_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.permission_histories[ids[i]] = struct{}{}
	}
}

// ClearPermissionHistories clears the "permission_histories" edge to the PermissionHistory entity.
func (m *EntitlementMutation) ClearPermissionHistories() {
	m.clearedpermission_histories = true
}

// PermissionHistoriesCleared reports if the "permission_histories" edge to the PermissionHistory entity was cleared.
func (m *EntitlementMutation) PermissionHistoriesCleared() bool {
	return m.clearedpermission_histories
}

// RemovePermissionHistoryIDs removes the "permission_histories" edge to the PermissionHistory entity by IDs.
func (m *EntitlementMutation) RemovePermissionHistoryIDs(ids ...string) {
	if m.removedpermission_histories == nil {
		m.removedpermission_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.permission_histories, ids[i])
		m.removedpermission_histories[ids[i]] = struct{}{}
	}
}

// RemovedPermissionHistories returns the removed IDs of the "permission_histories" edge to the PermissionHistory entity.
func (m *EntitlementMutation) RemovedPermissionHistoriesIDs() (ids []string) {
	for id := range m.removedpermission_histories {
		ids = append(ids, id)
	}
	return
}

// PermissionHistoriesIDs returns the "permission_histories" edge IDs in the mutation.
func (m *EntitlementMutation) PermissionHistoriesIDs() (ids []string) {
	for id := range m.permission_histories {
		ids = append(ids, id)
	}
	return
}

// ResetPermissionHistories resets all changes to the "permission_histories" edge.
func (m *EntitlementMutation) ResetPermissionHistories() {
	m.permission_histories = nil
	m.clearedpermission_histories = false
	m.removedpermission_histories = nil
}

// AddEntitlementAssignmentIDs adds the "entitlement_assignments" edge to the EntitlementAssignment entity by ids.
func (m *EntitlementMutation) AddEntitlementAssignmentIDs(ids ...string) {
	if m.entitlement_assignments == nil {
		m.entitlement_assignments = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlement_assignments[ids[i]] = struct{}{}
	}
}

// ClearEntitlementAssignments clears the "entitlement_assignments" edge to the EntitlementAssignment entity.
func (m *EntitlementMutation) ClearEntitlementAssignments() {
	m.clearedentitlement_assignments = true
}

// EntitlementAssignmentsCleared reports if the "entitlement_assignments" edge to the EntitlementAssignment entity was cleared.
func (m *EntitlementMutation) EntitlementAssignmentsCleared() bool {
	return m.clearedentitlement_assignments
}

// RemoveEntitlementAssignmentIDs removes the "entitlement_assignments" edge to the EntitlementAssignment entity by IDs.
func (m *EntitlementMutation) RemoveEntitlementAssignmentIDs(ids ...string) {
	if m.removedentitlement_assignments == nil {
		m.removedentitlement_assignments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlement_assignments, ids[i])
		m.removedentitlement_assignments[ids[i]] = struct{}{}
	}
}

// RemovedEntitlementAssignments returns the removed IDs of the "entitlement_assignments" edge to the EntitlementAssignment entity.
func (m *EntitlementMutation) RemovedEntitlementAssignmentsIDs() (ids []string) {
	for id := range m.removedentitlement_assignments {
		ids = append(ids, id)
	}
	return
}

// EntitlementAssignmentsIDs returns the "entitlement_assignments" edge IDs in the mutation.
func (m *EntitlementMutation) EntitlementAssignmentsIDs() (ids []string) {
	for id := range m.entitlement_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlementAssignments resets all changes to the "entitlement_assignments" edge.
func (m *EntitlementMutation) ResetEntitlementAssignments() {
	m.entitlement_assignments = nil
	m.clearedentitlement_assignments = false
	m.removedentitlement_assignments = nil
}

// ClearAction clears the "action" edge to the Action entity.
func (m *EntitlementMutation) ClearAction() {
	m.clearedaction = true
	m.clearedFields[entitlement.FieldActionID] = struct{}{}
}

// ActionCleared reports if the "action" edge to the Action entity was cleared.
func (m *EntitlementMutation) ActionCleared() bool {
	return m.ActionIDCleared() || m.clearedaction
}

// ActionIDs returns the "action" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActionID instead. It exists only for internal usage by the builders.
func (m *EntitlementMutation) ActionIDs() (ids []string) {
	if id := m.action; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAction resets all changes to the "action" edge.
func (m *EntitlementMutation) ResetAction() {
	m.action = nil
	m.clearedaction = false
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *EntitlementMutation) ClearResource() {
	m.clearedresource = true
	m.clearedFields[entitlement.FieldResourceID] = struct{}{}
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *EntitlementMutation) ResourceCleared() bool {
	return m.ResourceIDCleared() || m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *EntitlementMutation) ResourceIDs() (ids []string) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *EntitlementMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the EntitlementMutation builder.
func (m *EntitlementMutation) Where(ps ...predicate.Entitlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entitlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entitlement).
func (m *EntitlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.action != nil {
		fields = append(fields, entitlement.FieldActionID)
	}
	if m.action_expr != nil {
		fields = append(fields, entitlement.FieldActionExpr)
	}
	if m.created_at != nil {
		fields = append(fields, entitlement.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entitlement.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, entitlement.FieldName)
	}
	if m.description != nil {
		fields = append(fields, entitlement.FieldDescription)
	}
	if m.etag != nil {
		fields = append(fields, entitlement.FieldEtag)
	}
	if m.resource != nil {
		fields = append(fields, entitlement.FieldResourceID)
	}
	if m.scope_ref != nil {
		fields = append(fields, entitlement.FieldScopeRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlement.FieldActionID:
		return m.ActionID()
	case entitlement.FieldActionExpr:
		return m.ActionExpr()
	case entitlement.FieldCreatedAt:
		return m.CreatedAt()
	case entitlement.FieldCreatedBy:
		return m.CreatedBy()
	case entitlement.FieldName:
		return m.Name()
	case entitlement.FieldDescription:
		return m.Description()
	case entitlement.FieldEtag:
		return m.Etag()
	case entitlement.FieldResourceID:
		return m.ResourceID()
	case entitlement.FieldScopeRef:
		return m.ScopeRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlement.FieldActionID:
		return m.OldActionID(ctx)
	case entitlement.FieldActionExpr:
		return m.OldActionExpr(ctx)
	case entitlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlement.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entitlement.FieldName:
		return m.OldName(ctx)
	case entitlement.FieldDescription:
		return m.OldDescription(ctx)
	case entitlement.FieldEtag:
		return m.OldEtag(ctx)
	case entitlement.FieldResourceID:
		return m.OldResourceID(ctx)
	case entitlement.FieldScopeRef:
		return m.OldScopeRef(ctx)
	}
	return nil, fmt.Errorf("unknown Entitlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlement.FieldActionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionID(v)
		return nil
	case entitlement.FieldActionExpr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionExpr(v)
		return nil
	case entitlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlement.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entitlement.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entitlement.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case entitlement.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case entitlement.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case entitlement.FieldScopeRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeRef(v)
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Entitlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlement.FieldActionID) {
		fields = append(fields, entitlement.FieldActionID)
	}
	if m.FieldCleared(entitlement.FieldDescription) {
		fields = append(fields, entitlement.FieldDescription)
	}
	if m.FieldCleared(entitlement.FieldResourceID) {
		fields = append(fields, entitlement.FieldResourceID)
	}
	if m.FieldCleared(entitlement.FieldScopeRef) {
		fields = append(fields, entitlement.FieldScopeRef)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementMutation) ClearField(name string) error {
	switch name {
	case entitlement.FieldActionID:
		m.ClearActionID()
		return nil
	case entitlement.FieldDescription:
		m.ClearDescription()
		return nil
	case entitlement.FieldResourceID:
		m.ClearResourceID()
		return nil
	case entitlement.FieldScopeRef:
		m.ClearScopeRef()
		return nil
	}
	return fmt.Errorf("unknown Entitlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementMutation) ResetField(name string) error {
	switch name {
	case entitlement.FieldActionID:
		m.ResetActionID()
		return nil
	case entitlement.FieldActionExpr:
		m.ResetActionExpr()
		return nil
	case entitlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlement.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entitlement.FieldName:
		m.ResetName()
		return nil
	case entitlement.FieldDescription:
		m.ResetDescription()
		return nil
	case entitlement.FieldEtag:
		m.ResetEtag()
		return nil
	case entitlement.FieldResourceID:
		m.ResetResourceID()
		return nil
	case entitlement.FieldScopeRef:
		m.ResetScopeRef()
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.permission_histories != nil {
		edges = append(edges, entitlement.EdgePermissionHistories)
	}
	if m.entitlement_assignments != nil {
		edges = append(edges, entitlement.EdgeEntitlementAssignments)
	}
	if m.action != nil {
		edges = append(edges, entitlement.EdgeAction)
	}
	if m.resource != nil {
		edges = append(edges, entitlement.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.permission_histories))
		for id := range m.permission_histories {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeEntitlementAssignments:
		ids := make([]ent.Value, 0, len(m.entitlement_assignments))
		for id := range m.entitlement_assignments {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeAction:
		if id := m.action; id != nil {
			return []ent.Value{*id}
		}
	case entitlement.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpermission_histories != nil {
		edges = append(edges, entitlement.EdgePermissionHistories)
	}
	if m.removedentitlement_assignments != nil {
		edges = append(edges, entitlement.EdgeEntitlementAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.removedpermission_histories))
		for id := range m.removedpermission_histories {
			ids = append(ids, id)
		}
		return ids
	case entitlement.EdgeEntitlementAssignments:
		ids := make([]ent.Value, 0, len(m.removedentitlement_assignments))
		for id := range m.removedentitlement_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpermission_histories {
		edges = append(edges, entitlement.EdgePermissionHistories)
	}
	if m.clearedentitlement_assignments {
		edges = append(edges, entitlement.EdgeEntitlementAssignments)
	}
	if m.clearedaction {
		edges = append(edges, entitlement.EdgeAction)
	}
	if m.clearedresource {
		edges = append(edges, entitlement.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementMutation) EdgeCleared(name string) bool {
	switch name {
	case entitlement.EdgePermissionHistories:
		return m.clearedpermission_histories
	case entitlement.EdgeEntitlementAssignments:
		return m.clearedentitlement_assignments
	case entitlement.EdgeAction:
		return m.clearedaction
	case entitlement.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementMutation) ClearEdge(name string) error {
	switch name {
	case entitlement.EdgeAction:
		m.ClearAction()
		return nil
	case entitlement.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown Entitlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementMutation) ResetEdge(name string) error {
	switch name {
	case entitlement.EdgePermissionHistories:
		m.ResetPermissionHistories()
		return nil
	case entitlement.EdgeEntitlementAssignments:
		m.ResetEntitlementAssignments()
		return nil
	case entitlement.EdgeAction:
		m.ResetAction()
		return nil
	case entitlement.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown Entitlement edge %s", name)
}

// EntitlementAssignmentMutation represents an operation that mutates the EntitlementAssignment nodes in the graph.
type EntitlementAssignmentMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	subject_type                *entitlementassignment.SubjectType
	subject_ref                 *string
	resolved_expr               *string
	action_name                 *string
	resource_name               *string
	clearedFields               map[string]struct{}
	entitlement                 *string
	clearedentitlement          bool
	permission_histories        map[string]struct{}
	removedpermission_histories map[string]struct{}
	clearedpermission_histories bool
	done                        bool
	oldValue                    func(context.Context) (*EntitlementAssignment, error)
	predicates                  []predicate.EntitlementAssignment
}

var _ ent.Mutation = (*EntitlementAssignmentMutation)(nil)

// entitlementassignmentOption allows management of the mutation configuration using functional options.
type entitlementassignmentOption func(*EntitlementAssignmentMutation)

// newEntitlementAssignmentMutation creates new mutation for the EntitlementAssignment entity.
func newEntitlementAssignmentMutation(c config, op Op, opts ...entitlementassignmentOption) *EntitlementAssignmentMutation {
	m := &EntitlementAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlementAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementAssignmentID sets the ID field of the mutation.
func withEntitlementAssignmentID(id string) entitlementassignmentOption {
	return func(m *EntitlementAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *EntitlementAssignment
		)
		m.oldValue = func(ctx context.Context) (*EntitlementAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntitlementAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlementAssignment sets the old EntitlementAssignment of the mutation.
func withEntitlementAssignment(node *EntitlementAssignment) entitlementassignmentOption {
	return func(m *EntitlementAssignmentMutation) {
		m.oldValue = func(context.Context) (*EntitlementAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntitlementAssignment entities.
func (m *EntitlementAssignmentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementAssignmentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementAssignmentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntitlementAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntitlementID sets the "entitlement_id" field.
func (m *EntitlementAssignmentMutation) SetEntitlementID(s string) {
	m.entitlement = &s
}

// EntitlementID returns the value of the "entitlement_id" field in the mutation.
func (m *EntitlementAssignmentMutation) EntitlementID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementID returns the old "entitlement_id" field's value of the EntitlementAssignment entity.
// If the EntitlementAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementAssignmentMutation) OldEntitlementID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementID: %w", err)
	}
	return oldValue.EntitlementID, nil
}

// ResetEntitlementID resets all changes to the "entitlement_id" field.
func (m *EntitlementAssignmentMutation) ResetEntitlementID() {
	m.entitlement = nil
}

// SetSubjectType sets the "subject_type" field.
func (m *EntitlementAssignmentMutation) SetSubjectType(et entitlementassignment.SubjectType) {
	m.subject_type = &et
}

// SubjectType returns the value of the "subject_type" field in the mutation.
func (m *EntitlementAssignmentMutation) SubjectType() (r entitlementassignment.SubjectType, exists bool) {
	v := m.subject_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectType returns the old "subject_type" field's value of the EntitlementAssignment entity.
// If the EntitlementAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementAssignmentMutation) OldSubjectType(ctx context.Context) (v entitlementassignment.SubjectType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectType: %w", err)
	}
	return oldValue.SubjectType, nil
}

// ResetSubjectType resets all changes to the "subject_type" field.
func (m *EntitlementAssignmentMutation) ResetSubjectType() {
	m.subject_type = nil
}

// SetSubjectRef sets the "subject_ref" field.
func (m *EntitlementAssignmentMutation) SetSubjectRef(s string) {
	m.subject_ref = &s
}

// SubjectRef returns the value of the "subject_ref" field in the mutation.
func (m *EntitlementAssignmentMutation) SubjectRef() (r string, exists bool) {
	v := m.subject_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectRef returns the old "subject_ref" field's value of the EntitlementAssignment entity.
// If the EntitlementAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementAssignmentMutation) OldSubjectRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectRef: %w", err)
	}
	return oldValue.SubjectRef, nil
}

// ResetSubjectRef resets all changes to the "subject_ref" field.
func (m *EntitlementAssignmentMutation) ResetSubjectRef() {
	m.subject_ref = nil
}

// SetResolvedExpr sets the "resolved_expr" field.
func (m *EntitlementAssignmentMutation) SetResolvedExpr(s string) {
	m.resolved_expr = &s
}

// ResolvedExpr returns the value of the "resolved_expr" field in the mutation.
func (m *EntitlementAssignmentMutation) ResolvedExpr() (r string, exists bool) {
	v := m.resolved_expr
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedExpr returns the old "resolved_expr" field's value of the EntitlementAssignment entity.
// If the EntitlementAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementAssignmentMutation) OldResolvedExpr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedExpr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedExpr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedExpr: %w", err)
	}
	return oldValue.ResolvedExpr, nil
}

// ResetResolvedExpr resets all changes to the "resolved_expr" field.
func (m *EntitlementAssignmentMutation) ResetResolvedExpr() {
	m.resolved_expr = nil
}

// SetActionName sets the "action_name" field.
func (m *EntitlementAssignmentMutation) SetActionName(s string) {
	m.action_name = &s
}

// ActionName returns the value of the "action_name" field in the mutation.
func (m *EntitlementAssignmentMutation) ActionName() (r string, exists bool) {
	v := m.action_name
	if v == nil {
		return
	}
	return *v, true
}

// OldActionName returns the old "action_name" field's value of the EntitlementAssignment entity.
// If the EntitlementAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementAssignmentMutation) OldActionName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionName: %w", err)
	}
	return oldValue.ActionName, nil
}

// ClearActionName clears the value of the "action_name" field.
func (m *EntitlementAssignmentMutation) ClearActionName() {
	m.action_name = nil
	m.clearedFields[entitlementassignment.FieldActionName] = struct{}{}
}

// ActionNameCleared returns if the "action_name" field was cleared in this mutation.
func (m *EntitlementAssignmentMutation) ActionNameCleared() bool {
	_, ok := m.clearedFields[entitlementassignment.FieldActionName]
	return ok
}

// ResetActionName resets all changes to the "action_name" field.
func (m *EntitlementAssignmentMutation) ResetActionName() {
	m.action_name = nil
	delete(m.clearedFields, entitlementassignment.FieldActionName)
}

// SetResourceName sets the "resource_name" field.
func (m *EntitlementAssignmentMutation) SetResourceName(s string) {
	m.resource_name = &s
}

// ResourceName returns the value of the "resource_name" field in the mutation.
func (m *EntitlementAssignmentMutation) ResourceName() (r string, exists bool) {
	v := m.resource_name
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceName returns the old "resource_name" field's value of the EntitlementAssignment entity.
// If the EntitlementAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementAssignmentMutation) OldResourceName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceName: %w", err)
	}
	return oldValue.ResourceName, nil
}

// ClearResourceName clears the value of the "resource_name" field.
func (m *EntitlementAssignmentMutation) ClearResourceName() {
	m.resource_name = nil
	m.clearedFields[entitlementassignment.FieldResourceName] = struct{}{}
}

// ResourceNameCleared returns if the "resource_name" field was cleared in this mutation.
func (m *EntitlementAssignmentMutation) ResourceNameCleared() bool {
	_, ok := m.clearedFields[entitlementassignment.FieldResourceName]
	return ok
}

// ResetResourceName resets all changes to the "resource_name" field.
func (m *EntitlementAssignmentMutation) ResetResourceName() {
	m.resource_name = nil
	delete(m.clearedFields, entitlementassignment.FieldResourceName)
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *EntitlementAssignmentMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[entitlementassignment.FieldEntitlementID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *EntitlementAssignmentMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *EntitlementAssignmentMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *EntitlementAssignmentMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// AddPermissionHistoryIDs adds the "permission_histories" edge to the PermissionHistory entity by ids.
func (m *EntitlementAssignmentMutation) AddPermissionHistoryIDs(ids ...string) {
	if m.permission_histories == nil {
		m.permission_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.permission_histories[ids[i]] = struct{}{}
	}
}

// ClearPermissionHistories clears the "permission_histories" edge to the PermissionHistory entity.
func (m *EntitlementAssignmentMutation) ClearPermissionHistories() {
	m.clearedpermission_histories = true
}

// PermissionHistoriesCleared reports if the "permission_histories" edge to the PermissionHistory entity was cleared.
func (m *EntitlementAssignmentMutation) PermissionHistoriesCleared() bool {
	return m.clearedpermission_histories
}

// RemovePermissionHistoryIDs removes the "permission_histories" edge to the PermissionHistory entity by IDs.
func (m *EntitlementAssignmentMutation) RemovePermissionHistoryIDs(ids ...string) {
	if m.removedpermission_histories == nil {
		m.removedpermission_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.permission_histories, ids[i])
		m.removedpermission_histories[ids[i]] = struct{}{}
	}
}

// RemovedPermissionHistories returns the removed IDs of the "permission_histories" edge to the PermissionHistory entity.
func (m *EntitlementAssignmentMutation) RemovedPermissionHistoriesIDs() (ids []string) {
	for id := range m.removedpermission_histories {
		ids = append(ids, id)
	}
	return
}

// PermissionHistoriesIDs returns the "permission_histories" edge IDs in the mutation.
func (m *EntitlementAssignmentMutation) PermissionHistoriesIDs() (ids []string) {
	for id := range m.permission_histories {
		ids = append(ids, id)
	}
	return
}

// ResetPermissionHistories resets all changes to the "permission_histories" edge.
func (m *EntitlementAssignmentMutation) ResetPermissionHistories() {
	m.permission_histories = nil
	m.clearedpermission_histories = false
	m.removedpermission_histories = nil
}

// Where appends a list predicates to the EntitlementAssignmentMutation builder.
func (m *EntitlementAssignmentMutation) Where(ps ...predicate.EntitlementAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntitlementAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntitlementAssignment).
func (m *EntitlementAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.entitlement != nil {
		fields = append(fields, entitlementassignment.FieldEntitlementID)
	}
	if m.subject_type != nil {
		fields = append(fields, entitlementassignment.FieldSubjectType)
	}
	if m.subject_ref != nil {
		fields = append(fields, entitlementassignment.FieldSubjectRef)
	}
	if m.resolved_expr != nil {
		fields = append(fields, entitlementassignment.FieldResolvedExpr)
	}
	if m.action_name != nil {
		fields = append(fields, entitlementassignment.FieldActionName)
	}
	if m.resource_name != nil {
		fields = append(fields, entitlementassignment.FieldResourceName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlementassignment.FieldEntitlementID:
		return m.EntitlementID()
	case entitlementassignment.FieldSubjectType:
		return m.SubjectType()
	case entitlementassignment.FieldSubjectRef:
		return m.SubjectRef()
	case entitlementassignment.FieldResolvedExpr:
		return m.ResolvedExpr()
	case entitlementassignment.FieldActionName:
		return m.ActionName()
	case entitlementassignment.FieldResourceName:
		return m.ResourceName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlementassignment.FieldEntitlementID:
		return m.OldEntitlementID(ctx)
	case entitlementassignment.FieldSubjectType:
		return m.OldSubjectType(ctx)
	case entitlementassignment.FieldSubjectRef:
		return m.OldSubjectRef(ctx)
	case entitlementassignment.FieldResolvedExpr:
		return m.OldResolvedExpr(ctx)
	case entitlementassignment.FieldActionName:
		return m.OldActionName(ctx)
	case entitlementassignment.FieldResourceName:
		return m.OldResourceName(ctx)
	}
	return nil, fmt.Errorf("unknown EntitlementAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlementassignment.FieldEntitlementID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementID(v)
		return nil
	case entitlementassignment.FieldSubjectType:
		v, ok := value.(entitlementassignment.SubjectType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectType(v)
		return nil
	case entitlementassignment.FieldSubjectRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectRef(v)
		return nil
	case entitlementassignment.FieldResolvedExpr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedExpr(v)
		return nil
	case entitlementassignment.FieldActionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionName(v)
		return nil
	case entitlementassignment.FieldResourceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceName(v)
		return nil
	}
	return fmt.Errorf("unknown EntitlementAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntitlementAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlementassignment.FieldActionName) {
		fields = append(fields, entitlementassignment.FieldActionName)
	}
	if m.FieldCleared(entitlementassignment.FieldResourceName) {
		fields = append(fields, entitlementassignment.FieldResourceName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementAssignmentMutation) ClearField(name string) error {
	switch name {
	case entitlementassignment.FieldActionName:
		m.ClearActionName()
		return nil
	case entitlementassignment.FieldResourceName:
		m.ClearResourceName()
		return nil
	}
	return fmt.Errorf("unknown EntitlementAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementAssignmentMutation) ResetField(name string) error {
	switch name {
	case entitlementassignment.FieldEntitlementID:
		m.ResetEntitlementID()
		return nil
	case entitlementassignment.FieldSubjectType:
		m.ResetSubjectType()
		return nil
	case entitlementassignment.FieldSubjectRef:
		m.ResetSubjectRef()
		return nil
	case entitlementassignment.FieldResolvedExpr:
		m.ResetResolvedExpr()
		return nil
	case entitlementassignment.FieldActionName:
		m.ResetActionName()
		return nil
	case entitlementassignment.FieldResourceName:
		m.ResetResourceName()
		return nil
	}
	return fmt.Errorf("unknown EntitlementAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.entitlement != nil {
		edges = append(edges, entitlementassignment.EdgeEntitlement)
	}
	if m.permission_histories != nil {
		edges = append(edges, entitlementassignment.EdgePermissionHistories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitlementassignment.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	case entitlementassignment.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.permission_histories))
		for id := range m.permission_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpermission_histories != nil {
		edges = append(edges, entitlementassignment.EdgePermissionHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementAssignmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitlementassignment.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.removedpermission_histories))
		for id := range m.removedpermission_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedentitlement {
		edges = append(edges, entitlementassignment.EdgeEntitlement)
	}
	if m.clearedpermission_histories {
		edges = append(edges, entitlementassignment.EdgePermissionHistories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case entitlementassignment.EdgeEntitlement:
		return m.clearedentitlement
	case entitlementassignment.EdgePermissionHistories:
		return m.clearedpermission_histories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case entitlementassignment.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	}
	return fmt.Errorf("unknown EntitlementAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case entitlementassignment.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	case entitlementassignment.EdgePermissionHistories:
		m.ResetPermissionHistories()
		return nil
	}
	return fmt.Errorf("unknown EntitlementAssignment edge %s", name)
}

// GrantRequestMutation represents an operation that mutates the GrantRequest nodes in the graph.
type GrantRequestMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	attachment_url              *string
	comment                     *string
	created_at                  *time.Time
	created_by                  *string
	etag                        *string
	receiver_id                 *string
	receiver_type               *grantrequest.ReceiverType
	target_type                 *grantrequest.TargetType
	target_role_name            *string
	target_suite_name           *string
	status                      *grantrequest.Status
	clearedFields               map[string]struct{}
	permission_histories        map[string]struct{}
	removedpermission_histories map[string]struct{}
	clearedpermission_histories bool
	role                        *string
	clearedrole                 bool
	role_suite                  *string
	clearedrole_suite           bool
	grant_responses             map[string]struct{}
	removedgrant_responses      map[string]struct{}
	clearedgrant_responses      bool
	done                        bool
	oldValue                    func(context.Context) (*GrantRequest, error)
	predicates                  []predicate.GrantRequest
}

var _ ent.Mutation = (*GrantRequestMutation)(nil)

// grantrequestOption allows management of the mutation configuration using functional options.
type grantrequestOption func(*GrantRequestMutation)

// newGrantRequestMutation creates new mutation for the GrantRequest entity.
func newGrantRequestMutation(c config, op Op, opts ...grantrequestOption) *GrantRequestMutation {
	m := &GrantRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeGrantRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrantRequestID sets the ID field of the mutation.
func withGrantRequestID(id string) grantrequestOption {
	return func(m *GrantRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *GrantRequest
		)
		m.oldValue = func(ctx context.Context) (*GrantRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GrantRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrantRequest sets the old GrantRequest of the mutation.
func withGrantRequest(node *GrantRequest) grantrequestOption {
	return func(m *GrantRequestMutation) {
		m.oldValue = func(context.Context) (*GrantRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrantRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrantRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GrantRequest entities.
func (m *GrantRequestMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GrantRequestMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GrantRequestMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GrantRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAttachmentURL sets the "attachment_url" field.
func (m *GrantRequestMutation) SetAttachmentURL(s string) {
	m.attachment_url = &s
}

// AttachmentURL returns the value of the "attachment_url" field in the mutation.
func (m *GrantRequestMutation) AttachmentURL() (r string, exists bool) {
	v := m.attachment_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentURL returns the old "attachment_url" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldAttachmentURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachmentURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachmentURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentURL: %w", err)
	}
	return oldValue.AttachmentURL, nil
}

// ClearAttachmentURL clears the value of the "attachment_url" field.
func (m *GrantRequestMutation) ClearAttachmentURL() {
	m.attachment_url = nil
	m.clearedFields[grantrequest.FieldAttachmentURL] = struct{}{}
}

// AttachmentURLCleared returns if the "attachment_url" field was cleared in this mutation.
func (m *GrantRequestMutation) AttachmentURLCleared() bool {
	_, ok := m.clearedFields[grantrequest.FieldAttachmentURL]
	return ok
}

// ResetAttachmentURL resets all changes to the "attachment_url" field.
func (m *GrantRequestMutation) ResetAttachmentURL() {
	m.attachment_url = nil
	delete(m.clearedFields, grantrequest.FieldAttachmentURL)
}

// SetComment sets the "comment" field.
func (m *GrantRequestMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *GrantRequestMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *GrantRequestMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[grantrequest.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *GrantRequestMutation) CommentCleared() bool {
	_, ok := m.clearedFields[grantrequest.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *GrantRequestMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, grantrequest.FieldComment)
}

// SetCreatedAt sets the "created_at" field.
func (m *GrantRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GrantRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GrantRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *GrantRequestMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GrantRequestMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GrantRequestMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetEtag sets the "etag" field.
func (m *GrantRequestMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *GrantRequestMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *GrantRequestMutation) ResetEtag() {
	m.etag = nil
}

// SetReceiverID sets the "receiver_id" field.
func (m *GrantRequestMutation) SetReceiverID(s string) {
	m.receiver_id = &s
}

// ReceiverID returns the value of the "receiver_id" field in the mutation.
func (m *GrantRequestMutation) ReceiverID() (r string, exists bool) {
	v := m.receiver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverID returns the old "receiver_id" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldReceiverID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverID: %w", err)
	}
	return oldValue.ReceiverID, nil
}

// ResetReceiverID resets all changes to the "receiver_id" field.
func (m *GrantRequestMutation) ResetReceiverID() {
	m.receiver_id = nil
}

// SetReceiverType sets the "receiver_type" field.
func (m *GrantRequestMutation) SetReceiverType(gt grantrequest.ReceiverType) {
	m.receiver_type = &gt
}

// ReceiverType returns the value of the "receiver_type" field in the mutation.
func (m *GrantRequestMutation) ReceiverType() (r grantrequest.ReceiverType, exists bool) {
	v := m.receiver_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverType returns the old "receiver_type" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldReceiverType(ctx context.Context) (v grantrequest.ReceiverType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverType: %w", err)
	}
	return oldValue.ReceiverType, nil
}

// ResetReceiverType resets all changes to the "receiver_type" field.
func (m *GrantRequestMutation) ResetReceiverType() {
	m.receiver_type = nil
}

// SetTargetType sets the "target_type" field.
func (m *GrantRequestMutation) SetTargetType(gt grantrequest.TargetType) {
	m.target_type = &gt
}

// TargetType returns the value of the "target_type" field in the mutation.
func (m *GrantRequestMutation) TargetType() (r grantrequest.TargetType, exists bool) {
	v := m.target_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetType returns the old "target_type" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldTargetType(ctx context.Context) (v grantrequest.TargetType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetType: %w", err)
	}
	return oldValue.TargetType, nil
}

// ResetTargetType resets all changes to the "target_type" field.
func (m *GrantRequestMutation) ResetTargetType() {
	m.target_type = nil
}

// SetTargetRoleID sets the "target_role_id" field.
func (m *GrantRequestMutation) SetTargetRoleID(s string) {
	m.role = &s
}

// TargetRoleID returns the value of the "target_role_id" field in the mutation.
func (m *GrantRequestMutation) TargetRoleID() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetRoleID returns the old "target_role_id" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldTargetRoleID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetRoleID: %w", err)
	}
	return oldValue.TargetRoleID, nil
}

// ClearTargetRoleID clears the value of the "target_role_id" field.
func (m *GrantRequestMutation) ClearTargetRoleID() {
	m.role = nil
	m.clearedFields[grantrequest.FieldTargetRoleID] = struct{}{}
}

// TargetRoleIDCleared returns if the "target_role_id" field was cleared in this mutation.
func (m *GrantRequestMutation) TargetRoleIDCleared() bool {
	_, ok := m.clearedFields[grantrequest.FieldTargetRoleID]
	return ok
}

// ResetTargetRoleID resets all changes to the "target_role_id" field.
func (m *GrantRequestMutation) ResetTargetRoleID() {
	m.role = nil
	delete(m.clearedFields, grantrequest.FieldTargetRoleID)
}

// SetTargetRoleName sets the "target_role_name" field.
func (m *GrantRequestMutation) SetTargetRoleName(s string) {
	m.target_role_name = &s
}

// TargetRoleName returns the value of the "target_role_name" field in the mutation.
func (m *GrantRequestMutation) TargetRoleName() (r string, exists bool) {
	v := m.target_role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetRoleName returns the old "target_role_name" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldTargetRoleName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetRoleName: %w", err)
	}
	return oldValue.TargetRoleName, nil
}

// ClearTargetRoleName clears the value of the "target_role_name" field.
func (m *GrantRequestMutation) ClearTargetRoleName() {
	m.target_role_name = nil
	m.clearedFields[grantrequest.FieldTargetRoleName] = struct{}{}
}

// TargetRoleNameCleared returns if the "target_role_name" field was cleared in this mutation.
func (m *GrantRequestMutation) TargetRoleNameCleared() bool {
	_, ok := m.clearedFields[grantrequest.FieldTargetRoleName]
	return ok
}

// ResetTargetRoleName resets all changes to the "target_role_name" field.
func (m *GrantRequestMutation) ResetTargetRoleName() {
	m.target_role_name = nil
	delete(m.clearedFields, grantrequest.FieldTargetRoleName)
}

// SetTargetSuiteID sets the "target_suite_id" field.
func (m *GrantRequestMutation) SetTargetSuiteID(s string) {
	m.role_suite = &s
}

// TargetSuiteID returns the value of the "target_suite_id" field in the mutation.
func (m *GrantRequestMutation) TargetSuiteID() (r string, exists bool) {
	v := m.role_suite
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetSuiteID returns the old "target_suite_id" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldTargetSuiteID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetSuiteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetSuiteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetSuiteID: %w", err)
	}
	return oldValue.TargetSuiteID, nil
}

// ClearTargetSuiteID clears the value of the "target_suite_id" field.
func (m *GrantRequestMutation) ClearTargetSuiteID() {
	m.role_suite = nil
	m.clearedFields[grantrequest.FieldTargetSuiteID] = struct{}{}
}

// TargetSuiteIDCleared returns if the "target_suite_id" field was cleared in this mutation.
func (m *GrantRequestMutation) TargetSuiteIDCleared() bool {
	_, ok := m.clearedFields[grantrequest.FieldTargetSuiteID]
	return ok
}

// ResetTargetSuiteID resets all changes to the "target_suite_id" field.
func (m *GrantRequestMutation) ResetTargetSuiteID() {
	m.role_suite = nil
	delete(m.clearedFields, grantrequest.FieldTargetSuiteID)
}

// SetTargetSuiteName sets the "target_suite_name" field.
func (m *GrantRequestMutation) SetTargetSuiteName(s string) {
	m.target_suite_name = &s
}

// TargetSuiteName returns the value of the "target_suite_name" field in the mutation.
func (m *GrantRequestMutation) TargetSuiteName() (r string, exists bool) {
	v := m.target_suite_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetSuiteName returns the old "target_suite_name" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldTargetSuiteName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetSuiteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetSuiteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetSuiteName: %w", err)
	}
	return oldValue.TargetSuiteName, nil
}

// ClearTargetSuiteName clears the value of the "target_suite_name" field.
func (m *GrantRequestMutation) ClearTargetSuiteName() {
	m.target_suite_name = nil
	m.clearedFields[grantrequest.FieldTargetSuiteName] = struct{}{}
}

// TargetSuiteNameCleared returns if the "target_suite_name" field was cleared in this mutation.
func (m *GrantRequestMutation) TargetSuiteNameCleared() bool {
	_, ok := m.clearedFields[grantrequest.FieldTargetSuiteName]
	return ok
}

// ResetTargetSuiteName resets all changes to the "target_suite_name" field.
func (m *GrantRequestMutation) ResetTargetSuiteName() {
	m.target_suite_name = nil
	delete(m.clearedFields, grantrequest.FieldTargetSuiteName)
}

// SetStatus sets the "status" field.
func (m *GrantRequestMutation) SetStatus(gr grantrequest.Status) {
	m.status = &gr
}

// Status returns the value of the "status" field in the mutation.
func (m *GrantRequestMutation) Status() (r grantrequest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GrantRequest entity.
// If the GrantRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantRequestMutation) OldStatus(ctx context.Context) (v grantrequest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GrantRequestMutation) ResetStatus() {
	m.status = nil
}

// AddPermissionHistoryIDs adds the "permission_histories" edge to the PermissionHistory entity by ids.
func (m *GrantRequestMutation) AddPermissionHistoryIDs(ids ...string) {
	if m.permission_histories == nil {
		m.permission_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.permission_histories[ids[i]] = struct{}{}
	}
}

// ClearPermissionHistories clears the "permission_histories" edge to the PermissionHistory entity.
func (m *GrantRequestMutation) ClearPermissionHistories() {
	m.clearedpermission_histories = true
}

// PermissionHistoriesCleared reports if the "permission_histories" edge to the PermissionHistory entity was cleared.
func (m *GrantRequestMutation) PermissionHistoriesCleared() bool {
	return m.clearedpermission_histories
}

// RemovePermissionHistoryIDs removes the "permission_histories" edge to the PermissionHistory entity by IDs.
func (m *GrantRequestMutation) RemovePermissionHistoryIDs(ids ...string) {
	if m.removedpermission_histories == nil {
		m.removedpermission_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.permission_histories, ids[i])
		m.removedpermission_histories[ids[i]] = struct{}{}
	}
}

// RemovedPermissionHistories returns the removed IDs of the "permission_histories" edge to the PermissionHistory entity.
func (m *GrantRequestMutation) RemovedPermissionHistoriesIDs() (ids []string) {
	for id := range m.removedpermission_histories {
		ids = append(ids, id)
	}
	return
}

// PermissionHistoriesIDs returns the "permission_histories" edge IDs in the mutation.
func (m *GrantRequestMutation) PermissionHistoriesIDs() (ids []string) {
	for id := range m.permission_histories {
		ids = append(ids, id)
	}
	return
}

// ResetPermissionHistories resets all changes to the "permission_histories" edge.
func (m *GrantRequestMutation) ResetPermissionHistories() {
	m.permission_histories = nil
	m.clearedpermission_histories = false
	m.removedpermission_histories = nil
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *GrantRequestMutation) SetRoleID(id string) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *GrantRequestMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[grantrequest.FieldTargetRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *GrantRequestMutation) RoleCleared() bool {
	return m.TargetRoleIDCleared() || m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *GrantRequestMutation) RoleID() (id string, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *GrantRequestMutation) RoleIDs() (ids []string) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *GrantRequestMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetRoleSuiteID sets the "role_suite" edge to the RoleSuite entity by id.
func (m *GrantRequestMutation) SetRoleSuiteID(id string) {
	m.role_suite = &id
}

// ClearRoleSuite clears the "role_suite" edge to the RoleSuite entity.
func (m *GrantRequestMutation) ClearRoleSuite() {
	m.clearedrole_suite = true
	m.clearedFields[grantrequest.FieldTargetSuiteID] = struct{}{}
}

// RoleSuiteCleared reports if the "role_suite" edge to the RoleSuite entity was cleared.
func (m *GrantRequestMutation) RoleSuiteCleared() bool {
	return m.TargetSuiteIDCleared() || m.clearedrole_suite
}

// RoleSuiteID returns the "role_suite" edge ID in the mutation.
func (m *GrantRequestMutation) RoleSuiteID() (id string, exists bool) {
	if m.role_suite != nil {
		return *m.role_suite, true
	}
	return
}

// RoleSuiteIDs returns the "role_suite" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleSuiteID instead. It exists only for internal usage by the builders.
func (m *GrantRequestMutation) RoleSuiteIDs() (ids []string) {
	if id := m.role_suite; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleSuite resets all changes to the "role_suite" edge.
func (m *GrantRequestMutation) ResetRoleSuite() {
	m.role_suite = nil
	m.clearedrole_suite = false
}

// AddGrantResponseIDs adds the "grant_responses" edge to the GrantResponse entity by ids.
func (m *GrantRequestMutation) AddGrantResponseIDs(ids ...string) {
	if m.grant_responses == nil {
		m.grant_responses = make(map[string]struct{})
	}
	for i := range ids {
		m.grant_responses[ids[i]] = struct{}{}
	}
}

// ClearGrantResponses clears the "grant_responses" edge to the GrantResponse entity.
func (m *GrantRequestMutation) ClearGrantResponses() {
	m.clearedgrant_responses = true
}

// GrantResponsesCleared reports if the "grant_responses" edge to the GrantResponse entity was cleared.
func (m *GrantRequestMutation) GrantResponsesCleared() bool {
	return m.clearedgrant_responses
}

// RemoveGrantResponseIDs removes the "grant_responses" edge to the GrantResponse entity by IDs.
func (m *GrantRequestMutation) RemoveGrantResponseIDs(ids ...string) {
	if m.removedgrant_responses == nil {
		m.removedgrant_responses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.grant_responses, ids[i])
		m.removedgrant_responses[ids[i]] = struct{}{}
	}
}

// RemovedGrantResponses returns the removed IDs of the "grant_responses" edge to the GrantResponse entity.
func (m *GrantRequestMutation) RemovedGrantResponsesIDs() (ids []string) {
	for id := range m.removedgrant_responses {
		ids = append(ids, id)
	}
	return
}

// GrantResponsesIDs returns the "grant_responses" edge IDs in the mutation.
func (m *GrantRequestMutation) GrantResponsesIDs() (ids []string) {
	for id := range m.grant_responses {
		ids = append(ids, id)
	}
	return
}

// ResetGrantResponses resets all changes to the "grant_responses" edge.
func (m *GrantRequestMutation) ResetGrantResponses() {
	m.grant_responses = nil
	m.clearedgrant_responses = false
	m.removedgrant_responses = nil
}

// Where appends a list predicates to the GrantRequestMutation builder.
func (m *GrantRequestMutation) Where(ps ...predicate.GrantRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GrantRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GrantRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GrantRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GrantRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GrantRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GrantRequest).
func (m *GrantRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GrantRequestMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.attachment_url != nil {
		fields = append(fields, grantrequest.FieldAttachmentURL)
	}
	if m.comment != nil {
		fields = append(fields, grantrequest.FieldComment)
	}
	if m.created_at != nil {
		fields = append(fields, grantrequest.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, grantrequest.FieldCreatedBy)
	}
	if m.etag != nil {
		fields = append(fields, grantrequest.FieldEtag)
	}
	if m.receiver_id != nil {
		fields = append(fields, grantrequest.FieldReceiverID)
	}
	if m.receiver_type != nil {
		fields = append(fields, grantrequest.FieldReceiverType)
	}
	if m.target_type != nil {
		fields = append(fields, grantrequest.FieldTargetType)
	}
	if m.role != nil {
		fields = append(fields, grantrequest.FieldTargetRoleID)
	}
	if m.target_role_name != nil {
		fields = append(fields, grantrequest.FieldTargetRoleName)
	}
	if m.role_suite != nil {
		fields = append(fields, grantrequest.FieldTargetSuiteID)
	}
	if m.target_suite_name != nil {
		fields = append(fields, grantrequest.FieldTargetSuiteName)
	}
	if m.status != nil {
		fields = append(fields, grantrequest.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GrantRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grantrequest.FieldAttachmentURL:
		return m.AttachmentURL()
	case grantrequest.FieldComment:
		return m.Comment()
	case grantrequest.FieldCreatedAt:
		return m.CreatedAt()
	case grantrequest.FieldCreatedBy:
		return m.CreatedBy()
	case grantrequest.FieldEtag:
		return m.Etag()
	case grantrequest.FieldReceiverID:
		return m.ReceiverID()
	case grantrequest.FieldReceiverType:
		return m.ReceiverType()
	case grantrequest.FieldTargetType:
		return m.TargetType()
	case grantrequest.FieldTargetRoleID:
		return m.TargetRoleID()
	case grantrequest.FieldTargetRoleName:
		return m.TargetRoleName()
	case grantrequest.FieldTargetSuiteID:
		return m.TargetSuiteID()
	case grantrequest.FieldTargetSuiteName:
		return m.TargetSuiteName()
	case grantrequest.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GrantRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grantrequest.FieldAttachmentURL:
		return m.OldAttachmentURL(ctx)
	case grantrequest.FieldComment:
		return m.OldComment(ctx)
	case grantrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case grantrequest.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case grantrequest.FieldEtag:
		return m.OldEtag(ctx)
	case grantrequest.FieldReceiverID:
		return m.OldReceiverID(ctx)
	case grantrequest.FieldReceiverType:
		return m.OldReceiverType(ctx)
	case grantrequest.FieldTargetType:
		return m.OldTargetType(ctx)
	case grantrequest.FieldTargetRoleID:
		return m.OldTargetRoleID(ctx)
	case grantrequest.FieldTargetRoleName:
		return m.OldTargetRoleName(ctx)
	case grantrequest.FieldTargetSuiteID:
		return m.OldTargetSuiteID(ctx)
	case grantrequest.FieldTargetSuiteName:
		return m.OldTargetSuiteName(ctx)
	case grantrequest.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown GrantRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grantrequest.FieldAttachmentURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentURL(v)
		return nil
	case grantrequest.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case grantrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case grantrequest.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case grantrequest.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case grantrequest.FieldReceiverID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverID(v)
		return nil
	case grantrequest.FieldReceiverType:
		v, ok := value.(grantrequest.ReceiverType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverType(v)
		return nil
	case grantrequest.FieldTargetType:
		v, ok := value.(grantrequest.TargetType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetType(v)
		return nil
	case grantrequest.FieldTargetRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetRoleID(v)
		return nil
	case grantrequest.FieldTargetRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetRoleName(v)
		return nil
	case grantrequest.FieldTargetSuiteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetSuiteID(v)
		return nil
	case grantrequest.FieldTargetSuiteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetSuiteName(v)
		return nil
	case grantrequest.FieldStatus:
		v, ok := value.(grantrequest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown GrantRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GrantRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GrantRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GrantRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GrantRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(grantrequest.FieldAttachmentURL) {
		fields = append(fields, grantrequest.FieldAttachmentURL)
	}
	if m.FieldCleared(grantrequest.FieldComment) {
		fields = append(fields, grantrequest.FieldComment)
	}
	if m.FieldCleared(grantrequest.FieldTargetRoleID) {
		fields = append(fields, grantrequest.FieldTargetRoleID)
	}
	if m.FieldCleared(grantrequest.FieldTargetRoleName) {
		fields = append(fields, grantrequest.FieldTargetRoleName)
	}
	if m.FieldCleared(grantrequest.FieldTargetSuiteID) {
		fields = append(fields, grantrequest.FieldTargetSuiteID)
	}
	if m.FieldCleared(grantrequest.FieldTargetSuiteName) {
		fields = append(fields, grantrequest.FieldTargetSuiteName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GrantRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrantRequestMutation) ClearField(name string) error {
	switch name {
	case grantrequest.FieldAttachmentURL:
		m.ClearAttachmentURL()
		return nil
	case grantrequest.FieldComment:
		m.ClearComment()
		return nil
	case grantrequest.FieldTargetRoleID:
		m.ClearTargetRoleID()
		return nil
	case grantrequest.FieldTargetRoleName:
		m.ClearTargetRoleName()
		return nil
	case grantrequest.FieldTargetSuiteID:
		m.ClearTargetSuiteID()
		return nil
	case grantrequest.FieldTargetSuiteName:
		m.ClearTargetSuiteName()
		return nil
	}
	return fmt.Errorf("unknown GrantRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GrantRequestMutation) ResetField(name string) error {
	switch name {
	case grantrequest.FieldAttachmentURL:
		m.ResetAttachmentURL()
		return nil
	case grantrequest.FieldComment:
		m.ResetComment()
		return nil
	case grantrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case grantrequest.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case grantrequest.FieldEtag:
		m.ResetEtag()
		return nil
	case grantrequest.FieldReceiverID:
		m.ResetReceiverID()
		return nil
	case grantrequest.FieldReceiverType:
		m.ResetReceiverType()
		return nil
	case grantrequest.FieldTargetType:
		m.ResetTargetType()
		return nil
	case grantrequest.FieldTargetRoleID:
		m.ResetTargetRoleID()
		return nil
	case grantrequest.FieldTargetRoleName:
		m.ResetTargetRoleName()
		return nil
	case grantrequest.FieldTargetSuiteID:
		m.ResetTargetSuiteID()
		return nil
	case grantrequest.FieldTargetSuiteName:
		m.ResetTargetSuiteName()
		return nil
	case grantrequest.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown GrantRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GrantRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.permission_histories != nil {
		edges = append(edges, grantrequest.EdgePermissionHistories)
	}
	if m.role != nil {
		edges = append(edges, grantrequest.EdgeRole)
	}
	if m.role_suite != nil {
		edges = append(edges, grantrequest.EdgeRoleSuite)
	}
	if m.grant_responses != nil {
		edges = append(edges, grantrequest.EdgeGrantResponses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GrantRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grantrequest.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.permission_histories))
		for id := range m.permission_histories {
			ids = append(ids, id)
		}
		return ids
	case grantrequest.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case grantrequest.EdgeRoleSuite:
		if id := m.role_suite; id != nil {
			return []ent.Value{*id}
		}
	case grantrequest.EdgeGrantResponses:
		ids := make([]ent.Value, 0, len(m.grant_responses))
		for id := range m.grant_responses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GrantRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpermission_histories != nil {
		edges = append(edges, grantrequest.EdgePermissionHistories)
	}
	if m.removedgrant_responses != nil {
		edges = append(edges, grantrequest.EdgeGrantResponses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GrantRequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case grantrequest.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.removedpermission_histories))
		for id := range m.removedpermission_histories {
			ids = append(ids, id)
		}
		return ids
	case grantrequest.EdgeGrantResponses:
		ids := make([]ent.Value, 0, len(m.removedgrant_responses))
		for id := range m.removedgrant_responses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GrantRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpermission_histories {
		edges = append(edges, grantrequest.EdgePermissionHistories)
	}
	if m.clearedrole {
		edges = append(edges, grantrequest.EdgeRole)
	}
	if m.clearedrole_suite {
		edges = append(edges, grantrequest.EdgeRoleSuite)
	}
	if m.clearedgrant_responses {
		edges = append(edges, grantrequest.EdgeGrantResponses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GrantRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case grantrequest.EdgePermissionHistories:
		return m.clearedpermission_histories
	case grantrequest.EdgeRole:
		return m.clearedrole
	case grantrequest.EdgeRoleSuite:
		return m.clearedrole_suite
	case grantrequest.EdgeGrantResponses:
		return m.clearedgrant_responses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GrantRequestMutation) ClearEdge(name string) error {
	switch name {
	case grantrequest.EdgeRole:
		m.ClearRole()
		return nil
	case grantrequest.EdgeRoleSuite:
		m.ClearRoleSuite()
		return nil
	}
	return fmt.Errorf("unknown GrantRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GrantRequestMutation) ResetEdge(name string) error {
	switch name {
	case grantrequest.EdgePermissionHistories:
		m.ResetPermissionHistories()
		return nil
	case grantrequest.EdgeRole:
		m.ResetRole()
		return nil
	case grantrequest.EdgeRoleSuite:
		m.ResetRoleSuite()
		return nil
	case grantrequest.EdgeGrantResponses:
		m.ResetGrantResponses()
		return nil
	}
	return fmt.Errorf("unknown GrantRequest edge %s", name)
}

// GrantResponseMutation represents an operation that mutates the GrantResponse nodes in the graph.
type GrantResponseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	is_approved          *bool
	reason               *string
	responder_id         *string
	created_at           *time.Time
	etag                 *string
	clearedFields        map[string]struct{}
	grant_request        *string
	clearedgrant_request bool
	done                 bool
	oldValue             func(context.Context) (*GrantResponse, error)
	predicates           []predicate.GrantResponse
}

var _ ent.Mutation = (*GrantResponseMutation)(nil)

// grantresponseOption allows management of the mutation configuration using functional options.
type grantresponseOption func(*GrantResponseMutation)

// newGrantResponseMutation creates new mutation for the GrantResponse entity.
func newGrantResponseMutation(c config, op Op, opts ...grantresponseOption) *GrantResponseMutation {
	m := &GrantResponseMutation{
		config:        c,
		op:            op,
		typ:           TypeGrantResponse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrantResponseID sets the ID field of the mutation.
func withGrantResponseID(id string) grantresponseOption {
	return func(m *GrantResponseMutation) {
		var (
			err   error
			once  sync.Once
			value *GrantResponse
		)
		m.oldValue = func(ctx context.Context) (*GrantResponse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GrantResponse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrantResponse sets the old GrantResponse of the mutation.
func withGrantResponse(node *GrantResponse) grantresponseOption {
	return func(m *GrantResponseMutation) {
		m.oldValue = func(context.Context) (*GrantResponse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrantResponseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrantResponseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GrantResponse entities.
func (m *GrantResponseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GrantResponseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GrantResponseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GrantResponse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestID sets the "request_id" field.
func (m *GrantResponseMutation) SetRequestID(s string) {
	m.grant_request = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *GrantResponseMutation) RequestID() (r string, exists bool) {
	v := m.grant_request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the GrantResponse entity.
// If the GrantResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantResponseMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *GrantResponseMutation) ResetRequestID() {
	m.grant_request = nil
}

// SetIsApproved sets the "is_approved" field.
func (m *GrantResponseMutation) SetIsApproved(b bool) {
	m.is_approved = &b
}

// IsApproved returns the value of the "is_approved" field in the mutation.
func (m *GrantResponseMutation) IsApproved() (r bool, exists bool) {
	v := m.is_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsApproved returns the old "is_approved" field's value of the GrantResponse entity.
// If the GrantResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantResponseMutation) OldIsApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsApproved: %w", err)
	}
	return oldValue.IsApproved, nil
}

// ResetIsApproved resets all changes to the "is_approved" field.
func (m *GrantResponseMutation) ResetIsApproved() {
	m.is_approved = nil
}

// SetReason sets the "reason" field.
func (m *GrantResponseMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *GrantResponseMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the GrantResponse entity.
// If the GrantResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantResponseMutation) OldReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *GrantResponseMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[grantresponse.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *GrantResponseMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[grantresponse.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *GrantResponseMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, grantresponse.FieldReason)
}

// SetResponderID sets the "responder_id" field.
func (m *GrantResponseMutation) SetResponderID(s string) {
	m.responder_id = &s
}

// ResponderID returns the value of the "responder_id" field in the mutation.
func (m *GrantResponseMutation) ResponderID() (r string, exists bool) {
	v := m.responder_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResponderID returns the old "responder_id" field's value of the GrantResponse entity.
// If the GrantResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantResponseMutation) OldResponderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponderID: %w", err)
	}
	return oldValue.ResponderID, nil
}

// ResetResponderID resets all changes to the "responder_id" field.
func (m *GrantResponseMutation) ResetResponderID() {
	m.responder_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GrantResponseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GrantResponseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GrantResponse entity.
// If the GrantResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantResponseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GrantResponseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEtag sets the "etag" field.
func (m *GrantResponseMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *GrantResponseMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the GrantResponse entity.
// If the GrantResponse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantResponseMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *GrantResponseMutation) ResetEtag() {
	m.etag = nil
}

// SetGrantRequestID sets the "grant_request" edge to the GrantRequest entity by id.
func (m *GrantResponseMutation) SetGrantRequestID(id string) {
	m.grant_request = &id
}

// ClearGrantRequest clears the "grant_request" edge to the GrantRequest entity.
func (m *GrantResponseMutation) ClearGrantRequest() {
	m.clearedgrant_request = true
	m.clearedFields[grantresponse.FieldRequestID] = struct{}{}
}

// GrantRequestCleared reports if the "grant_request" edge to the GrantRequest entity was cleared.
func (m *GrantResponseMutation) GrantRequestCleared() bool {
	return m.clearedgrant_request
}

// GrantRequestID returns the "grant_request" edge ID in the mutation.
func (m *GrantResponseMutation) GrantRequestID() (id string, exists bool) {
	if m.grant_request != nil {
		return *m.grant_request, true
	}
	return
}

// GrantRequestIDs returns the "grant_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GrantRequestID instead. It exists only for internal usage by the builders.
func (m *GrantResponseMutation) GrantRequestIDs() (ids []string) {
	if id := m.grant_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGrantRequest resets all changes to the "grant_request" edge.
func (m *GrantResponseMutation) ResetGrantRequest() {
	m.grant_request = nil
	m.clearedgrant_request = false
}

// Where appends a list predicates to the GrantResponseMutation builder.
func (m *GrantResponseMutation) Where(ps ...predicate.GrantResponse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GrantResponseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GrantResponseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GrantResponse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GrantResponseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GrantResponseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GrantResponse).
func (m *GrantResponseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GrantResponseMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.grant_request != nil {
		fields = append(fields, grantresponse.FieldRequestID)
	}
	if m.is_approved != nil {
		fields = append(fields, grantresponse.FieldIsApproved)
	}
	if m.reason != nil {
		fields = append(fields, grantresponse.FieldReason)
	}
	if m.responder_id != nil {
		fields = append(fields, grantresponse.FieldResponderID)
	}
	if m.created_at != nil {
		fields = append(fields, grantresponse.FieldCreatedAt)
	}
	if m.etag != nil {
		fields = append(fields, grantresponse.FieldEtag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GrantResponseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grantresponse.FieldRequestID:
		return m.RequestID()
	case grantresponse.FieldIsApproved:
		return m.IsApproved()
	case grantresponse.FieldReason:
		return m.Reason()
	case grantresponse.FieldResponderID:
		return m.ResponderID()
	case grantresponse.FieldCreatedAt:
		return m.CreatedAt()
	case grantresponse.FieldEtag:
		return m.Etag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GrantResponseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grantresponse.FieldRequestID:
		return m.OldRequestID(ctx)
	case grantresponse.FieldIsApproved:
		return m.OldIsApproved(ctx)
	case grantresponse.FieldReason:
		return m.OldReason(ctx)
	case grantresponse.FieldResponderID:
		return m.OldResponderID(ctx)
	case grantresponse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case grantresponse.FieldEtag:
		return m.OldEtag(ctx)
	}
	return nil, fmt.Errorf("unknown GrantResponse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantResponseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grantresponse.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case grantresponse.FieldIsApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsApproved(v)
		return nil
	case grantresponse.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case grantresponse.FieldResponderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponderID(v)
		return nil
	case grantresponse.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case grantresponse.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	}
	return fmt.Errorf("unknown GrantResponse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GrantResponseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GrantResponseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantResponseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GrantResponse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GrantResponseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(grantresponse.FieldReason) {
		fields = append(fields, grantresponse.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GrantResponseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrantResponseMutation) ClearField(name string) error {
	switch name {
	case grantresponse.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown GrantResponse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GrantResponseMutation) ResetField(name string) error {
	switch name {
	case grantresponse.FieldRequestID:
		m.ResetRequestID()
		return nil
	case grantresponse.FieldIsApproved:
		m.ResetIsApproved()
		return nil
	case grantresponse.FieldReason:
		m.ResetReason()
		return nil
	case grantresponse.FieldResponderID:
		m.ResetResponderID()
		return nil
	case grantresponse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case grantresponse.FieldEtag:
		m.ResetEtag()
		return nil
	}
	return fmt.Errorf("unknown GrantResponse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GrantResponseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.grant_request != nil {
		edges = append(edges, grantresponse.EdgeGrantRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GrantResponseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grantresponse.EdgeGrantRequest:
		if id := m.grant_request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GrantResponseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GrantResponseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GrantResponseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgrant_request {
		edges = append(edges, grantresponse.EdgeGrantRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GrantResponseMutation) EdgeCleared(name string) bool {
	switch name {
	case grantresponse.EdgeGrantRequest:
		return m.clearedgrant_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GrantResponseMutation) ClearEdge(name string) error {
	switch name {
	case grantresponse.EdgeGrantRequest:
		m.ClearGrantRequest()
		return nil
	}
	return fmt.Errorf("unknown GrantResponse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GrantResponseMutation) ResetEdge(name string) error {
	switch name {
	case grantresponse.EdgeGrantRequest:
		m.ResetGrantRequest()
		return nil
	}
	return fmt.Errorf("unknown GrantResponse edge %s", name)
}

// PermissionHistoryMutation represents an operation that mutates the PermissionHistory nodes in the graph.
type PermissionHistoryMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	approver_id                   *string
	approver_email                *string
	created_at                    *time.Time
	effect                        *permissionhistory.Effect
	reason                        *permissionhistory.Reason
	entitlement_expr              *string
	resolved_expr                 *string
	receiver_id                   *string
	receiver_email                *string
	role_name                     *string
	role_suite_name               *string
	clearedFields                 map[string]struct{}
	entitlement                   *string
	clearedentitlement            bool
	entitlement_assignment        *string
	clearedentitlement_assignment bool
	role                          *string
	clearedrole                   bool
	role_suite                    *string
	clearedrole_suite             bool
	grant_request                 *string
	clearedgrant_request          bool
	revoke_request                *string
	clearedrevoke_request         bool
	done                          bool
	oldValue                      func(context.Context) (*PermissionHistory, error)
	predicates                    []predicate.PermissionHistory
}

var _ ent.Mutation = (*PermissionHistoryMutation)(nil)

// permissionhistoryOption allows management of the mutation configuration using functional options.
type permissionhistoryOption func(*PermissionHistoryMutation)

// newPermissionHistoryMutation creates new mutation for the PermissionHistory entity.
func newPermissionHistoryMutation(c config, op Op, opts ...permissionhistoryOption) *PermissionHistoryMutation {
	m := &PermissionHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionHistoryID sets the ID field of the mutation.
func withPermissionHistoryID(id string) permissionhistoryOption {
	return func(m *PermissionHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionHistory
		)
		m.oldValue = func(ctx context.Context) (*PermissionHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionHistory sets the old PermissionHistory of the mutation.
func withPermissionHistory(node *PermissionHistory) permissionhistoryOption {
	return func(m *PermissionHistoryMutation) {
		m.oldValue = func(context.Context) (*PermissionHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionHistory entities.
func (m *PermissionHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApproverID sets the "approver_id" field.
func (m *PermissionHistoryMutation) SetApproverID(s string) {
	m.approver_id = &s
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *PermissionHistoryMutation) ApproverID() (r string, exists bool) {
	v := m.approver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldApproverID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// ClearApproverID clears the value of the "approver_id" field.
func (m *PermissionHistoryMutation) ClearApproverID() {
	m.approver_id = nil
	m.clearedFields[permissionhistory.FieldApproverID] = struct{}{}
}

// ApproverIDCleared returns if the "approver_id" field was cleared in this mutation.
func (m *PermissionHistoryMutation) ApproverIDCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldApproverID]
	return ok
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *PermissionHistoryMutation) ResetApproverID() {
	m.approver_id = nil
	delete(m.clearedFields, permissionhistory.FieldApproverID)
}

// SetApproverEmail sets the "approver_email" field.
func (m *PermissionHistoryMutation) SetApproverEmail(s string) {
	m.approver_email = &s
}

// ApproverEmail returns the value of the "approver_email" field in the mutation.
func (m *PermissionHistoryMutation) ApproverEmail() (r string, exists bool) {
	v := m.approver_email
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverEmail returns the old "approver_email" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldApproverEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverEmail: %w", err)
	}
	return oldValue.ApproverEmail, nil
}

// ClearApproverEmail clears the value of the "approver_email" field.
func (m *PermissionHistoryMutation) ClearApproverEmail() {
	m.approver_email = nil
	m.clearedFields[permissionhistory.FieldApproverEmail] = struct{}{}
}

// ApproverEmailCleared returns if the "approver_email" field was cleared in this mutation.
func (m *PermissionHistoryMutation) ApproverEmailCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldApproverEmail]
	return ok
}

// ResetApproverEmail resets all changes to the "approver_email" field.
func (m *PermissionHistoryMutation) ResetApproverEmail() {
	m.approver_email = nil
	delete(m.clearedFields, permissionhistory.FieldApproverEmail)
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEffect sets the "effect" field.
func (m *PermissionHistoryMutation) SetEffect(pe permissionhistory.Effect) {
	m.effect = &pe
}

// Effect returns the value of the "effect" field in the mutation.
func (m *PermissionHistoryMutation) Effect() (r permissionhistory.Effect, exists bool) {
	v := m.effect
	if v == nil {
		return
	}
	return *v, true
}

// OldEffect returns the old "effect" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldEffect(ctx context.Context) (v permissionhistory.Effect, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffect: %w", err)
	}
	return oldValue.Effect, nil
}

// ResetEffect resets all changes to the "effect" field.
func (m *PermissionHistoryMutation) ResetEffect() {
	m.effect = nil
}

// SetReason sets the "reason" field.
func (m *PermissionHistoryMutation) SetReason(pe permissionhistory.Reason) {
	m.reason = &pe
}

// Reason returns the value of the "reason" field in the mutation.
func (m *PermissionHistoryMutation) Reason() (r permissionhistory.Reason, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldReason(ctx context.Context) (v permissionhistory.Reason, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *PermissionHistoryMutation) ResetReason() {
	m.reason = nil
}

// SetEntitlementID sets the "entitlement_id" field.
func (m *PermissionHistoryMutation) SetEntitlementID(s string) {
	m.entitlement = &s
}

// EntitlementID returns the value of the "entitlement_id" field in the mutation.
func (m *PermissionHistoryMutation) EntitlementID() (r string, exists bool) {
	v := m.entitlement
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementID returns the old "entitlement_id" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldEntitlementID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementID: %w", err)
	}
	return oldValue.EntitlementID, nil
}

// ClearEntitlementID clears the value of the "entitlement_id" field.
func (m *PermissionHistoryMutation) ClearEntitlementID() {
	m.entitlement = nil
	m.clearedFields[permissionhistory.FieldEntitlementID] = struct{}{}
}

// EntitlementIDCleared returns if the "entitlement_id" field was cleared in this mutation.
func (m *PermissionHistoryMutation) EntitlementIDCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldEntitlementID]
	return ok
}

// ResetEntitlementID resets all changes to the "entitlement_id" field.
func (m *PermissionHistoryMutation) ResetEntitlementID() {
	m.entitlement = nil
	delete(m.clearedFields, permissionhistory.FieldEntitlementID)
}

// SetEntitlementExpr sets the "entitlement_expr" field.
func (m *PermissionHistoryMutation) SetEntitlementExpr(s string) {
	m.entitlement_expr = &s
}

// EntitlementExpr returns the value of the "entitlement_expr" field in the mutation.
func (m *PermissionHistoryMutation) EntitlementExpr() (r string, exists bool) {
	v := m.entitlement_expr
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementExpr returns the old "entitlement_expr" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldEntitlementExpr(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementExpr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementExpr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementExpr: %w", err)
	}
	return oldValue.EntitlementExpr, nil
}

// ClearEntitlementExpr clears the value of the "entitlement_expr" field.
func (m *PermissionHistoryMutation) ClearEntitlementExpr() {
	m.entitlement_expr = nil
	m.clearedFields[permissionhistory.FieldEntitlementExpr] = struct{}{}
}

// EntitlementExprCleared returns if the "entitlement_expr" field was cleared in this mutation.
func (m *PermissionHistoryMutation) EntitlementExprCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldEntitlementExpr]
	return ok
}

// ResetEntitlementExpr resets all changes to the "entitlement_expr" field.
func (m *PermissionHistoryMutation) ResetEntitlementExpr() {
	m.entitlement_expr = nil
	delete(m.clearedFields, permissionhistory.FieldEntitlementExpr)
}

// SetEntitlementAssignmentID sets the "entitlement_assignment_id" field.
func (m *PermissionHistoryMutation) SetEntitlementAssignmentID(s string) {
	m.entitlement_assignment = &s
}

// EntitlementAssignmentID returns the value of the "entitlement_assignment_id" field in the mutation.
func (m *PermissionHistoryMutation) EntitlementAssignmentID() (r string, exists bool) {
	v := m.entitlement_assignment
	if v == nil {
		return
	}
	return *v, true
}

// OldEntitlementAssignmentID returns the old "entitlement_assignment_id" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldEntitlementAssignmentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntitlementAssignmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntitlementAssignmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntitlementAssignmentID: %w", err)
	}
	return oldValue.EntitlementAssignmentID, nil
}

// ClearEntitlementAssignmentID clears the value of the "entitlement_assignment_id" field.
func (m *PermissionHistoryMutation) ClearEntitlementAssignmentID() {
	m.entitlement_assignment = nil
	m.clearedFields[permissionhistory.FieldEntitlementAssignmentID] = struct{}{}
}

// EntitlementAssignmentIDCleared returns if the "entitlement_assignment_id" field was cleared in this mutation.
func (m *PermissionHistoryMutation) EntitlementAssignmentIDCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldEntitlementAssignmentID]
	return ok
}

// ResetEntitlementAssignmentID resets all changes to the "entitlement_assignment_id" field.
func (m *PermissionHistoryMutation) ResetEntitlementAssignmentID() {
	m.entitlement_assignment = nil
	delete(m.clearedFields, permissionhistory.FieldEntitlementAssignmentID)
}

// SetResolvedExpr sets the "resolved_expr" field.
func (m *PermissionHistoryMutation) SetResolvedExpr(s string) {
	m.resolved_expr = &s
}

// ResolvedExpr returns the value of the "resolved_expr" field in the mutation.
func (m *PermissionHistoryMutation) ResolvedExpr() (r string, exists bool) {
	v := m.resolved_expr
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedExpr returns the old "resolved_expr" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldResolvedExpr(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedExpr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedExpr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedExpr: %w", err)
	}
	return oldValue.ResolvedExpr, nil
}

// ClearResolvedExpr clears the value of the "resolved_expr" field.
func (m *PermissionHistoryMutation) ClearResolvedExpr() {
	m.resolved_expr = nil
	m.clearedFields[permissionhistory.FieldResolvedExpr] = struct{}{}
}

// ResolvedExprCleared returns if the "resolved_expr" field was cleared in this mutation.
func (m *PermissionHistoryMutation) ResolvedExprCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldResolvedExpr]
	return ok
}

// ResetResolvedExpr resets all changes to the "resolved_expr" field.
func (m *PermissionHistoryMutation) ResetResolvedExpr() {
	m.resolved_expr = nil
	delete(m.clearedFields, permissionhistory.FieldResolvedExpr)
}

// SetReceiverID sets the "receiver_id" field.
func (m *PermissionHistoryMutation) SetReceiverID(s string) {
	m.receiver_id = &s
}

// ReceiverID returns the value of the "receiver_id" field in the mutation.
func (m *PermissionHistoryMutation) ReceiverID() (r string, exists bool) {
	v := m.receiver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverID returns the old "receiver_id" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldReceiverID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverID: %w", err)
	}
	return oldValue.ReceiverID, nil
}

// ClearReceiverID clears the value of the "receiver_id" field.
func (m *PermissionHistoryMutation) ClearReceiverID() {
	m.receiver_id = nil
	m.clearedFields[permissionhistory.FieldReceiverID] = struct{}{}
}

// ReceiverIDCleared returns if the "receiver_id" field was cleared in this mutation.
func (m *PermissionHistoryMutation) ReceiverIDCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldReceiverID]
	return ok
}

// ResetReceiverID resets all changes to the "receiver_id" field.
func (m *PermissionHistoryMutation) ResetReceiverID() {
	m.receiver_id = nil
	delete(m.clearedFields, permissionhistory.FieldReceiverID)
}

// SetReceiverEmail sets the "receiver_email" field.
func (m *PermissionHistoryMutation) SetReceiverEmail(s string) {
	m.receiver_email = &s
}

// ReceiverEmail returns the value of the "receiver_email" field in the mutation.
func (m *PermissionHistoryMutation) ReceiverEmail() (r string, exists bool) {
	v := m.receiver_email
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverEmail returns the old "receiver_email" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldReceiverEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverEmail: %w", err)
	}
	return oldValue.ReceiverEmail, nil
}

// ClearReceiverEmail clears the value of the "receiver_email" field.
func (m *PermissionHistoryMutation) ClearReceiverEmail() {
	m.receiver_email = nil
	m.clearedFields[permissionhistory.FieldReceiverEmail] = struct{}{}
}

// ReceiverEmailCleared returns if the "receiver_email" field was cleared in this mutation.
func (m *PermissionHistoryMutation) ReceiverEmailCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldReceiverEmail]
	return ok
}

// ResetReceiverEmail resets all changes to the "receiver_email" field.
func (m *PermissionHistoryMutation) ResetReceiverEmail() {
	m.receiver_email = nil
	delete(m.clearedFields, permissionhistory.FieldReceiverEmail)
}

// SetGrantRequestID sets the "grant_request_id" field.
func (m *PermissionHistoryMutation) SetGrantRequestID(s string) {
	m.grant_request = &s
}

// GrantRequestID returns the value of the "grant_request_id" field in the mutation.
func (m *PermissionHistoryMutation) GrantRequestID() (r string, exists bool) {
	v := m.grant_request
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantRequestID returns the old "grant_request_id" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldGrantRequestID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantRequestID: %w", err)
	}
	return oldValue.GrantRequestID, nil
}

// ClearGrantRequestID clears the value of the "grant_request_id" field.
func (m *PermissionHistoryMutation) ClearGrantRequestID() {
	m.grant_request = nil
	m.clearedFields[permissionhistory.FieldGrantRequestID] = struct{}{}
}

// GrantRequestIDCleared returns if the "grant_request_id" field was cleared in this mutation.
func (m *PermissionHistoryMutation) GrantRequestIDCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldGrantRequestID]
	return ok
}

// ResetGrantRequestID resets all changes to the "grant_request_id" field.
func (m *PermissionHistoryMutation) ResetGrantRequestID() {
	m.grant_request = nil
	delete(m.clearedFields, permissionhistory.FieldGrantRequestID)
}

// SetRevokeRequestID sets the "revoke_request_id" field.
func (m *PermissionHistoryMutation) SetRevokeRequestID(s string) {
	m.revoke_request = &s
}

// RevokeRequestID returns the value of the "revoke_request_id" field in the mutation.
func (m *PermissionHistoryMutation) RevokeRequestID() (r string, exists bool) {
	v := m.revoke_request
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokeRequestID returns the old "revoke_request_id" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldRevokeRequestID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokeRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokeRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokeRequestID: %w", err)
	}
	return oldValue.RevokeRequestID, nil
}

// ClearRevokeRequestID clears the value of the "revoke_request_id" field.
func (m *PermissionHistoryMutation) ClearRevokeRequestID() {
	m.revoke_request = nil
	m.clearedFields[permissionhistory.FieldRevokeRequestID] = struct{}{}
}

// RevokeRequestIDCleared returns if the "revoke_request_id" field was cleared in this mutation.
func (m *PermissionHistoryMutation) RevokeRequestIDCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldRevokeRequestID]
	return ok
}

// ResetRevokeRequestID resets all changes to the "revoke_request_id" field.
func (m *PermissionHistoryMutation) ResetRevokeRequestID() {
	m.revoke_request = nil
	delete(m.clearedFields, permissionhistory.FieldRevokeRequestID)
}

// SetRoleID sets the "role_id" field.
func (m *PermissionHistoryMutation) SetRoleID(s string) {
	m.role = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *PermissionHistoryMutation) RoleID() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldRoleID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *PermissionHistoryMutation) ClearRoleID() {
	m.role = nil
	m.clearedFields[permissionhistory.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *PermissionHistoryMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *PermissionHistoryMutation) ResetRoleID() {
	m.role = nil
	delete(m.clearedFields, permissionhistory.FieldRoleID)
}

// SetRoleName sets the "role_name" field.
func (m *PermissionHistoryMutation) SetRoleName(s string) {
	m.role_name = &s
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *PermissionHistoryMutation) RoleName() (r string, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldRoleName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ClearRoleName clears the value of the "role_name" field.
func (m *PermissionHistoryMutation) ClearRoleName() {
	m.role_name = nil
	m.clearedFields[permissionhistory.FieldRoleName] = struct{}{}
}

// RoleNameCleared returns if the "role_name" field was cleared in this mutation.
func (m *PermissionHistoryMutation) RoleNameCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldRoleName]
	return ok
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *PermissionHistoryMutation) ResetRoleName() {
	m.role_name = nil
	delete(m.clearedFields, permissionhistory.FieldRoleName)
}

// SetRoleSuiteID sets the "role_suite_id" field.
func (m *PermissionHistoryMutation) SetRoleSuiteID(s string) {
	m.role_suite = &s
}

// RoleSuiteID returns the value of the "role_suite_id" field in the mutation.
func (m *PermissionHistoryMutation) RoleSuiteID() (r string, exists bool) {
	v := m.role_suite
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleSuiteID returns the old "role_suite_id" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldRoleSuiteID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleSuiteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleSuiteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleSuiteID: %w", err)
	}
	return oldValue.RoleSuiteID, nil
}

// ClearRoleSuiteID clears the value of the "role_suite_id" field.
func (m *PermissionHistoryMutation) ClearRoleSuiteID() {
	m.role_suite = nil
	m.clearedFields[permissionhistory.FieldRoleSuiteID] = struct{}{}
}

// RoleSuiteIDCleared returns if the "role_suite_id" field was cleared in this mutation.
func (m *PermissionHistoryMutation) RoleSuiteIDCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldRoleSuiteID]
	return ok
}

// ResetRoleSuiteID resets all changes to the "role_suite_id" field.
func (m *PermissionHistoryMutation) ResetRoleSuiteID() {
	m.role_suite = nil
	delete(m.clearedFields, permissionhistory.FieldRoleSuiteID)
}

// SetRoleSuiteName sets the "role_suite_name" field.
func (m *PermissionHistoryMutation) SetRoleSuiteName(s string) {
	m.role_suite_name = &s
}

// RoleSuiteName returns the value of the "role_suite_name" field in the mutation.
func (m *PermissionHistoryMutation) RoleSuiteName() (r string, exists bool) {
	v := m.role_suite_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleSuiteName returns the old "role_suite_name" field's value of the PermissionHistory entity.
// If the PermissionHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionHistoryMutation) OldRoleSuiteName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleSuiteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleSuiteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleSuiteName: %w", err)
	}
	return oldValue.RoleSuiteName, nil
}

// ClearRoleSuiteName clears the value of the "role_suite_name" field.
func (m *PermissionHistoryMutation) ClearRoleSuiteName() {
	m.role_suite_name = nil
	m.clearedFields[permissionhistory.FieldRoleSuiteName] = struct{}{}
}

// RoleSuiteNameCleared returns if the "role_suite_name" field was cleared in this mutation.
func (m *PermissionHistoryMutation) RoleSuiteNameCleared() bool {
	_, ok := m.clearedFields[permissionhistory.FieldRoleSuiteName]
	return ok
}

// ResetRoleSuiteName resets all changes to the "role_suite_name" field.
func (m *PermissionHistoryMutation) ResetRoleSuiteName() {
	m.role_suite_name = nil
	delete(m.clearedFields, permissionhistory.FieldRoleSuiteName)
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *PermissionHistoryMutation) ClearEntitlement() {
	m.clearedentitlement = true
	m.clearedFields[permissionhistory.FieldEntitlementID] = struct{}{}
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *PermissionHistoryMutation) EntitlementCleared() bool {
	return m.EntitlementIDCleared() || m.clearedentitlement
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementID instead. It exists only for internal usage by the builders.
func (m *PermissionHistoryMutation) EntitlementIDs() (ids []string) {
	if id := m.entitlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *PermissionHistoryMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
}

// ClearEntitlementAssignment clears the "entitlement_assignment" edge to the EntitlementAssignment entity.
func (m *PermissionHistoryMutation) ClearEntitlementAssignment() {
	m.clearedentitlement_assignment = true
	m.clearedFields[permissionhistory.FieldEntitlementAssignmentID] = struct{}{}
}

// EntitlementAssignmentCleared reports if the "entitlement_assignment" edge to the EntitlementAssignment entity was cleared.
func (m *PermissionHistoryMutation) EntitlementAssignmentCleared() bool {
	return m.EntitlementAssignmentIDCleared() || m.clearedentitlement_assignment
}

// EntitlementAssignmentIDs returns the "entitlement_assignment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntitlementAssignmentID instead. It exists only for internal usage by the builders.
func (m *PermissionHistoryMutation) EntitlementAssignmentIDs() (ids []string) {
	if id := m.entitlement_assignment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntitlementAssignment resets all changes to the "entitlement_assignment" edge.
func (m *PermissionHistoryMutation) ResetEntitlementAssignment() {
	m.entitlement_assignment = nil
	m.clearedentitlement_assignment = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *PermissionHistoryMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[permissionhistory.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *PermissionHistoryMutation) RoleCleared() bool {
	return m.RoleIDCleared() || m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *PermissionHistoryMutation) RoleIDs() (ids []string) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *PermissionHistoryMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// ClearRoleSuite clears the "role_suite" edge to the RoleSuite entity.
func (m *PermissionHistoryMutation) ClearRoleSuite() {
	m.clearedrole_suite = true
	m.clearedFields[permissionhistory.FieldRoleSuiteID] = struct{}{}
}

// RoleSuiteCleared reports if the "role_suite" edge to the RoleSuite entity was cleared.
func (m *PermissionHistoryMutation) RoleSuiteCleared() bool {
	return m.RoleSuiteIDCleared() || m.clearedrole_suite
}

// RoleSuiteIDs returns the "role_suite" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleSuiteID instead. It exists only for internal usage by the builders.
func (m *PermissionHistoryMutation) RoleSuiteIDs() (ids []string) {
	if id := m.role_suite; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleSuite resets all changes to the "role_suite" edge.
func (m *PermissionHistoryMutation) ResetRoleSuite() {
	m.role_suite = nil
	m.clearedrole_suite = false
}

// ClearGrantRequest clears the "grant_request" edge to the GrantRequest entity.
func (m *PermissionHistoryMutation) ClearGrantRequest() {
	m.clearedgrant_request = true
	m.clearedFields[permissionhistory.FieldGrantRequestID] = struct{}{}
}

// GrantRequestCleared reports if the "grant_request" edge to the GrantRequest entity was cleared.
func (m *PermissionHistoryMutation) GrantRequestCleared() bool {
	return m.GrantRequestIDCleared() || m.clearedgrant_request
}

// GrantRequestIDs returns the "grant_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GrantRequestID instead. It exists only for internal usage by the builders.
func (m *PermissionHistoryMutation) GrantRequestIDs() (ids []string) {
	if id := m.grant_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGrantRequest resets all changes to the "grant_request" edge.
func (m *PermissionHistoryMutation) ResetGrantRequest() {
	m.grant_request = nil
	m.clearedgrant_request = false
}

// ClearRevokeRequest clears the "revoke_request" edge to the RevokeRequest entity.
func (m *PermissionHistoryMutation) ClearRevokeRequest() {
	m.clearedrevoke_request = true
	m.clearedFields[permissionhistory.FieldRevokeRequestID] = struct{}{}
}

// RevokeRequestCleared reports if the "revoke_request" edge to the RevokeRequest entity was cleared.
func (m *PermissionHistoryMutation) RevokeRequestCleared() bool {
	return m.RevokeRequestIDCleared() || m.clearedrevoke_request
}

// RevokeRequestIDs returns the "revoke_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevokeRequestID instead. It exists only for internal usage by the builders.
func (m *PermissionHistoryMutation) RevokeRequestIDs() (ids []string) {
	if id := m.revoke_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevokeRequest resets all changes to the "revoke_request" edge.
func (m *PermissionHistoryMutation) ResetRevokeRequest() {
	m.revoke_request = nil
	m.clearedrevoke_request = false
}

// Where appends a list predicates to the PermissionHistoryMutation builder.
func (m *PermissionHistoryMutation) Where(ps ...predicate.PermissionHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionHistory).
func (m *PermissionHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.approver_id != nil {
		fields = append(fields, permissionhistory.FieldApproverID)
	}
	if m.approver_email != nil {
		fields = append(fields, permissionhistory.FieldApproverEmail)
	}
	if m.created_at != nil {
		fields = append(fields, permissionhistory.FieldCreatedAt)
	}
	if m.effect != nil {
		fields = append(fields, permissionhistory.FieldEffect)
	}
	if m.reason != nil {
		fields = append(fields, permissionhistory.FieldReason)
	}
	if m.entitlement != nil {
		fields = append(fields, permissionhistory.FieldEntitlementID)
	}
	if m.entitlement_expr != nil {
		fields = append(fields, permissionhistory.FieldEntitlementExpr)
	}
	if m.entitlement_assignment != nil {
		fields = append(fields, permissionhistory.FieldEntitlementAssignmentID)
	}
	if m.resolved_expr != nil {
		fields = append(fields, permissionhistory.FieldResolvedExpr)
	}
	if m.receiver_id != nil {
		fields = append(fields, permissionhistory.FieldReceiverID)
	}
	if m.receiver_email != nil {
		fields = append(fields, permissionhistory.FieldReceiverEmail)
	}
	if m.grant_request != nil {
		fields = append(fields, permissionhistory.FieldGrantRequestID)
	}
	if m.revoke_request != nil {
		fields = append(fields, permissionhistory.FieldRevokeRequestID)
	}
	if m.role != nil {
		fields = append(fields, permissionhistory.FieldRoleID)
	}
	if m.role_name != nil {
		fields = append(fields, permissionhistory.FieldRoleName)
	}
	if m.role_suite != nil {
		fields = append(fields, permissionhistory.FieldRoleSuiteID)
	}
	if m.role_suite_name != nil {
		fields = append(fields, permissionhistory.FieldRoleSuiteName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissionhistory.FieldApproverID:
		return m.ApproverID()
	case permissionhistory.FieldApproverEmail:
		return m.ApproverEmail()
	case permissionhistory.FieldCreatedAt:
		return m.CreatedAt()
	case permissionhistory.FieldEffect:
		return m.Effect()
	case permissionhistory.FieldReason:
		return m.Reason()
	case permissionhistory.FieldEntitlementID:
		return m.EntitlementID()
	case permissionhistory.FieldEntitlementExpr:
		return m.EntitlementExpr()
	case permissionhistory.FieldEntitlementAssignmentID:
		return m.EntitlementAssignmentID()
	case permissionhistory.FieldResolvedExpr:
		return m.ResolvedExpr()
	case permissionhistory.FieldReceiverID:
		return m.ReceiverID()
	case permissionhistory.FieldReceiverEmail:
		return m.ReceiverEmail()
	case permissionhistory.FieldGrantRequestID:
		return m.GrantRequestID()
	case permissionhistory.FieldRevokeRequestID:
		return m.RevokeRequestID()
	case permissionhistory.FieldRoleID:
		return m.RoleID()
	case permissionhistory.FieldRoleName:
		return m.RoleName()
	case permissionhistory.FieldRoleSuiteID:
		return m.RoleSuiteID()
	case permissionhistory.FieldRoleSuiteName:
		return m.RoleSuiteName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissionhistory.FieldApproverID:
		return m.OldApproverID(ctx)
	case permissionhistory.FieldApproverEmail:
		return m.OldApproverEmail(ctx)
	case permissionhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permissionhistory.FieldEffect:
		return m.OldEffect(ctx)
	case permissionhistory.FieldReason:
		return m.OldReason(ctx)
	case permissionhistory.FieldEntitlementID:
		return m.OldEntitlementID(ctx)
	case permissionhistory.FieldEntitlementExpr:
		return m.OldEntitlementExpr(ctx)
	case permissionhistory.FieldEntitlementAssignmentID:
		return m.OldEntitlementAssignmentID(ctx)
	case permissionhistory.FieldResolvedExpr:
		return m.OldResolvedExpr(ctx)
	case permissionhistory.FieldReceiverID:
		return m.OldReceiverID(ctx)
	case permissionhistory.FieldReceiverEmail:
		return m.OldReceiverEmail(ctx)
	case permissionhistory.FieldGrantRequestID:
		return m.OldGrantRequestID(ctx)
	case permissionhistory.FieldRevokeRequestID:
		return m.OldRevokeRequestID(ctx)
	case permissionhistory.FieldRoleID:
		return m.OldRoleID(ctx)
	case permissionhistory.FieldRoleName:
		return m.OldRoleName(ctx)
	case permissionhistory.FieldRoleSuiteID:
		return m.OldRoleSuiteID(ctx)
	case permissionhistory.FieldRoleSuiteName:
		return m.OldRoleSuiteName(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissionhistory.FieldApproverID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	case permissionhistory.FieldApproverEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverEmail(v)
		return nil
	case permissionhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permissionhistory.FieldEffect:
		v, ok := value.(permissionhistory.Effect)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffect(v)
		return nil
	case permissionhistory.FieldReason:
		v, ok := value.(permissionhistory.Reason)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case permissionhistory.FieldEntitlementID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementID(v)
		return nil
	case permissionhistory.FieldEntitlementExpr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementExpr(v)
		return nil
	case permissionhistory.FieldEntitlementAssignmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntitlementAssignmentID(v)
		return nil
	case permissionhistory.FieldResolvedExpr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedExpr(v)
		return nil
	case permissionhistory.FieldReceiverID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverID(v)
		return nil
	case permissionhistory.FieldReceiverEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverEmail(v)
		return nil
	case permissionhistory.FieldGrantRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantRequestID(v)
		return nil
	case permissionhistory.FieldRevokeRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokeRequestID(v)
		return nil
	case permissionhistory.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case permissionhistory.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case permissionhistory.FieldRoleSuiteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleSuiteID(v)
		return nil
	case permissionhistory.FieldRoleSuiteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleSuiteName(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PermissionHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permissionhistory.FieldApproverID) {
		fields = append(fields, permissionhistory.FieldApproverID)
	}
	if m.FieldCleared(permissionhistory.FieldApproverEmail) {
		fields = append(fields, permissionhistory.FieldApproverEmail)
	}
	if m.FieldCleared(permissionhistory.FieldEntitlementID) {
		fields = append(fields, permissionhistory.FieldEntitlementID)
	}
	if m.FieldCleared(permissionhistory.FieldEntitlementExpr) {
		fields = append(fields, permissionhistory.FieldEntitlementExpr)
	}
	if m.FieldCleared(permissionhistory.FieldEntitlementAssignmentID) {
		fields = append(fields, permissionhistory.FieldEntitlementAssignmentID)
	}
	if m.FieldCleared(permissionhistory.FieldResolvedExpr) {
		fields = append(fields, permissionhistory.FieldResolvedExpr)
	}
	if m.FieldCleared(permissionhistory.FieldReceiverID) {
		fields = append(fields, permissionhistory.FieldReceiverID)
	}
	if m.FieldCleared(permissionhistory.FieldReceiverEmail) {
		fields = append(fields, permissionhistory.FieldReceiverEmail)
	}
	if m.FieldCleared(permissionhistory.FieldGrantRequestID) {
		fields = append(fields, permissionhistory.FieldGrantRequestID)
	}
	if m.FieldCleared(permissionhistory.FieldRevokeRequestID) {
		fields = append(fields, permissionhistory.FieldRevokeRequestID)
	}
	if m.FieldCleared(permissionhistory.FieldRoleID) {
		fields = append(fields, permissionhistory.FieldRoleID)
	}
	if m.FieldCleared(permissionhistory.FieldRoleName) {
		fields = append(fields, permissionhistory.FieldRoleName)
	}
	if m.FieldCleared(permissionhistory.FieldRoleSuiteID) {
		fields = append(fields, permissionhistory.FieldRoleSuiteID)
	}
	if m.FieldCleared(permissionhistory.FieldRoleSuiteName) {
		fields = append(fields, permissionhistory.FieldRoleSuiteName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionHistoryMutation) ClearField(name string) error {
	switch name {
	case permissionhistory.FieldApproverID:
		m.ClearApproverID()
		return nil
	case permissionhistory.FieldApproverEmail:
		m.ClearApproverEmail()
		return nil
	case permissionhistory.FieldEntitlementID:
		m.ClearEntitlementID()
		return nil
	case permissionhistory.FieldEntitlementExpr:
		m.ClearEntitlementExpr()
		return nil
	case permissionhistory.FieldEntitlementAssignmentID:
		m.ClearEntitlementAssignmentID()
		return nil
	case permissionhistory.FieldResolvedExpr:
		m.ClearResolvedExpr()
		return nil
	case permissionhistory.FieldReceiverID:
		m.ClearReceiverID()
		return nil
	case permissionhistory.FieldReceiverEmail:
		m.ClearReceiverEmail()
		return nil
	case permissionhistory.FieldGrantRequestID:
		m.ClearGrantRequestID()
		return nil
	case permissionhistory.FieldRevokeRequestID:
		m.ClearRevokeRequestID()
		return nil
	case permissionhistory.FieldRoleID:
		m.ClearRoleID()
		return nil
	case permissionhistory.FieldRoleName:
		m.ClearRoleName()
		return nil
	case permissionhistory.FieldRoleSuiteID:
		m.ClearRoleSuiteID()
		return nil
	case permissionhistory.FieldRoleSuiteName:
		m.ClearRoleSuiteName()
		return nil
	}
	return fmt.Errorf("unknown PermissionHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionHistoryMutation) ResetField(name string) error {
	switch name {
	case permissionhistory.FieldApproverID:
		m.ResetApproverID()
		return nil
	case permissionhistory.FieldApproverEmail:
		m.ResetApproverEmail()
		return nil
	case permissionhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permissionhistory.FieldEffect:
		m.ResetEffect()
		return nil
	case permissionhistory.FieldReason:
		m.ResetReason()
		return nil
	case permissionhistory.FieldEntitlementID:
		m.ResetEntitlementID()
		return nil
	case permissionhistory.FieldEntitlementExpr:
		m.ResetEntitlementExpr()
		return nil
	case permissionhistory.FieldEntitlementAssignmentID:
		m.ResetEntitlementAssignmentID()
		return nil
	case permissionhistory.FieldResolvedExpr:
		m.ResetResolvedExpr()
		return nil
	case permissionhistory.FieldReceiverID:
		m.ResetReceiverID()
		return nil
	case permissionhistory.FieldReceiverEmail:
		m.ResetReceiverEmail()
		return nil
	case permissionhistory.FieldGrantRequestID:
		m.ResetGrantRequestID()
		return nil
	case permissionhistory.FieldRevokeRequestID:
		m.ResetRevokeRequestID()
		return nil
	case permissionhistory.FieldRoleID:
		m.ResetRoleID()
		return nil
	case permissionhistory.FieldRoleName:
		m.ResetRoleName()
		return nil
	case permissionhistory.FieldRoleSuiteID:
		m.ResetRoleSuiteID()
		return nil
	case permissionhistory.FieldRoleSuiteName:
		m.ResetRoleSuiteName()
		return nil
	}
	return fmt.Errorf("unknown PermissionHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.entitlement != nil {
		edges = append(edges, permissionhistory.EdgeEntitlement)
	}
	if m.entitlement_assignment != nil {
		edges = append(edges, permissionhistory.EdgeEntitlementAssignment)
	}
	if m.role != nil {
		edges = append(edges, permissionhistory.EdgeRole)
	}
	if m.role_suite != nil {
		edges = append(edges, permissionhistory.EdgeRoleSuite)
	}
	if m.grant_request != nil {
		edges = append(edges, permissionhistory.EdgeGrantRequest)
	}
	if m.revoke_request != nil {
		edges = append(edges, permissionhistory.EdgeRevokeRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permissionhistory.EdgeEntitlement:
		if id := m.entitlement; id != nil {
			return []ent.Value{*id}
		}
	case permissionhistory.EdgeEntitlementAssignment:
		if id := m.entitlement_assignment; id != nil {
			return []ent.Value{*id}
		}
	case permissionhistory.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case permissionhistory.EdgeRoleSuite:
		if id := m.role_suite; id != nil {
			return []ent.Value{*id}
		}
	case permissionhistory.EdgeGrantRequest:
		if id := m.grant_request; id != nil {
			return []ent.Value{*id}
		}
	case permissionhistory.EdgeRevokeRequest:
		if id := m.revoke_request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedentitlement {
		edges = append(edges, permissionhistory.EdgeEntitlement)
	}
	if m.clearedentitlement_assignment {
		edges = append(edges, permissionhistory.EdgeEntitlementAssignment)
	}
	if m.clearedrole {
		edges = append(edges, permissionhistory.EdgeRole)
	}
	if m.clearedrole_suite {
		edges = append(edges, permissionhistory.EdgeRoleSuite)
	}
	if m.clearedgrant_request {
		edges = append(edges, permissionhistory.EdgeGrantRequest)
	}
	if m.clearedrevoke_request {
		edges = append(edges, permissionhistory.EdgeRevokeRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case permissionhistory.EdgeEntitlement:
		return m.clearedentitlement
	case permissionhistory.EdgeEntitlementAssignment:
		return m.clearedentitlement_assignment
	case permissionhistory.EdgeRole:
		return m.clearedrole
	case permissionhistory.EdgeRoleSuite:
		return m.clearedrole_suite
	case permissionhistory.EdgeGrantRequest:
		return m.clearedgrant_request
	case permissionhistory.EdgeRevokeRequest:
		return m.clearedrevoke_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionHistoryMutation) ClearEdge(name string) error {
	switch name {
	case permissionhistory.EdgeEntitlement:
		m.ClearEntitlement()
		return nil
	case permissionhistory.EdgeEntitlementAssignment:
		m.ClearEntitlementAssignment()
		return nil
	case permissionhistory.EdgeRole:
		m.ClearRole()
		return nil
	case permissionhistory.EdgeRoleSuite:
		m.ClearRoleSuite()
		return nil
	case permissionhistory.EdgeGrantRequest:
		m.ClearGrantRequest()
		return nil
	case permissionhistory.EdgeRevokeRequest:
		m.ClearRevokeRequest()
		return nil
	}
	return fmt.Errorf("unknown PermissionHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionHistoryMutation) ResetEdge(name string) error {
	switch name {
	case permissionhistory.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	case permissionhistory.EdgeEntitlementAssignment:
		m.ResetEntitlementAssignment()
		return nil
	case permissionhistory.EdgeRole:
		m.ResetRole()
		return nil
	case permissionhistory.EdgeRoleSuite:
		m.ResetRoleSuite()
		return nil
	case permissionhistory.EdgeGrantRequest:
		m.ResetGrantRequest()
		return nil
	case permissionhistory.EdgeRevokeRequest:
		m.ResetRevokeRequest()
		return nil
	}
	return fmt.Errorf("unknown PermissionHistory edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	name                *string
	description         *string
	etag                *string
	resource_type       *string
	resource_ref        *string
	scope_type          *string
	clearedFields       map[string]struct{}
	actions             map[string]struct{}
	removedactions      map[string]struct{}
	clearedactions      bool
	entitlements        map[string]struct{}
	removedentitlements map[string]struct{}
	clearedentitlements bool
	done                bool
	oldValue            func(context.Context) (*Resource, error)
	predicates          []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id string) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Resource entities.
func (m *ResourceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetName sets the "name" field.
func (m *ResourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ResourceMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ResourceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResourceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ResourceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resource.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ResourceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resource.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ResourceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resource.FieldDescription)
}

// SetEtag sets the "etag" field.
func (m *ResourceMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *ResourceMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *ResourceMutation) ResetEtag() {
	m.etag = nil
}

// SetResourceType sets the "resource_type" field.
func (m *ResourceMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *ResourceMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *ResourceMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceRef sets the "resource_ref" field.
func (m *ResourceMutation) SetResourceRef(s string) {
	m.resource_ref = &s
}

// ResourceRef returns the value of the "resource_ref" field in the mutation.
func (m *ResourceMutation) ResourceRef() (r string, exists bool) {
	v := m.resource_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceRef returns the old "resource_ref" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldResourceRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceRef: %w", err)
	}
	return oldValue.ResourceRef, nil
}

// ClearResourceRef clears the value of the "resource_ref" field.
func (m *ResourceMutation) ClearResourceRef() {
	m.resource_ref = nil
	m.clearedFields[resource.FieldResourceRef] = struct{}{}
}

// ResourceRefCleared returns if the "resource_ref" field was cleared in this mutation.
func (m *ResourceMutation) ResourceRefCleared() bool {
	_, ok := m.clearedFields[resource.FieldResourceRef]
	return ok
}

// ResetResourceRef resets all changes to the "resource_ref" field.
func (m *ResourceMutation) ResetResourceRef() {
	m.resource_ref = nil
	delete(m.clearedFields, resource.FieldResourceRef)
}

// SetScopeType sets the "scope_type" field.
func (m *ResourceMutation) SetScopeType(s string) {
	m.scope_type = &s
}

// ScopeType returns the value of the "scope_type" field in the mutation.
func (m *ResourceMutation) ScopeType() (r string, exists bool) {
	v := m.scope_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeType returns the old "scope_type" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldScopeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeType: %w", err)
	}
	return oldValue.ScopeType, nil
}

// ResetScopeType resets all changes to the "scope_type" field.
func (m *ResourceMutation) ResetScopeType() {
	m.scope_type = nil
}

// AddActionIDs adds the "actions" edge to the Action entity by ids.
func (m *ResourceMutation) AddActionIDs(ids ...string) {
	if m.actions == nil {
		m.actions = make(map[string]struct{})
	}
	for i := range ids {
		m.actions[ids[i]] = struct{}{}
	}
}

// ClearActions clears the "actions" edge to the Action entity.
func (m *ResourceMutation) ClearActions() {
	m.clearedactions = true
}

// ActionsCleared reports if the "actions" edge to the Action entity was cleared.
func (m *ResourceMutation) ActionsCleared() bool {
	return m.clearedactions
}

// RemoveActionIDs removes the "actions" edge to the Action entity by IDs.
func (m *ResourceMutation) RemoveActionIDs(ids ...string) {
	if m.removedactions == nil {
		m.removedactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.actions, ids[i])
		m.removedactions[ids[i]] = struct{}{}
	}
}

// RemovedActions returns the removed IDs of the "actions" edge to the Action entity.
func (m *ResourceMutation) RemovedActionsIDs() (ids []string) {
	for id := range m.removedactions {
		ids = append(ids, id)
	}
	return
}

// ActionsIDs returns the "actions" edge IDs in the mutation.
func (m *ResourceMutation) ActionsIDs() (ids []string) {
	for id := range m.actions {
		ids = append(ids, id)
	}
	return
}

// ResetActions resets all changes to the "actions" edge.
func (m *ResourceMutation) ResetActions() {
	m.actions = nil
	m.clearedactions = false
	m.removedactions = nil
}

// AddEntitlementIDs adds the "entitlements" edge to the Entitlement entity by ids.
func (m *ResourceMutation) AddEntitlementIDs(ids ...string) {
	if m.entitlements == nil {
		m.entitlements = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlements[ids[i]] = struct{}{}
	}
}

// ClearEntitlements clears the "entitlements" edge to the Entitlement entity.
func (m *ResourceMutation) ClearEntitlements() {
	m.clearedentitlements = true
}

// EntitlementsCleared reports if the "entitlements" edge to the Entitlement entity was cleared.
func (m *ResourceMutation) EntitlementsCleared() bool {
	return m.clearedentitlements
}

// RemoveEntitlementIDs removes the "entitlements" edge to the Entitlement entity by IDs.
func (m *ResourceMutation) RemoveEntitlementIDs(ids ...string) {
	if m.removedentitlements == nil {
		m.removedentitlements = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlements, ids[i])
		m.removedentitlements[ids[i]] = struct{}{}
	}
}

// RemovedEntitlements returns the removed IDs of the "entitlements" edge to the Entitlement entity.
func (m *ResourceMutation) RemovedEntitlementsIDs() (ids []string) {
	for id := range m.removedentitlements {
		ids = append(ids, id)
	}
	return
}

// EntitlementsIDs returns the "entitlements" edge IDs in the mutation.
func (m *ResourceMutation) EntitlementsIDs() (ids []string) {
	for id := range m.entitlements {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlements resets all changes to the "entitlements" edge.
func (m *ResourceMutation) ResetEntitlements() {
	m.entitlements = nil
	m.clearedentitlements = false
	m.removedentitlements = nil
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, resource.FieldCreatedAt)
	}
	if m.name != nil {
		fields = append(fields, resource.FieldName)
	}
	if m.description != nil {
		fields = append(fields, resource.FieldDescription)
	}
	if m.etag != nil {
		fields = append(fields, resource.FieldEtag)
	}
	if m.resource_type != nil {
		fields = append(fields, resource.FieldResourceType)
	}
	if m.resource_ref != nil {
		fields = append(fields, resource.FieldResourceRef)
	}
	if m.scope_type != nil {
		fields = append(fields, resource.FieldScopeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldCreatedAt:
		return m.CreatedAt()
	case resource.FieldName:
		return m.Name()
	case resource.FieldDescription:
		return m.Description()
	case resource.FieldEtag:
		return m.Etag()
	case resource.FieldResourceType:
		return m.ResourceType()
	case resource.FieldResourceRef:
		return m.ResourceRef()
	case resource.FieldScopeType:
		return m.ScopeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resource.FieldName:
		return m.OldName(ctx)
	case resource.FieldDescription:
		return m.OldDescription(ctx)
	case resource.FieldEtag:
		return m.OldEtag(ctx)
	case resource.FieldResourceType:
		return m.OldResourceType(ctx)
	case resource.FieldResourceRef:
		return m.OldResourceRef(ctx)
	case resource.FieldScopeType:
		return m.OldScopeType(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resource.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case resource.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case resource.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case resource.FieldResourceRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceRef(v)
		return nil
	case resource.FieldScopeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeType(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resource.FieldDescription) {
		fields = append(fields, resource.FieldDescription)
	}
	if m.FieldCleared(resource.FieldResourceRef) {
		fields = append(fields, resource.FieldResourceRef)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	switch name {
	case resource.FieldDescription:
		m.ClearDescription()
		return nil
	case resource.FieldResourceRef:
		m.ClearResourceRef()
		return nil
	}
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resource.FieldName:
		m.ResetName()
		return nil
	case resource.FieldDescription:
		m.ResetDescription()
		return nil
	case resource.FieldEtag:
		m.ResetEtag()
		return nil
	case resource.FieldResourceType:
		m.ResetResourceType()
		return nil
	case resource.FieldResourceRef:
		m.ResetResourceRef()
		return nil
	case resource.FieldScopeType:
		m.ResetScopeType()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.actions != nil {
		edges = append(edges, resource.EdgeActions)
	}
	if m.entitlements != nil {
		edges = append(edges, resource.EdgeEntitlements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeActions:
		ids := make([]ent.Value, 0, len(m.actions))
		for id := range m.actions {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeEntitlements:
		ids := make([]ent.Value, 0, len(m.entitlements))
		for id := range m.entitlements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedactions != nil {
		edges = append(edges, resource.EdgeActions)
	}
	if m.removedentitlements != nil {
		edges = append(edges, resource.EdgeEntitlements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeActions:
		ids := make([]ent.Value, 0, len(m.removedactions))
		for id := range m.removedactions {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeEntitlements:
		ids := make([]ent.Value, 0, len(m.removedentitlements))
		for id := range m.removedentitlements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedactions {
		edges = append(edges, resource.EdgeActions)
	}
	if m.clearedentitlements {
		edges = append(edges, resource.EdgeEntitlements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgeActions:
		return m.clearedactions
	case resource.EdgeEntitlements:
		return m.clearedentitlements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgeActions:
		m.ResetActions()
		return nil
	case resource.EdgeEntitlements:
		m.ResetEntitlements()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// RevokeRequestMutation represents an operation that mutates the RevokeRequest nodes in the graph.
type RevokeRequestMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	attachment_url              *string
	comment                     *string
	created_at                  *time.Time
	created_by                  *string
	etag                        *string
	receiver_id                 *string
	receiver_type               *revokerequest.ReceiverType
	target_type                 *revokerequest.TargetType
	target_role_name            *string
	target_suite_name           *string
	clearedFields               map[string]struct{}
	permission_histories        map[string]struct{}
	removedpermission_histories map[string]struct{}
	clearedpermission_histories bool
	role                        *string
	clearedrole                 bool
	role_suite                  *string
	clearedrole_suite           bool
	done                        bool
	oldValue                    func(context.Context) (*RevokeRequest, error)
	predicates                  []predicate.RevokeRequest
}

var _ ent.Mutation = (*RevokeRequestMutation)(nil)

// revokerequestOption allows management of the mutation configuration using functional options.
type revokerequestOption func(*RevokeRequestMutation)

// newRevokeRequestMutation creates new mutation for the RevokeRequest entity.
func newRevokeRequestMutation(c config, op Op, opts ...revokerequestOption) *RevokeRequestMutation {
	m := &RevokeRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeRevokeRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevokeRequestID sets the ID field of the mutation.
func withRevokeRequestID(id string) revokerequestOption {
	return func(m *RevokeRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *RevokeRequest
		)
		m.oldValue = func(ctx context.Context) (*RevokeRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RevokeRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevokeRequest sets the old RevokeRequest of the mutation.
func withRevokeRequest(node *RevokeRequest) revokerequestOption {
	return func(m *RevokeRequestMutation) {
		m.oldValue = func(context.Context) (*RevokeRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevokeRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevokeRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RevokeRequest entities.
func (m *RevokeRequestMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevokeRequestMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevokeRequestMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RevokeRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAttachmentURL sets the "attachment_url" field.
func (m *RevokeRequestMutation) SetAttachmentURL(s string) {
	m.attachment_url = &s
}

// AttachmentURL returns the value of the "attachment_url" field in the mutation.
func (m *RevokeRequestMutation) AttachmentURL() (r string, exists bool) {
	v := m.attachment_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentURL returns the old "attachment_url" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldAttachmentURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachmentURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachmentURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentURL: %w", err)
	}
	return oldValue.AttachmentURL, nil
}

// ClearAttachmentURL clears the value of the "attachment_url" field.
func (m *RevokeRequestMutation) ClearAttachmentURL() {
	m.attachment_url = nil
	m.clearedFields[revokerequest.FieldAttachmentURL] = struct{}{}
}

// AttachmentURLCleared returns if the "attachment_url" field was cleared in this mutation.
func (m *RevokeRequestMutation) AttachmentURLCleared() bool {
	_, ok := m.clearedFields[revokerequest.FieldAttachmentURL]
	return ok
}

// ResetAttachmentURL resets all changes to the "attachment_url" field.
func (m *RevokeRequestMutation) ResetAttachmentURL() {
	m.attachment_url = nil
	delete(m.clearedFields, revokerequest.FieldAttachmentURL)
}

// SetComment sets the "comment" field.
func (m *RevokeRequestMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *RevokeRequestMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *RevokeRequestMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[revokerequest.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *RevokeRequestMutation) CommentCleared() bool {
	_, ok := m.clearedFields[revokerequest.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *RevokeRequestMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, revokerequest.FieldComment)
}

// SetCreatedAt sets the "created_at" field.
func (m *RevokeRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RevokeRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RevokeRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RevokeRequestMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RevokeRequestMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RevokeRequestMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetEtag sets the "etag" field.
func (m *RevokeRequestMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *RevokeRequestMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *RevokeRequestMutation) ResetEtag() {
	m.etag = nil
}

// SetReceiverID sets the "receiver_id" field.
func (m *RevokeRequestMutation) SetReceiverID(s string) {
	m.receiver_id = &s
}

// ReceiverID returns the value of the "receiver_id" field in the mutation.
func (m *RevokeRequestMutation) ReceiverID() (r string, exists bool) {
	v := m.receiver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverID returns the old "receiver_id" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldReceiverID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverID: %w", err)
	}
	return oldValue.ReceiverID, nil
}

// ResetReceiverID resets all changes to the "receiver_id" field.
func (m *RevokeRequestMutation) ResetReceiverID() {
	m.receiver_id = nil
}

// SetReceiverType sets the "receiver_type" field.
func (m *RevokeRequestMutation) SetReceiverType(rt revokerequest.ReceiverType) {
	m.receiver_type = &rt
}

// ReceiverType returns the value of the "receiver_type" field in the mutation.
func (m *RevokeRequestMutation) ReceiverType() (r revokerequest.ReceiverType, exists bool) {
	v := m.receiver_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverType returns the old "receiver_type" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldReceiverType(ctx context.Context) (v revokerequest.ReceiverType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverType: %w", err)
	}
	return oldValue.ReceiverType, nil
}

// ResetReceiverType resets all changes to the "receiver_type" field.
func (m *RevokeRequestMutation) ResetReceiverType() {
	m.receiver_type = nil
}

// SetTargetType sets the "target_type" field.
func (m *RevokeRequestMutation) SetTargetType(rt revokerequest.TargetType) {
	m.target_type = &rt
}

// TargetType returns the value of the "target_type" field in the mutation.
func (m *RevokeRequestMutation) TargetType() (r revokerequest.TargetType, exists bool) {
	v := m.target_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetType returns the old "target_type" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldTargetType(ctx context.Context) (v revokerequest.TargetType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetType: %w", err)
	}
	return oldValue.TargetType, nil
}

// ResetTargetType resets all changes to the "target_type" field.
func (m *RevokeRequestMutation) ResetTargetType() {
	m.target_type = nil
}

// SetTargetRoleID sets the "target_role_id" field.
func (m *RevokeRequestMutation) SetTargetRoleID(s string) {
	m.role = &s
}

// TargetRoleID returns the value of the "target_role_id" field in the mutation.
func (m *RevokeRequestMutation) TargetRoleID() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetRoleID returns the old "target_role_id" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldTargetRoleID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetRoleID: %w", err)
	}
	return oldValue.TargetRoleID, nil
}

// ClearTargetRoleID clears the value of the "target_role_id" field.
func (m *RevokeRequestMutation) ClearTargetRoleID() {
	m.role = nil
	m.clearedFields[revokerequest.FieldTargetRoleID] = struct{}{}
}

// TargetRoleIDCleared returns if the "target_role_id" field was cleared in this mutation.
func (m *RevokeRequestMutation) TargetRoleIDCleared() bool {
	_, ok := m.clearedFields[revokerequest.FieldTargetRoleID]
	return ok
}

// ResetTargetRoleID resets all changes to the "target_role_id" field.
func (m *RevokeRequestMutation) ResetTargetRoleID() {
	m.role = nil
	delete(m.clearedFields, revokerequest.FieldTargetRoleID)
}

// SetTargetRoleName sets the "target_role_name" field.
func (m *RevokeRequestMutation) SetTargetRoleName(s string) {
	m.target_role_name = &s
}

// TargetRoleName returns the value of the "target_role_name" field in the mutation.
func (m *RevokeRequestMutation) TargetRoleName() (r string, exists bool) {
	v := m.target_role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetRoleName returns the old "target_role_name" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldTargetRoleName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetRoleName: %w", err)
	}
	return oldValue.TargetRoleName, nil
}

// ClearTargetRoleName clears the value of the "target_role_name" field.
func (m *RevokeRequestMutation) ClearTargetRoleName() {
	m.target_role_name = nil
	m.clearedFields[revokerequest.FieldTargetRoleName] = struct{}{}
}

// TargetRoleNameCleared returns if the "target_role_name" field was cleared in this mutation.
func (m *RevokeRequestMutation) TargetRoleNameCleared() bool {
	_, ok := m.clearedFields[revokerequest.FieldTargetRoleName]
	return ok
}

// ResetTargetRoleName resets all changes to the "target_role_name" field.
func (m *RevokeRequestMutation) ResetTargetRoleName() {
	m.target_role_name = nil
	delete(m.clearedFields, revokerequest.FieldTargetRoleName)
}

// SetTargetSuiteID sets the "target_suite_id" field.
func (m *RevokeRequestMutation) SetTargetSuiteID(s string) {
	m.role_suite = &s
}

// TargetSuiteID returns the value of the "target_suite_id" field in the mutation.
func (m *RevokeRequestMutation) TargetSuiteID() (r string, exists bool) {
	v := m.role_suite
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetSuiteID returns the old "target_suite_id" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldTargetSuiteID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetSuiteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetSuiteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetSuiteID: %w", err)
	}
	return oldValue.TargetSuiteID, nil
}

// ClearTargetSuiteID clears the value of the "target_suite_id" field.
func (m *RevokeRequestMutation) ClearTargetSuiteID() {
	m.role_suite = nil
	m.clearedFields[revokerequest.FieldTargetSuiteID] = struct{}{}
}

// TargetSuiteIDCleared returns if the "target_suite_id" field was cleared in this mutation.
func (m *RevokeRequestMutation) TargetSuiteIDCleared() bool {
	_, ok := m.clearedFields[revokerequest.FieldTargetSuiteID]
	return ok
}

// ResetTargetSuiteID resets all changes to the "target_suite_id" field.
func (m *RevokeRequestMutation) ResetTargetSuiteID() {
	m.role_suite = nil
	delete(m.clearedFields, revokerequest.FieldTargetSuiteID)
}

// SetTargetSuiteName sets the "target_suite_name" field.
func (m *RevokeRequestMutation) SetTargetSuiteName(s string) {
	m.target_suite_name = &s
}

// TargetSuiteName returns the value of the "target_suite_name" field in the mutation.
func (m *RevokeRequestMutation) TargetSuiteName() (r string, exists bool) {
	v := m.target_suite_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetSuiteName returns the old "target_suite_name" field's value of the RevokeRequest entity.
// If the RevokeRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevokeRequestMutation) OldTargetSuiteName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetSuiteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetSuiteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetSuiteName: %w", err)
	}
	return oldValue.TargetSuiteName, nil
}

// ClearTargetSuiteName clears the value of the "target_suite_name" field.
func (m *RevokeRequestMutation) ClearTargetSuiteName() {
	m.target_suite_name = nil
	m.clearedFields[revokerequest.FieldTargetSuiteName] = struct{}{}
}

// TargetSuiteNameCleared returns if the "target_suite_name" field was cleared in this mutation.
func (m *RevokeRequestMutation) TargetSuiteNameCleared() bool {
	_, ok := m.clearedFields[revokerequest.FieldTargetSuiteName]
	return ok
}

// ResetTargetSuiteName resets all changes to the "target_suite_name" field.
func (m *RevokeRequestMutation) ResetTargetSuiteName() {
	m.target_suite_name = nil
	delete(m.clearedFields, revokerequest.FieldTargetSuiteName)
}

// AddPermissionHistoryIDs adds the "permission_histories" edge to the PermissionHistory entity by ids.
func (m *RevokeRequestMutation) AddPermissionHistoryIDs(ids ...string) {
	if m.permission_histories == nil {
		m.permission_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.permission_histories[ids[i]] = struct{}{}
	}
}

// ClearPermissionHistories clears the "permission_histories" edge to the PermissionHistory entity.
func (m *RevokeRequestMutation) ClearPermissionHistories() {
	m.clearedpermission_histories = true
}

// PermissionHistoriesCleared reports if the "permission_histories" edge to the PermissionHistory entity was cleared.
func (m *RevokeRequestMutation) PermissionHistoriesCleared() bool {
	return m.clearedpermission_histories
}

// RemovePermissionHistoryIDs removes the "permission_histories" edge to the PermissionHistory entity by IDs.
func (m *RevokeRequestMutation) RemovePermissionHistoryIDs(ids ...string) {
	if m.removedpermission_histories == nil {
		m.removedpermission_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.permission_histories, ids[i])
		m.removedpermission_histories[ids[i]] = struct{}{}
	}
}

// RemovedPermissionHistories returns the removed IDs of the "permission_histories" edge to the PermissionHistory entity.
func (m *RevokeRequestMutation) RemovedPermissionHistoriesIDs() (ids []string) {
	for id := range m.removedpermission_histories {
		ids = append(ids, id)
	}
	return
}

// PermissionHistoriesIDs returns the "permission_histories" edge IDs in the mutation.
func (m *RevokeRequestMutation) PermissionHistoriesIDs() (ids []string) {
	for id := range m.permission_histories {
		ids = append(ids, id)
	}
	return
}

// ResetPermissionHistories resets all changes to the "permission_histories" edge.
func (m *RevokeRequestMutation) ResetPermissionHistories() {
	m.permission_histories = nil
	m.clearedpermission_histories = false
	m.removedpermission_histories = nil
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *RevokeRequestMutation) SetRoleID(id string) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *RevokeRequestMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[revokerequest.FieldTargetRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *RevokeRequestMutation) RoleCleared() bool {
	return m.TargetRoleIDCleared() || m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *RevokeRequestMutation) RoleID() (id string, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *RevokeRequestMutation) RoleIDs() (ids []string) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *RevokeRequestMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetRoleSuiteID sets the "role_suite" edge to the RoleSuite entity by id.
func (m *RevokeRequestMutation) SetRoleSuiteID(id string) {
	m.role_suite = &id
}

// ClearRoleSuite clears the "role_suite" edge to the RoleSuite entity.
func (m *RevokeRequestMutation) ClearRoleSuite() {
	m.clearedrole_suite = true
	m.clearedFields[revokerequest.FieldTargetSuiteID] = struct{}{}
}

// RoleSuiteCleared reports if the "role_suite" edge to the RoleSuite entity was cleared.
func (m *RevokeRequestMutation) RoleSuiteCleared() bool {
	return m.TargetSuiteIDCleared() || m.clearedrole_suite
}

// RoleSuiteID returns the "role_suite" edge ID in the mutation.
func (m *RevokeRequestMutation) RoleSuiteID() (id string, exists bool) {
	if m.role_suite != nil {
		return *m.role_suite, true
	}
	return
}

// RoleSuiteIDs returns the "role_suite" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleSuiteID instead. It exists only for internal usage by the builders.
func (m *RevokeRequestMutation) RoleSuiteIDs() (ids []string) {
	if id := m.role_suite; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleSuite resets all changes to the "role_suite" edge.
func (m *RevokeRequestMutation) ResetRoleSuite() {
	m.role_suite = nil
	m.clearedrole_suite = false
}

// Where appends a list predicates to the RevokeRequestMutation builder.
func (m *RevokeRequestMutation) Where(ps ...predicate.RevokeRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RevokeRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RevokeRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RevokeRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RevokeRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RevokeRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RevokeRequest).
func (m *RevokeRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevokeRequestMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.attachment_url != nil {
		fields = append(fields, revokerequest.FieldAttachmentURL)
	}
	if m.comment != nil {
		fields = append(fields, revokerequest.FieldComment)
	}
	if m.created_at != nil {
		fields = append(fields, revokerequest.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, revokerequest.FieldCreatedBy)
	}
	if m.etag != nil {
		fields = append(fields, revokerequest.FieldEtag)
	}
	if m.receiver_id != nil {
		fields = append(fields, revokerequest.FieldReceiverID)
	}
	if m.receiver_type != nil {
		fields = append(fields, revokerequest.FieldReceiverType)
	}
	if m.target_type != nil {
		fields = append(fields, revokerequest.FieldTargetType)
	}
	if m.role != nil {
		fields = append(fields, revokerequest.FieldTargetRoleID)
	}
	if m.target_role_name != nil {
		fields = append(fields, revokerequest.FieldTargetRoleName)
	}
	if m.role_suite != nil {
		fields = append(fields, revokerequest.FieldTargetSuiteID)
	}
	if m.target_suite_name != nil {
		fields = append(fields, revokerequest.FieldTargetSuiteName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevokeRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revokerequest.FieldAttachmentURL:
		return m.AttachmentURL()
	case revokerequest.FieldComment:
		return m.Comment()
	case revokerequest.FieldCreatedAt:
		return m.CreatedAt()
	case revokerequest.FieldCreatedBy:
		return m.CreatedBy()
	case revokerequest.FieldEtag:
		return m.Etag()
	case revokerequest.FieldReceiverID:
		return m.ReceiverID()
	case revokerequest.FieldReceiverType:
		return m.ReceiverType()
	case revokerequest.FieldTargetType:
		return m.TargetType()
	case revokerequest.FieldTargetRoleID:
		return m.TargetRoleID()
	case revokerequest.FieldTargetRoleName:
		return m.TargetRoleName()
	case revokerequest.FieldTargetSuiteID:
		return m.TargetSuiteID()
	case revokerequest.FieldTargetSuiteName:
		return m.TargetSuiteName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevokeRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revokerequest.FieldAttachmentURL:
		return m.OldAttachmentURL(ctx)
	case revokerequest.FieldComment:
		return m.OldComment(ctx)
	case revokerequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case revokerequest.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case revokerequest.FieldEtag:
		return m.OldEtag(ctx)
	case revokerequest.FieldReceiverID:
		return m.OldReceiverID(ctx)
	case revokerequest.FieldReceiverType:
		return m.OldReceiverType(ctx)
	case revokerequest.FieldTargetType:
		return m.OldTargetType(ctx)
	case revokerequest.FieldTargetRoleID:
		return m.OldTargetRoleID(ctx)
	case revokerequest.FieldTargetRoleName:
		return m.OldTargetRoleName(ctx)
	case revokerequest.FieldTargetSuiteID:
		return m.OldTargetSuiteID(ctx)
	case revokerequest.FieldTargetSuiteName:
		return m.OldTargetSuiteName(ctx)
	}
	return nil, fmt.Errorf("unknown RevokeRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevokeRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revokerequest.FieldAttachmentURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentURL(v)
		return nil
	case revokerequest.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case revokerequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case revokerequest.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case revokerequest.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case revokerequest.FieldReceiverID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverID(v)
		return nil
	case revokerequest.FieldReceiverType:
		v, ok := value.(revokerequest.ReceiverType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverType(v)
		return nil
	case revokerequest.FieldTargetType:
		v, ok := value.(revokerequest.TargetType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetType(v)
		return nil
	case revokerequest.FieldTargetRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetRoleID(v)
		return nil
	case revokerequest.FieldTargetRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetRoleName(v)
		return nil
	case revokerequest.FieldTargetSuiteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetSuiteID(v)
		return nil
	case revokerequest.FieldTargetSuiteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetSuiteName(v)
		return nil
	}
	return fmt.Errorf("unknown RevokeRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevokeRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevokeRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevokeRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RevokeRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevokeRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(revokerequest.FieldAttachmentURL) {
		fields = append(fields, revokerequest.FieldAttachmentURL)
	}
	if m.FieldCleared(revokerequest.FieldComment) {
		fields = append(fields, revokerequest.FieldComment)
	}
	if m.FieldCleared(revokerequest.FieldTargetRoleID) {
		fields = append(fields, revokerequest.FieldTargetRoleID)
	}
	if m.FieldCleared(revokerequest.FieldTargetRoleName) {
		fields = append(fields, revokerequest.FieldTargetRoleName)
	}
	if m.FieldCleared(revokerequest.FieldTargetSuiteID) {
		fields = append(fields, revokerequest.FieldTargetSuiteID)
	}
	if m.FieldCleared(revokerequest.FieldTargetSuiteName) {
		fields = append(fields, revokerequest.FieldTargetSuiteName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevokeRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevokeRequestMutation) ClearField(name string) error {
	switch name {
	case revokerequest.FieldAttachmentURL:
		m.ClearAttachmentURL()
		return nil
	case revokerequest.FieldComment:
		m.ClearComment()
		return nil
	case revokerequest.FieldTargetRoleID:
		m.ClearTargetRoleID()
		return nil
	case revokerequest.FieldTargetRoleName:
		m.ClearTargetRoleName()
		return nil
	case revokerequest.FieldTargetSuiteID:
		m.ClearTargetSuiteID()
		return nil
	case revokerequest.FieldTargetSuiteName:
		m.ClearTargetSuiteName()
		return nil
	}
	return fmt.Errorf("unknown RevokeRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevokeRequestMutation) ResetField(name string) error {
	switch name {
	case revokerequest.FieldAttachmentURL:
		m.ResetAttachmentURL()
		return nil
	case revokerequest.FieldComment:
		m.ResetComment()
		return nil
	case revokerequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case revokerequest.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case revokerequest.FieldEtag:
		m.ResetEtag()
		return nil
	case revokerequest.FieldReceiverID:
		m.ResetReceiverID()
		return nil
	case revokerequest.FieldReceiverType:
		m.ResetReceiverType()
		return nil
	case revokerequest.FieldTargetType:
		m.ResetTargetType()
		return nil
	case revokerequest.FieldTargetRoleID:
		m.ResetTargetRoleID()
		return nil
	case revokerequest.FieldTargetRoleName:
		m.ResetTargetRoleName()
		return nil
	case revokerequest.FieldTargetSuiteID:
		m.ResetTargetSuiteID()
		return nil
	case revokerequest.FieldTargetSuiteName:
		m.ResetTargetSuiteName()
		return nil
	}
	return fmt.Errorf("unknown RevokeRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevokeRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.permission_histories != nil {
		edges = append(edges, revokerequest.EdgePermissionHistories)
	}
	if m.role != nil {
		edges = append(edges, revokerequest.EdgeRole)
	}
	if m.role_suite != nil {
		edges = append(edges, revokerequest.EdgeRoleSuite)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevokeRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case revokerequest.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.permission_histories))
		for id := range m.permission_histories {
			ids = append(ids, id)
		}
		return ids
	case revokerequest.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case revokerequest.EdgeRoleSuite:
		if id := m.role_suite; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevokeRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpermission_histories != nil {
		edges = append(edges, revokerequest.EdgePermissionHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevokeRequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case revokerequest.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.removedpermission_histories))
		for id := range m.removedpermission_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevokeRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpermission_histories {
		edges = append(edges, revokerequest.EdgePermissionHistories)
	}
	if m.clearedrole {
		edges = append(edges, revokerequest.EdgeRole)
	}
	if m.clearedrole_suite {
		edges = append(edges, revokerequest.EdgeRoleSuite)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevokeRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case revokerequest.EdgePermissionHistories:
		return m.clearedpermission_histories
	case revokerequest.EdgeRole:
		return m.clearedrole
	case revokerequest.EdgeRoleSuite:
		return m.clearedrole_suite
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevokeRequestMutation) ClearEdge(name string) error {
	switch name {
	case revokerequest.EdgeRole:
		m.ClearRole()
		return nil
	case revokerequest.EdgeRoleSuite:
		m.ClearRoleSuite()
		return nil
	}
	return fmt.Errorf("unknown RevokeRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevokeRequestMutation) ResetEdge(name string) error {
	switch name {
	case revokerequest.EdgePermissionHistories:
		m.ResetPermissionHistories()
		return nil
	case revokerequest.EdgeRole:
		m.ResetRole()
		return nil
	case revokerequest.EdgeRoleSuite:
		m.ResetRoleSuite()
		return nil
	}
	return fmt.Errorf("unknown RevokeRequest edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	created_at                  *time.Time
	created_by                  *string
	name                        *string
	description                 *string
	etag                        *string
	owner_type                  *role.OwnerType
	owner_ref                   *string
	is_requestable              *bool
	is_required_attachment      *bool
	is_required_comment         *bool
	clearedFields               map[string]struct{}
	role_suites                 map[string]struct{}
	removedrole_suites          map[string]struct{}
	clearedrole_suites          bool
	role_users                  map[int]struct{}
	removedrole_users           map[int]struct{}
	clearedrole_users           bool
	grant_requests              map[string]struct{}
	removedgrant_requests       map[string]struct{}
	clearedgrant_requests       bool
	revoke_requests             map[string]struct{}
	removedrevoke_requests      map[string]struct{}
	clearedrevoke_requests      bool
	permission_histories        map[string]struct{}
	removedpermission_histories map[string]struct{}
	clearedpermission_histories bool
	done                        bool
	oldValue                    func(context.Context) (*Role, error)
	predicates                  []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id string) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetEtag sets the "etag" field.
func (m *RoleMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *RoleMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *RoleMutation) ResetEtag() {
	m.etag = nil
}

// SetOwnerType sets the "owner_type" field.
func (m *RoleMutation) SetOwnerType(rt role.OwnerType) {
	m.owner_type = &rt
}

// OwnerType returns the value of the "owner_type" field in the mutation.
func (m *RoleMutation) OwnerType() (r role.OwnerType, exists bool) {
	v := m.owner_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerType returns the old "owner_type" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOwnerType(ctx context.Context) (v role.OwnerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerType: %w", err)
	}
	return oldValue.OwnerType, nil
}

// ResetOwnerType resets all changes to the "owner_type" field.
func (m *RoleMutation) ResetOwnerType() {
	m.owner_type = nil
}

// SetOwnerRef sets the "owner_ref" field.
func (m *RoleMutation) SetOwnerRef(s string) {
	m.owner_ref = &s
}

// OwnerRef returns the value of the "owner_ref" field in the mutation.
func (m *RoleMutation) OwnerRef() (r string, exists bool) {
	v := m.owner_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerRef returns the old "owner_ref" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOwnerRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerRef: %w", err)
	}
	return oldValue.OwnerRef, nil
}

// ResetOwnerRef resets all changes to the "owner_ref" field.
func (m *RoleMutation) ResetOwnerRef() {
	m.owner_ref = nil
}

// SetIsRequestable sets the "is_requestable" field.
func (m *RoleMutation) SetIsRequestable(b bool) {
	m.is_requestable = &b
}

// IsRequestable returns the value of the "is_requestable" field in the mutation.
func (m *RoleMutation) IsRequestable() (r bool, exists bool) {
	v := m.is_requestable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequestable returns the old "is_requestable" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsRequestable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequestable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequestable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequestable: %w", err)
	}
	return oldValue.IsRequestable, nil
}

// ResetIsRequestable resets all changes to the "is_requestable" field.
func (m *RoleMutation) ResetIsRequestable() {
	m.is_requestable = nil
}

// SetIsRequiredAttachment sets the "is_required_attachment" field.
func (m *RoleMutation) SetIsRequiredAttachment(b bool) {
	m.is_required_attachment = &b
}

// IsRequiredAttachment returns the value of the "is_required_attachment" field in the mutation.
func (m *RoleMutation) IsRequiredAttachment() (r bool, exists bool) {
	v := m.is_required_attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequiredAttachment returns the old "is_required_attachment" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsRequiredAttachment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequiredAttachment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequiredAttachment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequiredAttachment: %w", err)
	}
	return oldValue.IsRequiredAttachment, nil
}

// ResetIsRequiredAttachment resets all changes to the "is_required_attachment" field.
func (m *RoleMutation) ResetIsRequiredAttachment() {
	m.is_required_attachment = nil
}

// SetIsRequiredComment sets the "is_required_comment" field.
func (m *RoleMutation) SetIsRequiredComment(b bool) {
	m.is_required_comment = &b
}

// IsRequiredComment returns the value of the "is_required_comment" field in the mutation.
func (m *RoleMutation) IsRequiredComment() (r bool, exists bool) {
	v := m.is_required_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequiredComment returns the old "is_required_comment" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsRequiredComment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequiredComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequiredComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequiredComment: %w", err)
	}
	return oldValue.IsRequiredComment, nil
}

// ResetIsRequiredComment resets all changes to the "is_required_comment" field.
func (m *RoleMutation) ResetIsRequiredComment() {
	m.is_required_comment = nil
}

// AddRoleSuiteIDs adds the "role_suites" edge to the RoleSuite entity by ids.
func (m *RoleMutation) AddRoleSuiteIDs(ids ...string) {
	if m.role_suites == nil {
		m.role_suites = make(map[string]struct{})
	}
	for i := range ids {
		m.role_suites[ids[i]] = struct{}{}
	}
}

// ClearRoleSuites clears the "role_suites" edge to the RoleSuite entity.
func (m *RoleMutation) ClearRoleSuites() {
	m.clearedrole_suites = true
}

// RoleSuitesCleared reports if the "role_suites" edge to the RoleSuite entity was cleared.
func (m *RoleMutation) RoleSuitesCleared() bool {
	return m.clearedrole_suites
}

// RemoveRoleSuiteIDs removes the "role_suites" edge to the RoleSuite entity by IDs.
func (m *RoleMutation) RemoveRoleSuiteIDs(ids ...string) {
	if m.removedrole_suites == nil {
		m.removedrole_suites = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.role_suites, ids[i])
		m.removedrole_suites[ids[i]] = struct{}{}
	}
}

// RemovedRoleSuites returns the removed IDs of the "role_suites" edge to the RoleSuite entity.
func (m *RoleMutation) RemovedRoleSuitesIDs() (ids []string) {
	for id := range m.removedrole_suites {
		ids = append(ids, id)
	}
	return
}

// RoleSuitesIDs returns the "role_suites" edge IDs in the mutation.
func (m *RoleMutation) RoleSuitesIDs() (ids []string) {
	for id := range m.role_suites {
		ids = append(ids, id)
	}
	return
}

// ResetRoleSuites resets all changes to the "role_suites" edge.
func (m *RoleMutation) ResetRoleSuites() {
	m.role_suites = nil
	m.clearedrole_suites = false
	m.removedrole_suites = nil
}

// AddRoleUserIDs adds the "role_users" edge to the RoleUser entity by ids.
func (m *RoleMutation) AddRoleUserIDs(ids ...int) {
	if m.role_users == nil {
		m.role_users = make(map[int]struct{})
	}
	for i := range ids {
		m.role_users[ids[i]] = struct{}{}
	}
}

// ClearRoleUsers clears the "role_users" edge to the RoleUser entity.
func (m *RoleMutation) ClearRoleUsers() {
	m.clearedrole_users = true
}

// RoleUsersCleared reports if the "role_users" edge to the RoleUser entity was cleared.
func (m *RoleMutation) RoleUsersCleared() bool {
	return m.clearedrole_users
}

// RemoveRoleUserIDs removes the "role_users" edge to the RoleUser entity by IDs.
func (m *RoleMutation) RemoveRoleUserIDs(ids ...int) {
	if m.removedrole_users == nil {
		m.removedrole_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role_users, ids[i])
		m.removedrole_users[ids[i]] = struct{}{}
	}
}

// RemovedRoleUsers returns the removed IDs of the "role_users" edge to the RoleUser entity.
func (m *RoleMutation) RemovedRoleUsersIDs() (ids []int) {
	for id := range m.removedrole_users {
		ids = append(ids, id)
	}
	return
}

// RoleUsersIDs returns the "role_users" edge IDs in the mutation.
func (m *RoleMutation) RoleUsersIDs() (ids []int) {
	for id := range m.role_users {
		ids = append(ids, id)
	}
	return
}

// ResetRoleUsers resets all changes to the "role_users" edge.
func (m *RoleMutation) ResetRoleUsers() {
	m.role_users = nil
	m.clearedrole_users = false
	m.removedrole_users = nil
}

// AddGrantRequestIDs adds the "grant_requests" edge to the GrantRequest entity by ids.
func (m *RoleMutation) AddGrantRequestIDs(ids ...string) {
	if m.grant_requests == nil {
		m.grant_requests = make(map[string]struct{})
	}
	for i := range ids {
		m.grant_requests[ids[i]] = struct{}{}
	}
}

// ClearGrantRequests clears the "grant_requests" edge to the GrantRequest entity.
func (m *RoleMutation) ClearGrantRequests() {
	m.clearedgrant_requests = true
}

// GrantRequestsCleared reports if the "grant_requests" edge to the GrantRequest entity was cleared.
func (m *RoleMutation) GrantRequestsCleared() bool {
	return m.clearedgrant_requests
}

// RemoveGrantRequestIDs removes the "grant_requests" edge to the GrantRequest entity by IDs.
func (m *RoleMutation) RemoveGrantRequestIDs(ids ...string) {
	if m.removedgrant_requests == nil {
		m.removedgrant_requests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.grant_requests, ids[i])
		m.removedgrant_requests[ids[i]] = struct{}{}
	}
}

// RemovedGrantRequests returns the removed IDs of the "grant_requests" edge to the GrantRequest entity.
func (m *RoleMutation) RemovedGrantRequestsIDs() (ids []string) {
	for id := range m.removedgrant_requests {
		ids = append(ids, id)
	}
	return
}

// GrantRequestsIDs returns the "grant_requests" edge IDs in the mutation.
func (m *RoleMutation) GrantRequestsIDs() (ids []string) {
	for id := range m.grant_requests {
		ids = append(ids, id)
	}
	return
}

// ResetGrantRequests resets all changes to the "grant_requests" edge.
func (m *RoleMutation) ResetGrantRequests() {
	m.grant_requests = nil
	m.clearedgrant_requests = false
	m.removedgrant_requests = nil
}

// AddRevokeRequestIDs adds the "revoke_requests" edge to the RevokeRequest entity by ids.
func (m *RoleMutation) AddRevokeRequestIDs(ids ...string) {
	if m.revoke_requests == nil {
		m.revoke_requests = make(map[string]struct{})
	}
	for i := range ids {
		m.revoke_requests[ids[i]] = struct{}{}
	}
}

// ClearRevokeRequests clears the "revoke_requests" edge to the RevokeRequest entity.
func (m *RoleMutation) ClearRevokeRequests() {
	m.clearedrevoke_requests = true
}

// RevokeRequestsCleared reports if the "revoke_requests" edge to the RevokeRequest entity was cleared.
func (m *RoleMutation) RevokeRequestsCleared() bool {
	return m.clearedrevoke_requests
}

// RemoveRevokeRequestIDs removes the "revoke_requests" edge to the RevokeRequest entity by IDs.
func (m *RoleMutation) RemoveRevokeRequestIDs(ids ...string) {
	if m.removedrevoke_requests == nil {
		m.removedrevoke_requests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.revoke_requests, ids[i])
		m.removedrevoke_requests[ids[i]] = struct{}{}
	}
}

// RemovedRevokeRequests returns the removed IDs of the "revoke_requests" edge to the RevokeRequest entity.
func (m *RoleMutation) RemovedRevokeRequestsIDs() (ids []string) {
	for id := range m.removedrevoke_requests {
		ids = append(ids, id)
	}
	return
}

// RevokeRequestsIDs returns the "revoke_requests" edge IDs in the mutation.
func (m *RoleMutation) RevokeRequestsIDs() (ids []string) {
	for id := range m.revoke_requests {
		ids = append(ids, id)
	}
	return
}

// ResetRevokeRequests resets all changes to the "revoke_requests" edge.
func (m *RoleMutation) ResetRevokeRequests() {
	m.revoke_requests = nil
	m.clearedrevoke_requests = false
	m.removedrevoke_requests = nil
}

// AddPermissionHistoryIDs adds the "permission_histories" edge to the PermissionHistory entity by ids.
func (m *RoleMutation) AddPermissionHistoryIDs(ids ...string) {
	if m.permission_histories == nil {
		m.permission_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.permission_histories[ids[i]] = struct{}{}
	}
}

// ClearPermissionHistories clears the "permission_histories" edge to the PermissionHistory entity.
func (m *RoleMutation) ClearPermissionHistories() {
	m.clearedpermission_histories = true
}

// PermissionHistoriesCleared reports if the "permission_histories" edge to the PermissionHistory entity was cleared.
func (m *RoleMutation) PermissionHistoriesCleared() bool {
	return m.clearedpermission_histories
}

// RemovePermissionHistoryIDs removes the "permission_histories" edge to the PermissionHistory entity by IDs.
func (m *RoleMutation) RemovePermissionHistoryIDs(ids ...string) {
	if m.removedpermission_histories == nil {
		m.removedpermission_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.permission_histories, ids[i])
		m.removedpermission_histories[ids[i]] = struct{}{}
	}
}

// RemovedPermissionHistories returns the removed IDs of the "permission_histories" edge to the PermissionHistory entity.
func (m *RoleMutation) RemovedPermissionHistoriesIDs() (ids []string) {
	for id := range m.removedpermission_histories {
		ids = append(ids, id)
	}
	return
}

// PermissionHistoriesIDs returns the "permission_histories" edge IDs in the mutation.
func (m *RoleMutation) PermissionHistoriesIDs() (ids []string) {
	for id := range m.permission_histories {
		ids = append(ids, id)
	}
	return
}

// ResetPermissionHistories resets all changes to the "permission_histories" edge.
func (m *RoleMutation) ResetPermissionHistories() {
	m.permission_histories = nil
	m.clearedpermission_histories = false
	m.removedpermission_histories = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, role.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.etag != nil {
		fields = append(fields, role.FieldEtag)
	}
	if m.owner_type != nil {
		fields = append(fields, role.FieldOwnerType)
	}
	if m.owner_ref != nil {
		fields = append(fields, role.FieldOwnerRef)
	}
	if m.is_requestable != nil {
		fields = append(fields, role.FieldIsRequestable)
	}
	if m.is_required_attachment != nil {
		fields = append(fields, role.FieldIsRequiredAttachment)
	}
	if m.is_required_comment != nil {
		fields = append(fields, role.FieldIsRequiredComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldCreatedBy:
		return m.CreatedBy()
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	case role.FieldEtag:
		return m.Etag()
	case role.FieldOwnerType:
		return m.OwnerType()
	case role.FieldOwnerRef:
		return m.OwnerRef()
	case role.FieldIsRequestable:
		return m.IsRequestable()
	case role.FieldIsRequiredAttachment:
		return m.IsRequiredAttachment()
	case role.FieldIsRequiredComment:
		return m.IsRequiredComment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldEtag:
		return m.OldEtag(ctx)
	case role.FieldOwnerType:
		return m.OldOwnerType(ctx)
	case role.FieldOwnerRef:
		return m.OldOwnerRef(ctx)
	case role.FieldIsRequestable:
		return m.OldIsRequestable(ctx)
	case role.FieldIsRequiredAttachment:
		return m.OldIsRequiredAttachment(ctx)
	case role.FieldIsRequiredComment:
		return m.OldIsRequiredComment(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case role.FieldOwnerType:
		v, ok := value.(role.OwnerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerType(v)
		return nil
	case role.FieldOwnerRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerRef(v)
		return nil
	case role.FieldIsRequestable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequestable(v)
		return nil
	case role.FieldIsRequiredAttachment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequiredAttachment(v)
		return nil
	case role.FieldIsRequiredComment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequiredComment(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldEtag:
		m.ResetEtag()
		return nil
	case role.FieldOwnerType:
		m.ResetOwnerType()
		return nil
	case role.FieldOwnerRef:
		m.ResetOwnerRef()
		return nil
	case role.FieldIsRequestable:
		m.ResetIsRequestable()
		return nil
	case role.FieldIsRequiredAttachment:
		m.ResetIsRequiredAttachment()
		return nil
	case role.FieldIsRequiredComment:
		m.ResetIsRequiredComment()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.role_suites != nil {
		edges = append(edges, role.EdgeRoleSuites)
	}
	if m.role_users != nil {
		edges = append(edges, role.EdgeRoleUsers)
	}
	if m.grant_requests != nil {
		edges = append(edges, role.EdgeGrantRequests)
	}
	if m.revoke_requests != nil {
		edges = append(edges, role.EdgeRevokeRequests)
	}
	if m.permission_histories != nil {
		edges = append(edges, role.EdgePermissionHistories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRoleSuites:
		ids := make([]ent.Value, 0, len(m.role_suites))
		for id := range m.role_suites {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeRoleUsers:
		ids := make([]ent.Value, 0, len(m.role_users))
		for id := range m.role_users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeGrantRequests:
		ids := make([]ent.Value, 0, len(m.grant_requests))
		for id := range m.grant_requests {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeRevokeRequests:
		ids := make([]ent.Value, 0, len(m.revoke_requests))
		for id := range m.revoke_requests {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.permission_histories))
		for id := range m.permission_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrole_suites != nil {
		edges = append(edges, role.EdgeRoleSuites)
	}
	if m.removedrole_users != nil {
		edges = append(edges, role.EdgeRoleUsers)
	}
	if m.removedgrant_requests != nil {
		edges = append(edges, role.EdgeGrantRequests)
	}
	if m.removedrevoke_requests != nil {
		edges = append(edges, role.EdgeRevokeRequests)
	}
	if m.removedpermission_histories != nil {
		edges = append(edges, role.EdgePermissionHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRoleSuites:
		ids := make([]ent.Value, 0, len(m.removedrole_suites))
		for id := range m.removedrole_suites {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeRoleUsers:
		ids := make([]ent.Value, 0, len(m.removedrole_users))
		for id := range m.removedrole_users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeGrantRequests:
		ids := make([]ent.Value, 0, len(m.removedgrant_requests))
		for id := range m.removedgrant_requests {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeRevokeRequests:
		ids := make([]ent.Value, 0, len(m.removedrevoke_requests))
		for id := range m.removedrevoke_requests {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.removedpermission_histories))
		for id := range m.removedpermission_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrole_suites {
		edges = append(edges, role.EdgeRoleSuites)
	}
	if m.clearedrole_users {
		edges = append(edges, role.EdgeRoleUsers)
	}
	if m.clearedgrant_requests {
		edges = append(edges, role.EdgeGrantRequests)
	}
	if m.clearedrevoke_requests {
		edges = append(edges, role.EdgeRevokeRequests)
	}
	if m.clearedpermission_histories {
		edges = append(edges, role.EdgePermissionHistories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeRoleSuites:
		return m.clearedrole_suites
	case role.EdgeRoleUsers:
		return m.clearedrole_users
	case role.EdgeGrantRequests:
		return m.clearedgrant_requests
	case role.EdgeRevokeRequests:
		return m.clearedrevoke_requests
	case role.EdgePermissionHistories:
		return m.clearedpermission_histories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeRoleSuites:
		m.ResetRoleSuites()
		return nil
	case role.EdgeRoleUsers:
		m.ResetRoleUsers()
		return nil
	case role.EdgeGrantRequests:
		m.ResetGrantRequests()
		return nil
	case role.EdgeRevokeRequests:
		m.ResetRevokeRequests()
		return nil
	case role.EdgePermissionHistories:
		m.ResetPermissionHistories()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// RoleRoleSuiteMutation represents an operation that mutates the RoleRoleSuite nodes in the graph.
type RoleRoleSuiteMutation struct {
	config
	op                Op
	typ               string
	clearedFields     map[string]struct{}
	role              *string
	clearedrole       bool
	role_suite        *string
	clearedrole_suite bool
	done              bool
	oldValue          func(context.Context) (*RoleRoleSuite, error)
	predicates        []predicate.RoleRoleSuite
}

var _ ent.Mutation = (*RoleRoleSuiteMutation)(nil)

// rolerolesuiteOption allows management of the mutation configuration using functional options.
type rolerolesuiteOption func(*RoleRoleSuiteMutation)

// newRoleRoleSuiteMutation creates new mutation for the RoleRoleSuite entity.
func newRoleRoleSuiteMutation(c config, op Op, opts ...rolerolesuiteOption) *RoleRoleSuiteMutation {
	m := &RoleRoleSuiteMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleRoleSuite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleRoleSuiteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleRoleSuiteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetRoleID sets the "role_id" field.
func (m *RoleRoleSuiteMutation) SetRoleID(s string) {
	m.role = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RoleRoleSuiteMutation) RoleID() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RoleRoleSuiteMutation) ResetRoleID() {
	m.role = nil
}

// SetRoleSuiteID sets the "role_suite_id" field.
func (m *RoleRoleSuiteMutation) SetRoleSuiteID(s string) {
	m.role_suite = &s
}

// RoleSuiteID returns the value of the "role_suite_id" field in the mutation.
func (m *RoleRoleSuiteMutation) RoleSuiteID() (r string, exists bool) {
	v := m.role_suite
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleSuiteID resets all changes to the "role_suite_id" field.
func (m *RoleRoleSuiteMutation) ResetRoleSuiteID() {
	m.role_suite = nil
}

// ClearRole clears the "role" edge to the Role entity.
func (m *RoleRoleSuiteMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[rolerolesuite.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *RoleRoleSuiteMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *RoleRoleSuiteMutation) RoleIDs() (ids []string) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *RoleRoleSuiteMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// ClearRoleSuite clears the "role_suite" edge to the RoleSuite entity.
func (m *RoleRoleSuiteMutation) ClearRoleSuite() {
	m.clearedrole_suite = true
	m.clearedFields[rolerolesuite.FieldRoleSuiteID] = struct{}{}
}

// RoleSuiteCleared reports if the "role_suite" edge to the RoleSuite entity was cleared.
func (m *RoleRoleSuiteMutation) RoleSuiteCleared() bool {
	return m.clearedrole_suite
}

// RoleSuiteIDs returns the "role_suite" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleSuiteID instead. It exists only for internal usage by the builders.
func (m *RoleRoleSuiteMutation) RoleSuiteIDs() (ids []string) {
	if id := m.role_suite; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleSuite resets all changes to the "role_suite" edge.
func (m *RoleRoleSuiteMutation) ResetRoleSuite() {
	m.role_suite = nil
	m.clearedrole_suite = false
}

// Where appends a list predicates to the RoleRoleSuiteMutation builder.
func (m *RoleRoleSuiteMutation) Where(ps ...predicate.RoleRoleSuite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleRoleSuiteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleRoleSuiteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoleRoleSuite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleRoleSuiteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleRoleSuiteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoleRoleSuite).
func (m *RoleRoleSuiteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleRoleSuiteMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.role != nil {
		fields = append(fields, rolerolesuite.FieldRoleID)
	}
	if m.role_suite != nil {
		fields = append(fields, rolerolesuite.FieldRoleSuiteID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleRoleSuiteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolerolesuite.FieldRoleID:
		return m.RoleID()
	case rolerolesuite.FieldRoleSuiteID:
		return m.RoleSuiteID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleRoleSuiteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema RoleRoleSuite does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleRoleSuiteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolerolesuite.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case rolerolesuite.FieldRoleSuiteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleSuiteID(v)
		return nil
	}
	return fmt.Errorf("unknown RoleRoleSuite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleRoleSuiteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleRoleSuiteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleRoleSuiteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleRoleSuite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleRoleSuiteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleRoleSuiteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleRoleSuiteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RoleRoleSuite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleRoleSuiteMutation) ResetField(name string) error {
	switch name {
	case rolerolesuite.FieldRoleID:
		m.ResetRoleID()
		return nil
	case rolerolesuite.FieldRoleSuiteID:
		m.ResetRoleSuiteID()
		return nil
	}
	return fmt.Errorf("unknown RoleRoleSuite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleRoleSuiteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.role != nil {
		edges = append(edges, rolerolesuite.EdgeRole)
	}
	if m.role_suite != nil {
		edges = append(edges, rolerolesuite.EdgeRoleSuite)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleRoleSuiteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolerolesuite.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case rolerolesuite.EdgeRoleSuite:
		if id := m.role_suite; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleRoleSuiteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleRoleSuiteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleRoleSuiteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrole {
		edges = append(edges, rolerolesuite.EdgeRole)
	}
	if m.clearedrole_suite {
		edges = append(edges, rolerolesuite.EdgeRoleSuite)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleRoleSuiteMutation) EdgeCleared(name string) bool {
	switch name {
	case rolerolesuite.EdgeRole:
		return m.clearedrole
	case rolerolesuite.EdgeRoleSuite:
		return m.clearedrole_suite
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleRoleSuiteMutation) ClearEdge(name string) error {
	switch name {
	case rolerolesuite.EdgeRole:
		m.ClearRole()
		return nil
	case rolerolesuite.EdgeRoleSuite:
		m.ClearRoleSuite()
		return nil
	}
	return fmt.Errorf("unknown RoleRoleSuite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleRoleSuiteMutation) ResetEdge(name string) error {
	switch name {
	case rolerolesuite.EdgeRole:
		m.ResetRole()
		return nil
	case rolerolesuite.EdgeRoleSuite:
		m.ResetRoleSuite()
		return nil
	}
	return fmt.Errorf("unknown RoleRoleSuite edge %s", name)
}

// RoleSuiteMutation represents an operation that mutates the RoleSuite nodes in the graph.
type RoleSuiteMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	created_at                  *time.Time
	created_by                  *string
	name                        *string
	description                 *string
	etag                        *string
	owner_type                  *rolesuite.OwnerType
	owner_ref                   *string
	is_requestable              *bool
	is_required_attachment      *bool
	is_required_comment         *bool
	clearedFields               map[string]struct{}
	rolesuite_users             map[int]struct{}
	removedrolesuite_users      map[int]struct{}
	clearedrolesuite_users      bool
	permission_histories        map[string]struct{}
	removedpermission_histories map[string]struct{}
	clearedpermission_histories bool
	grant_requests              map[string]struct{}
	removedgrant_requests       map[string]struct{}
	clearedgrant_requests       bool
	revoke_requests             map[string]struct{}
	removedrevoke_requests      map[string]struct{}
	clearedrevoke_requests      bool
	roles                       map[string]struct{}
	removedroles                map[string]struct{}
	clearedroles                bool
	done                        bool
	oldValue                    func(context.Context) (*RoleSuite, error)
	predicates                  []predicate.RoleSuite
}

var _ ent.Mutation = (*RoleSuiteMutation)(nil)

// rolesuiteOption allows management of the mutation configuration using functional options.
type rolesuiteOption func(*RoleSuiteMutation)

// newRoleSuiteMutation creates new mutation for the RoleSuite entity.
func newRoleSuiteMutation(c config, op Op, opts ...rolesuiteOption) *RoleSuiteMutation {
	m := &RoleSuiteMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleSuite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleSuiteID sets the ID field of the mutation.
func withRoleSuiteID(id string) rolesuiteOption {
	return func(m *RoleSuiteMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleSuite
		)
		m.oldValue = func(ctx context.Context) (*RoleSuite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleSuite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleSuite sets the old RoleSuite of the mutation.
func withRoleSuite(node *RoleSuite) rolesuiteOption {
	return func(m *RoleSuiteMutation) {
		m.oldValue = func(context.Context) (*RoleSuite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleSuiteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleSuiteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoleSuite entities.
func (m *RoleSuiteMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleSuiteMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleSuiteMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoleSuite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleSuiteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleSuiteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoleSuite entity.
// If the RoleSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleSuiteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleSuiteMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleSuiteMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RoleSuite entity.
// If the RoleSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleSuiteMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetName sets the "name" field.
func (m *RoleSuiteMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleSuiteMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RoleSuite entity.
// If the RoleSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleSuiteMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleSuiteMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleSuiteMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RoleSuite entity.
// If the RoleSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleSuiteMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[rolesuite.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleSuiteMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[rolesuite.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleSuiteMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, rolesuite.FieldDescription)
}

// SetEtag sets the "etag" field.
func (m *RoleSuiteMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *RoleSuiteMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the RoleSuite entity.
// If the RoleSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *RoleSuiteMutation) ResetEtag() {
	m.etag = nil
}

// SetOwnerType sets the "owner_type" field.
func (m *RoleSuiteMutation) SetOwnerType(rt rolesuite.OwnerType) {
	m.owner_type = &rt
}

// OwnerType returns the value of the "owner_type" field in the mutation.
func (m *RoleSuiteMutation) OwnerType() (r rolesuite.OwnerType, exists bool) {
	v := m.owner_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerType returns the old "owner_type" field's value of the RoleSuite entity.
// If the RoleSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteMutation) OldOwnerType(ctx context.Context) (v rolesuite.OwnerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerType: %w", err)
	}
	return oldValue.OwnerType, nil
}

// ResetOwnerType resets all changes to the "owner_type" field.
func (m *RoleSuiteMutation) ResetOwnerType() {
	m.owner_type = nil
}

// SetOwnerRef sets the "owner_ref" field.
func (m *RoleSuiteMutation) SetOwnerRef(s string) {
	m.owner_ref = &s
}

// OwnerRef returns the value of the "owner_ref" field in the mutation.
func (m *RoleSuiteMutation) OwnerRef() (r string, exists bool) {
	v := m.owner_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerRef returns the old "owner_ref" field's value of the RoleSuite entity.
// If the RoleSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteMutation) OldOwnerRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerRef: %w", err)
	}
	return oldValue.OwnerRef, nil
}

// ResetOwnerRef resets all changes to the "owner_ref" field.
func (m *RoleSuiteMutation) ResetOwnerRef() {
	m.owner_ref = nil
}

// SetIsRequestable sets the "is_requestable" field.
func (m *RoleSuiteMutation) SetIsRequestable(b bool) {
	m.is_requestable = &b
}

// IsRequestable returns the value of the "is_requestable" field in the mutation.
func (m *RoleSuiteMutation) IsRequestable() (r bool, exists bool) {
	v := m.is_requestable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequestable returns the old "is_requestable" field's value of the RoleSuite entity.
// If the RoleSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteMutation) OldIsRequestable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequestable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequestable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequestable: %w", err)
	}
	return oldValue.IsRequestable, nil
}

// ResetIsRequestable resets all changes to the "is_requestable" field.
func (m *RoleSuiteMutation) ResetIsRequestable() {
	m.is_requestable = nil
}

// SetIsRequiredAttachment sets the "is_required_attachment" field.
func (m *RoleSuiteMutation) SetIsRequiredAttachment(b bool) {
	m.is_required_attachment = &b
}

// IsRequiredAttachment returns the value of the "is_required_attachment" field in the mutation.
func (m *RoleSuiteMutation) IsRequiredAttachment() (r bool, exists bool) {
	v := m.is_required_attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequiredAttachment returns the old "is_required_attachment" field's value of the RoleSuite entity.
// If the RoleSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteMutation) OldIsRequiredAttachment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequiredAttachment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequiredAttachment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequiredAttachment: %w", err)
	}
	return oldValue.IsRequiredAttachment, nil
}

// ResetIsRequiredAttachment resets all changes to the "is_required_attachment" field.
func (m *RoleSuiteMutation) ResetIsRequiredAttachment() {
	m.is_required_attachment = nil
}

// SetIsRequiredComment sets the "is_required_comment" field.
func (m *RoleSuiteMutation) SetIsRequiredComment(b bool) {
	m.is_required_comment = &b
}

// IsRequiredComment returns the value of the "is_required_comment" field in the mutation.
func (m *RoleSuiteMutation) IsRequiredComment() (r bool, exists bool) {
	v := m.is_required_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequiredComment returns the old "is_required_comment" field's value of the RoleSuite entity.
// If the RoleSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteMutation) OldIsRequiredComment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequiredComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequiredComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequiredComment: %w", err)
	}
	return oldValue.IsRequiredComment, nil
}

// ResetIsRequiredComment resets all changes to the "is_required_comment" field.
func (m *RoleSuiteMutation) ResetIsRequiredComment() {
	m.is_required_comment = nil
}

// AddRolesuiteUserIDs adds the "rolesuite_users" edge to the RoleSuiteUser entity by ids.
func (m *RoleSuiteMutation) AddRolesuiteUserIDs(ids ...int) {
	if m.rolesuite_users == nil {
		m.rolesuite_users = make(map[int]struct{})
	}
	for i := range ids {
		m.rolesuite_users[ids[i]] = struct{}{}
	}
}

// ClearRolesuiteUsers clears the "rolesuite_users" edge to the RoleSuiteUser entity.
func (m *RoleSuiteMutation) ClearRolesuiteUsers() {
	m.clearedrolesuite_users = true
}

// RolesuiteUsersCleared reports if the "rolesuite_users" edge to the RoleSuiteUser entity was cleared.
func (m *RoleSuiteMutation) RolesuiteUsersCleared() bool {
	return m.clearedrolesuite_users
}

// RemoveRolesuiteUserIDs removes the "rolesuite_users" edge to the RoleSuiteUser entity by IDs.
func (m *RoleSuiteMutation) RemoveRolesuiteUserIDs(ids ...int) {
	if m.removedrolesuite_users == nil {
		m.removedrolesuite_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rolesuite_users, ids[i])
		m.removedrolesuite_users[ids[i]] = struct{}{}
	}
}

// RemovedRolesuiteUsers returns the removed IDs of the "rolesuite_users" edge to the RoleSuiteUser entity.
func (m *RoleSuiteMutation) RemovedRolesuiteUsersIDs() (ids []int) {
	for id := range m.removedrolesuite_users {
		ids = append(ids, id)
	}
	return
}

// RolesuiteUsersIDs returns the "rolesuite_users" edge IDs in the mutation.
func (m *RoleSuiteMutation) RolesuiteUsersIDs() (ids []int) {
	for id := range m.rolesuite_users {
		ids = append(ids, id)
	}
	return
}

// ResetRolesuiteUsers resets all changes to the "rolesuite_users" edge.
func (m *RoleSuiteMutation) ResetRolesuiteUsers() {
	m.rolesuite_users = nil
	m.clearedrolesuite_users = false
	m.removedrolesuite_users = nil
}

// AddPermissionHistoryIDs adds the "permission_histories" edge to the PermissionHistory entity by ids.
func (m *RoleSuiteMutation) AddPermissionHistoryIDs(ids ...string) {
	if m.permission_histories == nil {
		m.permission_histories = make(map[string]struct{})
	}
	for i := range ids {
		m.permission_histories[ids[i]] = struct{}{}
	}
}

// ClearPermissionHistories clears the "permission_histories" edge to the PermissionHistory entity.
func (m *RoleSuiteMutation) ClearPermissionHistories() {
	m.clearedpermission_histories = true
}

// PermissionHistoriesCleared reports if the "permission_histories" edge to the PermissionHistory entity was cleared.
func (m *RoleSuiteMutation) PermissionHistoriesCleared() bool {
	return m.clearedpermission_histories
}

// RemovePermissionHistoryIDs removes the "permission_histories" edge to the PermissionHistory entity by IDs.
func (m *RoleSuiteMutation) RemovePermissionHistoryIDs(ids ...string) {
	if m.removedpermission_histories == nil {
		m.removedpermission_histories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.permission_histories, ids[i])
		m.removedpermission_histories[ids[i]] = struct{}{}
	}
}

// RemovedPermissionHistories returns the removed IDs of the "permission_histories" edge to the PermissionHistory entity.
func (m *RoleSuiteMutation) RemovedPermissionHistoriesIDs() (ids []string) {
	for id := range m.removedpermission_histories {
		ids = append(ids, id)
	}
	return
}

// PermissionHistoriesIDs returns the "permission_histories" edge IDs in the mutation.
func (m *RoleSuiteMutation) PermissionHistoriesIDs() (ids []string) {
	for id := range m.permission_histories {
		ids = append(ids, id)
	}
	return
}

// ResetPermissionHistories resets all changes to the "permission_histories" edge.
func (m *RoleSuiteMutation) ResetPermissionHistories() {
	m.permission_histories = nil
	m.clearedpermission_histories = false
	m.removedpermission_histories = nil
}

// AddGrantRequestIDs adds the "grant_requests" edge to the GrantRequest entity by ids.
func (m *RoleSuiteMutation) AddGrantRequestIDs(ids ...string) {
	if m.grant_requests == nil {
		m.grant_requests = make(map[string]struct{})
	}
	for i := range ids {
		m.grant_requests[ids[i]] = struct{}{}
	}
}

// ClearGrantRequests clears the "grant_requests" edge to the GrantRequest entity.
func (m *RoleSuiteMutation) ClearGrantRequests() {
	m.clearedgrant_requests = true
}

// GrantRequestsCleared reports if the "grant_requests" edge to the GrantRequest entity was cleared.
func (m *RoleSuiteMutation) GrantRequestsCleared() bool {
	return m.clearedgrant_requests
}

// RemoveGrantRequestIDs removes the "grant_requests" edge to the GrantRequest entity by IDs.
func (m *RoleSuiteMutation) RemoveGrantRequestIDs(ids ...string) {
	if m.removedgrant_requests == nil {
		m.removedgrant_requests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.grant_requests, ids[i])
		m.removedgrant_requests[ids[i]] = struct{}{}
	}
}

// RemovedGrantRequests returns the removed IDs of the "grant_requests" edge to the GrantRequest entity.
func (m *RoleSuiteMutation) RemovedGrantRequestsIDs() (ids []string) {
	for id := range m.removedgrant_requests {
		ids = append(ids, id)
	}
	return
}

// GrantRequestsIDs returns the "grant_requests" edge IDs in the mutation.
func (m *RoleSuiteMutation) GrantRequestsIDs() (ids []string) {
	for id := range m.grant_requests {
		ids = append(ids, id)
	}
	return
}

// ResetGrantRequests resets all changes to the "grant_requests" edge.
func (m *RoleSuiteMutation) ResetGrantRequests() {
	m.grant_requests = nil
	m.clearedgrant_requests = false
	m.removedgrant_requests = nil
}

// AddRevokeRequestIDs adds the "revoke_requests" edge to the RevokeRequest entity by ids.
func (m *RoleSuiteMutation) AddRevokeRequestIDs(ids ...string) {
	if m.revoke_requests == nil {
		m.revoke_requests = make(map[string]struct{})
	}
	for i := range ids {
		m.revoke_requests[ids[i]] = struct{}{}
	}
}

// ClearRevokeRequests clears the "revoke_requests" edge to the RevokeRequest entity.
func (m *RoleSuiteMutation) ClearRevokeRequests() {
	m.clearedrevoke_requests = true
}

// RevokeRequestsCleared reports if the "revoke_requests" edge to the RevokeRequest entity was cleared.
func (m *RoleSuiteMutation) RevokeRequestsCleared() bool {
	return m.clearedrevoke_requests
}

// RemoveRevokeRequestIDs removes the "revoke_requests" edge to the RevokeRequest entity by IDs.
func (m *RoleSuiteMutation) RemoveRevokeRequestIDs(ids ...string) {
	if m.removedrevoke_requests == nil {
		m.removedrevoke_requests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.revoke_requests, ids[i])
		m.removedrevoke_requests[ids[i]] = struct{}{}
	}
}

// RemovedRevokeRequests returns the removed IDs of the "revoke_requests" edge to the RevokeRequest entity.
func (m *RoleSuiteMutation) RemovedRevokeRequestsIDs() (ids []string) {
	for id := range m.removedrevoke_requests {
		ids = append(ids, id)
	}
	return
}

// RevokeRequestsIDs returns the "revoke_requests" edge IDs in the mutation.
func (m *RoleSuiteMutation) RevokeRequestsIDs() (ids []string) {
	for id := range m.revoke_requests {
		ids = append(ids, id)
	}
	return
}

// ResetRevokeRequests resets all changes to the "revoke_requests" edge.
func (m *RoleSuiteMutation) ResetRevokeRequests() {
	m.revoke_requests = nil
	m.clearedrevoke_requests = false
	m.removedrevoke_requests = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *RoleSuiteMutation) AddRoleIDs(ids ...string) {
	if m.roles == nil {
		m.roles = make(map[string]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *RoleSuiteMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *RoleSuiteMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *RoleSuiteMutation) RemoveRoleIDs(ids ...string) {
	if m.removedroles == nil {
		m.removedroles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *RoleSuiteMutation) RemovedRolesIDs() (ids []string) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *RoleSuiteMutation) RolesIDs() (ids []string) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *RoleSuiteMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the RoleSuiteMutation builder.
func (m *RoleSuiteMutation) Where(ps ...predicate.RoleSuite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleSuiteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleSuiteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoleSuite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleSuiteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleSuiteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoleSuite).
func (m *RoleSuiteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleSuiteMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, rolesuite.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, rolesuite.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, rolesuite.FieldName)
	}
	if m.description != nil {
		fields = append(fields, rolesuite.FieldDescription)
	}
	if m.etag != nil {
		fields = append(fields, rolesuite.FieldEtag)
	}
	if m.owner_type != nil {
		fields = append(fields, rolesuite.FieldOwnerType)
	}
	if m.owner_ref != nil {
		fields = append(fields, rolesuite.FieldOwnerRef)
	}
	if m.is_requestable != nil {
		fields = append(fields, rolesuite.FieldIsRequestable)
	}
	if m.is_required_attachment != nil {
		fields = append(fields, rolesuite.FieldIsRequiredAttachment)
	}
	if m.is_required_comment != nil {
		fields = append(fields, rolesuite.FieldIsRequiredComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleSuiteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolesuite.FieldCreatedAt:
		return m.CreatedAt()
	case rolesuite.FieldCreatedBy:
		return m.CreatedBy()
	case rolesuite.FieldName:
		return m.Name()
	case rolesuite.FieldDescription:
		return m.Description()
	case rolesuite.FieldEtag:
		return m.Etag()
	case rolesuite.FieldOwnerType:
		return m.OwnerType()
	case rolesuite.FieldOwnerRef:
		return m.OwnerRef()
	case rolesuite.FieldIsRequestable:
		return m.IsRequestable()
	case rolesuite.FieldIsRequiredAttachment:
		return m.IsRequiredAttachment()
	case rolesuite.FieldIsRequiredComment:
		return m.IsRequiredComment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleSuiteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolesuite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rolesuite.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rolesuite.FieldName:
		return m.OldName(ctx)
	case rolesuite.FieldDescription:
		return m.OldDescription(ctx)
	case rolesuite.FieldEtag:
		return m.OldEtag(ctx)
	case rolesuite.FieldOwnerType:
		return m.OldOwnerType(ctx)
	case rolesuite.FieldOwnerRef:
		return m.OldOwnerRef(ctx)
	case rolesuite.FieldIsRequestable:
		return m.OldIsRequestable(ctx)
	case rolesuite.FieldIsRequiredAttachment:
		return m.OldIsRequiredAttachment(ctx)
	case rolesuite.FieldIsRequiredComment:
		return m.OldIsRequiredComment(ctx)
	}
	return nil, fmt.Errorf("unknown RoleSuite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleSuiteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolesuite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rolesuite.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rolesuite.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rolesuite.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case rolesuite.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case rolesuite.FieldOwnerType:
		v, ok := value.(rolesuite.OwnerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerType(v)
		return nil
	case rolesuite.FieldOwnerRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerRef(v)
		return nil
	case rolesuite.FieldIsRequestable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequestable(v)
		return nil
	case rolesuite.FieldIsRequiredAttachment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequiredAttachment(v)
		return nil
	case rolesuite.FieldIsRequiredComment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequiredComment(v)
		return nil
	}
	return fmt.Errorf("unknown RoleSuite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleSuiteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleSuiteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleSuiteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleSuite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleSuiteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rolesuite.FieldDescription) {
		fields = append(fields, rolesuite.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleSuiteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleSuiteMutation) ClearField(name string) error {
	switch name {
	case rolesuite.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown RoleSuite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleSuiteMutation) ResetField(name string) error {
	switch name {
	case rolesuite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rolesuite.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rolesuite.FieldName:
		m.ResetName()
		return nil
	case rolesuite.FieldDescription:
		m.ResetDescription()
		return nil
	case rolesuite.FieldEtag:
		m.ResetEtag()
		return nil
	case rolesuite.FieldOwnerType:
		m.ResetOwnerType()
		return nil
	case rolesuite.FieldOwnerRef:
		m.ResetOwnerRef()
		return nil
	case rolesuite.FieldIsRequestable:
		m.ResetIsRequestable()
		return nil
	case rolesuite.FieldIsRequiredAttachment:
		m.ResetIsRequiredAttachment()
		return nil
	case rolesuite.FieldIsRequiredComment:
		m.ResetIsRequiredComment()
		return nil
	}
	return fmt.Errorf("unknown RoleSuite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleSuiteMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.rolesuite_users != nil {
		edges = append(edges, rolesuite.EdgeRolesuiteUsers)
	}
	if m.permission_histories != nil {
		edges = append(edges, rolesuite.EdgePermissionHistories)
	}
	if m.grant_requests != nil {
		edges = append(edges, rolesuite.EdgeGrantRequests)
	}
	if m.revoke_requests != nil {
		edges = append(edges, rolesuite.EdgeRevokeRequests)
	}
	if m.roles != nil {
		edges = append(edges, rolesuite.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleSuiteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolesuite.EdgeRolesuiteUsers:
		ids := make([]ent.Value, 0, len(m.rolesuite_users))
		for id := range m.rolesuite_users {
			ids = append(ids, id)
		}
		return ids
	case rolesuite.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.permission_histories))
		for id := range m.permission_histories {
			ids = append(ids, id)
		}
		return ids
	case rolesuite.EdgeGrantRequests:
		ids := make([]ent.Value, 0, len(m.grant_requests))
		for id := range m.grant_requests {
			ids = append(ids, id)
		}
		return ids
	case rolesuite.EdgeRevokeRequests:
		ids := make([]ent.Value, 0, len(m.revoke_requests))
		for id := range m.revoke_requests {
			ids = append(ids, id)
		}
		return ids
	case rolesuite.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleSuiteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrolesuite_users != nil {
		edges = append(edges, rolesuite.EdgeRolesuiteUsers)
	}
	if m.removedpermission_histories != nil {
		edges = append(edges, rolesuite.EdgePermissionHistories)
	}
	if m.removedgrant_requests != nil {
		edges = append(edges, rolesuite.EdgeGrantRequests)
	}
	if m.removedrevoke_requests != nil {
		edges = append(edges, rolesuite.EdgeRevokeRequests)
	}
	if m.removedroles != nil {
		edges = append(edges, rolesuite.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleSuiteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rolesuite.EdgeRolesuiteUsers:
		ids := make([]ent.Value, 0, len(m.removedrolesuite_users))
		for id := range m.removedrolesuite_users {
			ids = append(ids, id)
		}
		return ids
	case rolesuite.EdgePermissionHistories:
		ids := make([]ent.Value, 0, len(m.removedpermission_histories))
		for id := range m.removedpermission_histories {
			ids = append(ids, id)
		}
		return ids
	case rolesuite.EdgeGrantRequests:
		ids := make([]ent.Value, 0, len(m.removedgrant_requests))
		for id := range m.removedgrant_requests {
			ids = append(ids, id)
		}
		return ids
	case rolesuite.EdgeRevokeRequests:
		ids := make([]ent.Value, 0, len(m.removedrevoke_requests))
		for id := range m.removedrevoke_requests {
			ids = append(ids, id)
		}
		return ids
	case rolesuite.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleSuiteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrolesuite_users {
		edges = append(edges, rolesuite.EdgeRolesuiteUsers)
	}
	if m.clearedpermission_histories {
		edges = append(edges, rolesuite.EdgePermissionHistories)
	}
	if m.clearedgrant_requests {
		edges = append(edges, rolesuite.EdgeGrantRequests)
	}
	if m.clearedrevoke_requests {
		edges = append(edges, rolesuite.EdgeRevokeRequests)
	}
	if m.clearedroles {
		edges = append(edges, rolesuite.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleSuiteMutation) EdgeCleared(name string) bool {
	switch name {
	case rolesuite.EdgeRolesuiteUsers:
		return m.clearedrolesuite_users
	case rolesuite.EdgePermissionHistories:
		return m.clearedpermission_histories
	case rolesuite.EdgeGrantRequests:
		return m.clearedgrant_requests
	case rolesuite.EdgeRevokeRequests:
		return m.clearedrevoke_requests
	case rolesuite.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleSuiteMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleSuite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleSuiteMutation) ResetEdge(name string) error {
	switch name {
	case rolesuite.EdgeRolesuiteUsers:
		m.ResetRolesuiteUsers()
		return nil
	case rolesuite.EdgePermissionHistories:
		m.ResetPermissionHistories()
		return nil
	case rolesuite.EdgeGrantRequests:
		m.ResetGrantRequests()
		return nil
	case rolesuite.EdgeRevokeRequests:
		m.ResetRevokeRequests()
		return nil
	case rolesuite.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown RoleSuite edge %s", name)
}

// RoleSuiteUserMutation represents an operation that mutates the RoleSuiteUser nodes in the graph.
type RoleSuiteUserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	approver_id       *string
	receiver_ref      *string
	receiver_type     *rolesuiteuser.ReceiverType
	clearedFields     map[string]struct{}
	role_suite        *string
	clearedrole_suite bool
	done              bool
	oldValue          func(context.Context) (*RoleSuiteUser, error)
	predicates        []predicate.RoleSuiteUser
}

var _ ent.Mutation = (*RoleSuiteUserMutation)(nil)

// rolesuiteuserOption allows management of the mutation configuration using functional options.
type rolesuiteuserOption func(*RoleSuiteUserMutation)

// newRoleSuiteUserMutation creates new mutation for the RoleSuiteUser entity.
func newRoleSuiteUserMutation(c config, op Op, opts ...rolesuiteuserOption) *RoleSuiteUserMutation {
	m := &RoleSuiteUserMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleSuiteUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleSuiteUserID sets the ID field of the mutation.
func withRoleSuiteUserID(id int) rolesuiteuserOption {
	return func(m *RoleSuiteUserMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleSuiteUser
		)
		m.oldValue = func(ctx context.Context) (*RoleSuiteUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleSuiteUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleSuiteUser sets the old RoleSuiteUser of the mutation.
func withRoleSuiteUser(node *RoleSuiteUser) rolesuiteuserOption {
	return func(m *RoleSuiteUserMutation) {
		m.oldValue = func(context.Context) (*RoleSuiteUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleSuiteUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleSuiteUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleSuiteUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleSuiteUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoleSuiteUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApproverID sets the "approver_id" field.
func (m *RoleSuiteUserMutation) SetApproverID(s string) {
	m.approver_id = &s
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *RoleSuiteUserMutation) ApproverID() (r string, exists bool) {
	v := m.approver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the RoleSuiteUser entity.
// If the RoleSuiteUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteUserMutation) OldApproverID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *RoleSuiteUserMutation) ResetApproverID() {
	m.approver_id = nil
}

// SetReceiverRef sets the "receiver_ref" field.
func (m *RoleSuiteUserMutation) SetReceiverRef(s string) {
	m.receiver_ref = &s
}

// ReceiverRef returns the value of the "receiver_ref" field in the mutation.
func (m *RoleSuiteUserMutation) ReceiverRef() (r string, exists bool) {
	v := m.receiver_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverRef returns the old "receiver_ref" field's value of the RoleSuiteUser entity.
// If the RoleSuiteUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteUserMutation) OldReceiverRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverRef: %w", err)
	}
	return oldValue.ReceiverRef, nil
}

// ResetReceiverRef resets all changes to the "receiver_ref" field.
func (m *RoleSuiteUserMutation) ResetReceiverRef() {
	m.receiver_ref = nil
}

// SetReceiverType sets the "receiver_type" field.
func (m *RoleSuiteUserMutation) SetReceiverType(rt rolesuiteuser.ReceiverType) {
	m.receiver_type = &rt
}

// ReceiverType returns the value of the "receiver_type" field in the mutation.
func (m *RoleSuiteUserMutation) ReceiverType() (r rolesuiteuser.ReceiverType, exists bool) {
	v := m.receiver_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverType returns the old "receiver_type" field's value of the RoleSuiteUser entity.
// If the RoleSuiteUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteUserMutation) OldReceiverType(ctx context.Context) (v rolesuiteuser.ReceiverType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverType: %w", err)
	}
	return oldValue.ReceiverType, nil
}

// ResetReceiverType resets all changes to the "receiver_type" field.
func (m *RoleSuiteUserMutation) ResetReceiverType() {
	m.receiver_type = nil
}

// SetRoleSuiteID sets the "role_suite_id" field.
func (m *RoleSuiteUserMutation) SetRoleSuiteID(s string) {
	m.role_suite = &s
}

// RoleSuiteID returns the value of the "role_suite_id" field in the mutation.
func (m *RoleSuiteUserMutation) RoleSuiteID() (r string, exists bool) {
	v := m.role_suite
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleSuiteID returns the old "role_suite_id" field's value of the RoleSuiteUser entity.
// If the RoleSuiteUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleSuiteUserMutation) OldRoleSuiteID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleSuiteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleSuiteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleSuiteID: %w", err)
	}
	return oldValue.RoleSuiteID, nil
}

// ResetRoleSuiteID resets all changes to the "role_suite_id" field.
func (m *RoleSuiteUserMutation) ResetRoleSuiteID() {
	m.role_suite = nil
}

// ClearRoleSuite clears the "role_suite" edge to the RoleSuite entity.
func (m *RoleSuiteUserMutation) ClearRoleSuite() {
	m.clearedrole_suite = true
	m.clearedFields[rolesuiteuser.FieldRoleSuiteID] = struct{}{}
}

// RoleSuiteCleared reports if the "role_suite" edge to the RoleSuite entity was cleared.
func (m *RoleSuiteUserMutation) RoleSuiteCleared() bool {
	return m.clearedrole_suite
}

// RoleSuiteIDs returns the "role_suite" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleSuiteID instead. It exists only for internal usage by the builders.
func (m *RoleSuiteUserMutation) RoleSuiteIDs() (ids []string) {
	if id := m.role_suite; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleSuite resets all changes to the "role_suite" edge.
func (m *RoleSuiteUserMutation) ResetRoleSuite() {
	m.role_suite = nil
	m.clearedrole_suite = false
}

// Where appends a list predicates to the RoleSuiteUserMutation builder.
func (m *RoleSuiteUserMutation) Where(ps ...predicate.RoleSuiteUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleSuiteUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleSuiteUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoleSuiteUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleSuiteUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleSuiteUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoleSuiteUser).
func (m *RoleSuiteUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleSuiteUserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.approver_id != nil {
		fields = append(fields, rolesuiteuser.FieldApproverID)
	}
	if m.receiver_ref != nil {
		fields = append(fields, rolesuiteuser.FieldReceiverRef)
	}
	if m.receiver_type != nil {
		fields = append(fields, rolesuiteuser.FieldReceiverType)
	}
	if m.role_suite != nil {
		fields = append(fields, rolesuiteuser.FieldRoleSuiteID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleSuiteUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolesuiteuser.FieldApproverID:
		return m.ApproverID()
	case rolesuiteuser.FieldReceiverRef:
		return m.ReceiverRef()
	case rolesuiteuser.FieldReceiverType:
		return m.ReceiverType()
	case rolesuiteuser.FieldRoleSuiteID:
		return m.RoleSuiteID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleSuiteUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolesuiteuser.FieldApproverID:
		return m.OldApproverID(ctx)
	case rolesuiteuser.FieldReceiverRef:
		return m.OldReceiverRef(ctx)
	case rolesuiteuser.FieldReceiverType:
		return m.OldReceiverType(ctx)
	case rolesuiteuser.FieldRoleSuiteID:
		return m.OldRoleSuiteID(ctx)
	}
	return nil, fmt.Errorf("unknown RoleSuiteUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleSuiteUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolesuiteuser.FieldApproverID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	case rolesuiteuser.FieldReceiverRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverRef(v)
		return nil
	case rolesuiteuser.FieldReceiverType:
		v, ok := value.(rolesuiteuser.ReceiverType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverType(v)
		return nil
	case rolesuiteuser.FieldRoleSuiteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleSuiteID(v)
		return nil
	}
	return fmt.Errorf("unknown RoleSuiteUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleSuiteUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleSuiteUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleSuiteUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleSuiteUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleSuiteUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleSuiteUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleSuiteUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RoleSuiteUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleSuiteUserMutation) ResetField(name string) error {
	switch name {
	case rolesuiteuser.FieldApproverID:
		m.ResetApproverID()
		return nil
	case rolesuiteuser.FieldReceiverRef:
		m.ResetReceiverRef()
		return nil
	case rolesuiteuser.FieldReceiverType:
		m.ResetReceiverType()
		return nil
	case rolesuiteuser.FieldRoleSuiteID:
		m.ResetRoleSuiteID()
		return nil
	}
	return fmt.Errorf("unknown RoleSuiteUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleSuiteUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role_suite != nil {
		edges = append(edges, rolesuiteuser.EdgeRoleSuite)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleSuiteUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolesuiteuser.EdgeRoleSuite:
		if id := m.role_suite; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleSuiteUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleSuiteUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleSuiteUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole_suite {
		edges = append(edges, rolesuiteuser.EdgeRoleSuite)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleSuiteUserMutation) EdgeCleared(name string) bool {
	switch name {
	case rolesuiteuser.EdgeRoleSuite:
		return m.clearedrole_suite
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleSuiteUserMutation) ClearEdge(name string) error {
	switch name {
	case rolesuiteuser.EdgeRoleSuite:
		m.ClearRoleSuite()
		return nil
	}
	return fmt.Errorf("unknown RoleSuiteUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleSuiteUserMutation) ResetEdge(name string) error {
	switch name {
	case rolesuiteuser.EdgeRoleSuite:
		m.ResetRoleSuite()
		return nil
	}
	return fmt.Errorf("unknown RoleSuiteUser edge %s", name)
}

// RoleUserMutation represents an operation that mutates the RoleUser nodes in the graph.
type RoleUserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	approver_id   *string
	receiver_ref  *string
	receiver_type *roleuser.ReceiverType
	clearedFields map[string]struct{}
	role          *string
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*RoleUser, error)
	predicates    []predicate.RoleUser
}

var _ ent.Mutation = (*RoleUserMutation)(nil)

// roleuserOption allows management of the mutation configuration using functional options.
type roleuserOption func(*RoleUserMutation)

// newRoleUserMutation creates new mutation for the RoleUser entity.
func newRoleUserMutation(c config, op Op, opts ...roleuserOption) *RoleUserMutation {
	m := &RoleUserMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleUserID sets the ID field of the mutation.
func withRoleUserID(id int) roleuserOption {
	return func(m *RoleUserMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleUser
		)
		m.oldValue = func(ctx context.Context) (*RoleUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleUser sets the old RoleUser of the mutation.
func withRoleUser(node *RoleUser) roleuserOption {
	return func(m *RoleUserMutation) {
		m.oldValue = func(context.Context) (*RoleUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoleUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApproverID sets the "approver_id" field.
func (m *RoleUserMutation) SetApproverID(s string) {
	m.approver_id = &s
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *RoleUserMutation) ApproverID() (r string, exists bool) {
	v := m.approver_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the RoleUser entity.
// If the RoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleUserMutation) OldApproverID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *RoleUserMutation) ResetApproverID() {
	m.approver_id = nil
}

// SetReceiverRef sets the "receiver_ref" field.
func (m *RoleUserMutation) SetReceiverRef(s string) {
	m.receiver_ref = &s
}

// ReceiverRef returns the value of the "receiver_ref" field in the mutation.
func (m *RoleUserMutation) ReceiverRef() (r string, exists bool) {
	v := m.receiver_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverRef returns the old "receiver_ref" field's value of the RoleUser entity.
// If the RoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleUserMutation) OldReceiverRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverRef: %w", err)
	}
	return oldValue.ReceiverRef, nil
}

// ResetReceiverRef resets all changes to the "receiver_ref" field.
func (m *RoleUserMutation) ResetReceiverRef() {
	m.receiver_ref = nil
}

// SetReceiverType sets the "receiver_type" field.
func (m *RoleUserMutation) SetReceiverType(rt roleuser.ReceiverType) {
	m.receiver_type = &rt
}

// ReceiverType returns the value of the "receiver_type" field in the mutation.
func (m *RoleUserMutation) ReceiverType() (r roleuser.ReceiverType, exists bool) {
	v := m.receiver_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverType returns the old "receiver_type" field's value of the RoleUser entity.
// If the RoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleUserMutation) OldReceiverType(ctx context.Context) (v roleuser.ReceiverType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverType: %w", err)
	}
	return oldValue.ReceiverType, nil
}

// ResetReceiverType resets all changes to the "receiver_type" field.
func (m *RoleUserMutation) ResetReceiverType() {
	m.receiver_type = nil
}

// SetRoleID sets the "role_id" field.
func (m *RoleUserMutation) SetRoleID(s string) {
	m.role = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RoleUserMutation) RoleID() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the RoleUser entity.
// If the RoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleUserMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RoleUserMutation) ResetRoleID() {
	m.role = nil
}

// ClearRole clears the "role" edge to the Role entity.
func (m *RoleUserMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[roleuser.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *RoleUserMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *RoleUserMutation) RoleIDs() (ids []string) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *RoleUserMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the RoleUserMutation builder.
func (m *RoleUserMutation) Where(ps ...predicate.RoleUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoleUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoleUser).
func (m *RoleUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleUserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.approver_id != nil {
		fields = append(fields, roleuser.FieldApproverID)
	}
	if m.receiver_ref != nil {
		fields = append(fields, roleuser.FieldReceiverRef)
	}
	if m.receiver_type != nil {
		fields = append(fields, roleuser.FieldReceiverType)
	}
	if m.role != nil {
		fields = append(fields, roleuser.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roleuser.FieldApproverID:
		return m.ApproverID()
	case roleuser.FieldReceiverRef:
		return m.ReceiverRef()
	case roleuser.FieldReceiverType:
		return m.ReceiverType()
	case roleuser.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roleuser.FieldApproverID:
		return m.OldApproverID(ctx)
	case roleuser.FieldReceiverRef:
		return m.OldReceiverRef(ctx)
	case roleuser.FieldReceiverType:
		return m.OldReceiverType(ctx)
	case roleuser.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown RoleUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roleuser.FieldApproverID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	case roleuser.FieldReceiverRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverRef(v)
		return nil
	case roleuser.FieldReceiverType:
		v, ok := value.(roleuser.ReceiverType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverType(v)
		return nil
	case roleuser.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown RoleUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RoleUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleUserMutation) ResetField(name string) error {
	switch name {
	case roleuser.FieldApproverID:
		m.ResetApproverID()
		return nil
	case roleuser.FieldReceiverRef:
		m.ResetReceiverRef()
		return nil
	case roleuser.FieldReceiverType:
		m.ResetReceiverType()
		return nil
	case roleuser.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown RoleUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role != nil {
		edges = append(edges, roleuser.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roleuser.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole {
		edges = append(edges, roleuser.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleUserMutation) EdgeCleared(name string) bool {
	switch name {
	case roleuser.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleUserMutation) ClearEdge(name string) error {
	switch name {
	case roleuser.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown RoleUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleUserMutation) ResetEdge(name string) error {
	switch name {
	case roleuser.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown RoleUser edge %s", name)
}
