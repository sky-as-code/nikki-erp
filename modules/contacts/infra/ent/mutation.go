// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/sky-as-code/nikki-erp/modules/contacts/domain"
	"github.com/sky-as-code/nikki-erp/modules/contacts/infra/ent/commchannel"
	"github.com/sky-as-code/nikki-erp/modules/contacts/infra/ent/party"
	"github.com/sky-as-code/nikki-erp/modules/contacts/infra/ent/predicate"
	"github.com/sky-as-code/nikki-erp/modules/contacts/infra/ent/relationship"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCommChannel  = "CommChannel"
	TypeParty        = "Party"
	TypeRelationship = "Relationship"
)

// CommChannelMutation represents an operation that mutates the CommChannel nodes in the graph.
type CommChannelMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	deleted_by    *string
	deleted_at    *time.Time
	etag          *string
	note          *string
	_type         *commchannel.Type
	updated_at    *time.Time
	value         *string
	value_json    *domain.ValueJsonData
	clearedFields map[string]struct{}
	party         *string
	clearedparty  bool
	done          bool
	oldValue      func(context.Context) (*CommChannel, error)
	predicates    []predicate.CommChannel
}

var _ ent.Mutation = (*CommChannelMutation)(nil)

// commchannelOption allows management of the mutation configuration using functional options.
type commchannelOption func(*CommChannelMutation)

// newCommChannelMutation creates new mutation for the CommChannel entity.
func newCommChannelMutation(c config, op Op, opts ...commchannelOption) *CommChannelMutation {
	m := &CommChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeCommChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommChannelID sets the ID field of the mutation.
func withCommChannelID(id string) commchannelOption {
	return func(m *CommChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *CommChannel
		)
		m.oldValue = func(ctx context.Context) (*CommChannel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommChannel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommChannel sets the old CommChannel of the mutation.
func withCommChannel(node *CommChannel) commchannelOption {
	return func(m *CommChannelMutation) {
		m.oldValue = func(context.Context) (*CommChannel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommChannel entities.
func (m *CommChannelMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommChannelMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommChannelMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommChannel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommChannel entity.
// If the CommChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *CommChannelMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *CommChannelMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the CommChannel entity.
// If the CommChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommChannelMutation) OldDeletedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *CommChannelMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[commchannel.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *CommChannelMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[commchannel.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *CommChannelMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, commchannel.FieldDeletedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommChannelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommChannelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CommChannel entity.
// If the CommChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommChannelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CommChannelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[commchannel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CommChannelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[commchannel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, commchannel.FieldDeletedAt)
}

// SetEtag sets the "etag" field.
func (m *CommChannelMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *CommChannelMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the CommChannel entity.
// If the CommChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommChannelMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *CommChannelMutation) ResetEtag() {
	m.etag = nil
}

// SetNote sets the "note" field.
func (m *CommChannelMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *CommChannelMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the CommChannel entity.
// If the CommChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommChannelMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *CommChannelMutation) ClearNote() {
	m.note = nil
	m.clearedFields[commchannel.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *CommChannelMutation) NoteCleared() bool {
	_, ok := m.clearedFields[commchannel.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *CommChannelMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, commchannel.FieldNote)
}

// SetPartyID sets the "party_id" field.
func (m *CommChannelMutation) SetPartyID(s string) {
	m.party = &s
}

// PartyID returns the value of the "party_id" field in the mutation.
func (m *CommChannelMutation) PartyID() (r string, exists bool) {
	v := m.party
	if v == nil {
		return
	}
	return *v, true
}

// OldPartyID returns the old "party_id" field's value of the CommChannel entity.
// If the CommChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommChannelMutation) OldPartyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartyID: %w", err)
	}
	return oldValue.PartyID, nil
}

// ResetPartyID resets all changes to the "party_id" field.
func (m *CommChannelMutation) ResetPartyID() {
	m.party = nil
}

// SetType sets the "type" field.
func (m *CommChannelMutation) SetType(c commchannel.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CommChannelMutation) GetType() (r commchannel.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CommChannel entity.
// If the CommChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommChannelMutation) OldType(ctx context.Context) (v commchannel.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CommChannelMutation) ResetType() {
	m._type = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommChannel entity.
// If the CommChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommChannelMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CommChannelMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[commchannel.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CommChannelMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[commchannel.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, commchannel.FieldUpdatedAt)
}

// SetValue sets the "value" field.
func (m *CommChannelMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *CommChannelMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the CommChannel entity.
// If the CommChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommChannelMutation) OldValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *CommChannelMutation) ClearValue() {
	m.value = nil
	m.clearedFields[commchannel.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *CommChannelMutation) ValueCleared() bool {
	_, ok := m.clearedFields[commchannel.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *CommChannelMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, commchannel.FieldValue)
}

// SetValueJSON sets the "value_json" field.
func (m *CommChannelMutation) SetValueJSON(djd domain.ValueJsonData) {
	m.value_json = &djd
}

// ValueJSON returns the value of the "value_json" field in the mutation.
func (m *CommChannelMutation) ValueJSON() (r domain.ValueJsonData, exists bool) {
	v := m.value_json
	if v == nil {
		return
	}
	return *v, true
}

// OldValueJSON returns the old "value_json" field's value of the CommChannel entity.
// If the CommChannel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommChannelMutation) OldValueJSON(ctx context.Context) (v domain.ValueJsonData, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueJSON: %w", err)
	}
	return oldValue.ValueJSON, nil
}

// ClearValueJSON clears the value of the "value_json" field.
func (m *CommChannelMutation) ClearValueJSON() {
	m.value_json = nil
	m.clearedFields[commchannel.FieldValueJSON] = struct{}{}
}

// ValueJSONCleared returns if the "value_json" field was cleared in this mutation.
func (m *CommChannelMutation) ValueJSONCleared() bool {
	_, ok := m.clearedFields[commchannel.FieldValueJSON]
	return ok
}

// ResetValueJSON resets all changes to the "value_json" field.
func (m *CommChannelMutation) ResetValueJSON() {
	m.value_json = nil
	delete(m.clearedFields, commchannel.FieldValueJSON)
}

// ClearParty clears the "party" edge to the Party entity.
func (m *CommChannelMutation) ClearParty() {
	m.clearedparty = true
	m.clearedFields[commchannel.FieldPartyID] = struct{}{}
}

// PartyCleared reports if the "party" edge to the Party entity was cleared.
func (m *CommChannelMutation) PartyCleared() bool {
	return m.clearedparty
}

// PartyIDs returns the "party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyID instead. It exists only for internal usage by the builders.
func (m *CommChannelMutation) PartyIDs() (ids []string) {
	if id := m.party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParty resets all changes to the "party" edge.
func (m *CommChannelMutation) ResetParty() {
	m.party = nil
	m.clearedparty = false
}

// Where appends a list predicates to the CommChannelMutation builder.
func (m *CommChannelMutation) Where(ps ...predicate.CommChannel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommChannel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommChannel).
func (m *CommChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommChannelMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, commchannel.FieldCreatedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, commchannel.FieldDeletedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, commchannel.FieldDeletedAt)
	}
	if m.etag != nil {
		fields = append(fields, commchannel.FieldEtag)
	}
	if m.note != nil {
		fields = append(fields, commchannel.FieldNote)
	}
	if m.party != nil {
		fields = append(fields, commchannel.FieldPartyID)
	}
	if m._type != nil {
		fields = append(fields, commchannel.FieldType)
	}
	if m.updated_at != nil {
		fields = append(fields, commchannel.FieldUpdatedAt)
	}
	if m.value != nil {
		fields = append(fields, commchannel.FieldValue)
	}
	if m.value_json != nil {
		fields = append(fields, commchannel.FieldValueJSON)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commchannel.FieldCreatedAt:
		return m.CreatedAt()
	case commchannel.FieldDeletedBy:
		return m.DeletedBy()
	case commchannel.FieldDeletedAt:
		return m.DeletedAt()
	case commchannel.FieldEtag:
		return m.Etag()
	case commchannel.FieldNote:
		return m.Note()
	case commchannel.FieldPartyID:
		return m.PartyID()
	case commchannel.FieldType:
		return m.GetType()
	case commchannel.FieldUpdatedAt:
		return m.UpdatedAt()
	case commchannel.FieldValue:
		return m.Value()
	case commchannel.FieldValueJSON:
		return m.ValueJSON()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commchannel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commchannel.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case commchannel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case commchannel.FieldEtag:
		return m.OldEtag(ctx)
	case commchannel.FieldNote:
		return m.OldNote(ctx)
	case commchannel.FieldPartyID:
		return m.OldPartyID(ctx)
	case commchannel.FieldType:
		return m.OldType(ctx)
	case commchannel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commchannel.FieldValue:
		return m.OldValue(ctx)
	case commchannel.FieldValueJSON:
		return m.OldValueJSON(ctx)
	}
	return nil, fmt.Errorf("unknown CommChannel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commchannel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commchannel.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case commchannel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case commchannel.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case commchannel.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case commchannel.FieldPartyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartyID(v)
		return nil
	case commchannel.FieldType:
		v, ok := value.(commchannel.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case commchannel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commchannel.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case commchannel.FieldValueJSON:
		v, ok := value.(domain.ValueJsonData)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueJSON(v)
		return nil
	}
	return fmt.Errorf("unknown CommChannel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommChannelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommChannelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CommChannel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commchannel.FieldDeletedBy) {
		fields = append(fields, commchannel.FieldDeletedBy)
	}
	if m.FieldCleared(commchannel.FieldDeletedAt) {
		fields = append(fields, commchannel.FieldDeletedAt)
	}
	if m.FieldCleared(commchannel.FieldNote) {
		fields = append(fields, commchannel.FieldNote)
	}
	if m.FieldCleared(commchannel.FieldUpdatedAt) {
		fields = append(fields, commchannel.FieldUpdatedAt)
	}
	if m.FieldCleared(commchannel.FieldValue) {
		fields = append(fields, commchannel.FieldValue)
	}
	if m.FieldCleared(commchannel.FieldValueJSON) {
		fields = append(fields, commchannel.FieldValueJSON)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommChannelMutation) ClearField(name string) error {
	switch name {
	case commchannel.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case commchannel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case commchannel.FieldNote:
		m.ClearNote()
		return nil
	case commchannel.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case commchannel.FieldValue:
		m.ClearValue()
		return nil
	case commchannel.FieldValueJSON:
		m.ClearValueJSON()
		return nil
	}
	return fmt.Errorf("unknown CommChannel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommChannelMutation) ResetField(name string) error {
	switch name {
	case commchannel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commchannel.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case commchannel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case commchannel.FieldEtag:
		m.ResetEtag()
		return nil
	case commchannel.FieldNote:
		m.ResetNote()
		return nil
	case commchannel.FieldPartyID:
		m.ResetPartyID()
		return nil
	case commchannel.FieldType:
		m.ResetType()
		return nil
	case commchannel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commchannel.FieldValue:
		m.ResetValue()
		return nil
	case commchannel.FieldValueJSON:
		m.ResetValueJSON()
		return nil
	}
	return fmt.Errorf("unknown CommChannel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.party != nil {
		edges = append(edges, commchannel.EdgeParty)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commchannel.EdgeParty:
		if id := m.party; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommChannelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparty {
		edges = append(edges, commchannel.EdgeParty)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case commchannel.EdgeParty:
		return m.clearedparty
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommChannelMutation) ClearEdge(name string) error {
	switch name {
	case commchannel.EdgeParty:
		m.ClearParty()
		return nil
	}
	return fmt.Errorf("unknown CommChannel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommChannelMutation) ResetEdge(name string) error {
	switch name {
	case commchannel.EdgeParty:
		m.ResetParty()
		return nil
	}
	return fmt.Errorf("unknown CommChannel edge %s", name)
}

// PartyMutation represents an operation that mutates the Party nodes in the graph.
type PartyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	avatar_url           *string
	created_at           *time.Time
	deleted_at           *time.Time
	deleted_by           *string
	display_name         *string
	etag                 *string
	job_position         *string
	language_id          *string
	legal_address        *string
	legal_name           *string
	nationality_id       *string
	note                 *string
	tax_id               *string
	title                *party.Title
	_type                *string
	updated_at           *time.Time
	website              *string
	clearedFields        map[string]struct{}
	comm_channels        map[string]struct{}
	removedcomm_channels map[string]struct{}
	clearedcomm_channels bool
	relationships        map[string]struct{}
	removedrelationships map[string]struct{}
	clearedrelationships bool
	done                 bool
	oldValue             func(context.Context) (*Party, error)
	predicates           []predicate.Party
}

var _ ent.Mutation = (*PartyMutation)(nil)

// partyOption allows management of the mutation configuration using functional options.
type partyOption func(*PartyMutation)

// newPartyMutation creates new mutation for the Party entity.
func newPartyMutation(c config, op Op, opts ...partyOption) *PartyMutation {
	m := &PartyMutation{
		config:        c,
		op:            op,
		typ:           TypeParty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartyID sets the ID field of the mutation.
func withPartyID(id string) partyOption {
	return func(m *PartyMutation) {
		var (
			err   error
			once  sync.Once
			value *Party
		)
		m.oldValue = func(ctx context.Context) (*Party, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Party.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParty sets the old Party of the mutation.
func withParty(node *Party) partyOption {
	return func(m *PartyMutation) {
		m.oldValue = func(context.Context) (*Party, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Party entities.
func (m *PartyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Party.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAvatarURL sets the "avatar_url" field.
func (m *PartyMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *PartyMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldAvatarURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *PartyMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[party.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *PartyMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[party.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *PartyMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, party.FieldAvatarURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *PartyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PartyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PartyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PartyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[party.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PartyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[party.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PartyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, party.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PartyMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PartyMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldDeletedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PartyMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[party.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PartyMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[party.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PartyMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, party.FieldDeletedBy)
}

// SetDisplayName sets the "display_name" field.
func (m *PartyMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *PartyMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *PartyMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetEtag sets the "etag" field.
func (m *PartyMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *PartyMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *PartyMutation) ResetEtag() {
	m.etag = nil
}

// SetJobPosition sets the "job_position" field.
func (m *PartyMutation) SetJobPosition(s string) {
	m.job_position = &s
}

// JobPosition returns the value of the "job_position" field in the mutation.
func (m *PartyMutation) JobPosition() (r string, exists bool) {
	v := m.job_position
	if v == nil {
		return
	}
	return *v, true
}

// OldJobPosition returns the old "job_position" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldJobPosition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobPosition: %w", err)
	}
	return oldValue.JobPosition, nil
}

// ClearJobPosition clears the value of the "job_position" field.
func (m *PartyMutation) ClearJobPosition() {
	m.job_position = nil
	m.clearedFields[party.FieldJobPosition] = struct{}{}
}

// JobPositionCleared returns if the "job_position" field was cleared in this mutation.
func (m *PartyMutation) JobPositionCleared() bool {
	_, ok := m.clearedFields[party.FieldJobPosition]
	return ok
}

// ResetJobPosition resets all changes to the "job_position" field.
func (m *PartyMutation) ResetJobPosition() {
	m.job_position = nil
	delete(m.clearedFields, party.FieldJobPosition)
}

// SetLanguageID sets the "language_id" field.
func (m *PartyMutation) SetLanguageID(s string) {
	m.language_id = &s
}

// LanguageID returns the value of the "language_id" field in the mutation.
func (m *PartyMutation) LanguageID() (r string, exists bool) {
	v := m.language_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageID returns the old "language_id" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldLanguageID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageID: %w", err)
	}
	return oldValue.LanguageID, nil
}

// ClearLanguageID clears the value of the "language_id" field.
func (m *PartyMutation) ClearLanguageID() {
	m.language_id = nil
	m.clearedFields[party.FieldLanguageID] = struct{}{}
}

// LanguageIDCleared returns if the "language_id" field was cleared in this mutation.
func (m *PartyMutation) LanguageIDCleared() bool {
	_, ok := m.clearedFields[party.FieldLanguageID]
	return ok
}

// ResetLanguageID resets all changes to the "language_id" field.
func (m *PartyMutation) ResetLanguageID() {
	m.language_id = nil
	delete(m.clearedFields, party.FieldLanguageID)
}

// SetLegalAddress sets the "legal_address" field.
func (m *PartyMutation) SetLegalAddress(s string) {
	m.legal_address = &s
}

// LegalAddress returns the value of the "legal_address" field in the mutation.
func (m *PartyMutation) LegalAddress() (r string, exists bool) {
	v := m.legal_address
	if v == nil {
		return
	}
	return *v, true
}

// OldLegalAddress returns the old "legal_address" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldLegalAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegalAddress: %w", err)
	}
	return oldValue.LegalAddress, nil
}

// ClearLegalAddress clears the value of the "legal_address" field.
func (m *PartyMutation) ClearLegalAddress() {
	m.legal_address = nil
	m.clearedFields[party.FieldLegalAddress] = struct{}{}
}

// LegalAddressCleared returns if the "legal_address" field was cleared in this mutation.
func (m *PartyMutation) LegalAddressCleared() bool {
	_, ok := m.clearedFields[party.FieldLegalAddress]
	return ok
}

// ResetLegalAddress resets all changes to the "legal_address" field.
func (m *PartyMutation) ResetLegalAddress() {
	m.legal_address = nil
	delete(m.clearedFields, party.FieldLegalAddress)
}

// SetLegalName sets the "legal_name" field.
func (m *PartyMutation) SetLegalName(s string) {
	m.legal_name = &s
}

// LegalName returns the value of the "legal_name" field in the mutation.
func (m *PartyMutation) LegalName() (r string, exists bool) {
	v := m.legal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLegalName returns the old "legal_name" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldLegalName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegalName: %w", err)
	}
	return oldValue.LegalName, nil
}

// ClearLegalName clears the value of the "legal_name" field.
func (m *PartyMutation) ClearLegalName() {
	m.legal_name = nil
	m.clearedFields[party.FieldLegalName] = struct{}{}
}

// LegalNameCleared returns if the "legal_name" field was cleared in this mutation.
func (m *PartyMutation) LegalNameCleared() bool {
	_, ok := m.clearedFields[party.FieldLegalName]
	return ok
}

// ResetLegalName resets all changes to the "legal_name" field.
func (m *PartyMutation) ResetLegalName() {
	m.legal_name = nil
	delete(m.clearedFields, party.FieldLegalName)
}

// SetNationalityID sets the "nationality_id" field.
func (m *PartyMutation) SetNationalityID(s string) {
	m.nationality_id = &s
}

// NationalityID returns the value of the "nationality_id" field in the mutation.
func (m *PartyMutation) NationalityID() (r string, exists bool) {
	v := m.nationality_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNationalityID returns the old "nationality_id" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldNationalityID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNationalityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNationalityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNationalityID: %w", err)
	}
	return oldValue.NationalityID, nil
}

// ClearNationalityID clears the value of the "nationality_id" field.
func (m *PartyMutation) ClearNationalityID() {
	m.nationality_id = nil
	m.clearedFields[party.FieldNationalityID] = struct{}{}
}

// NationalityIDCleared returns if the "nationality_id" field was cleared in this mutation.
func (m *PartyMutation) NationalityIDCleared() bool {
	_, ok := m.clearedFields[party.FieldNationalityID]
	return ok
}

// ResetNationalityID resets all changes to the "nationality_id" field.
func (m *PartyMutation) ResetNationalityID() {
	m.nationality_id = nil
	delete(m.clearedFields, party.FieldNationalityID)
}

// SetNote sets the "note" field.
func (m *PartyMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *PartyMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *PartyMutation) ClearNote() {
	m.note = nil
	m.clearedFields[party.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *PartyMutation) NoteCleared() bool {
	_, ok := m.clearedFields[party.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *PartyMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, party.FieldNote)
}

// SetTaxID sets the "tax_id" field.
func (m *PartyMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *PartyMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldTaxID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ClearTaxID clears the value of the "tax_id" field.
func (m *PartyMutation) ClearTaxID() {
	m.tax_id = nil
	m.clearedFields[party.FieldTaxID] = struct{}{}
}

// TaxIDCleared returns if the "tax_id" field was cleared in this mutation.
func (m *PartyMutation) TaxIDCleared() bool {
	_, ok := m.clearedFields[party.FieldTaxID]
	return ok
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *PartyMutation) ResetTaxID() {
	m.tax_id = nil
	delete(m.clearedFields, party.FieldTaxID)
}

// SetTitle sets the "title" field.
func (m *PartyMutation) SetTitle(pa party.Title) {
	m.title = &pa
}

// Title returns the value of the "title" field in the mutation.
func (m *PartyMutation) Title() (r party.Title, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldTitle(ctx context.Context) (v *party.Title, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *PartyMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[party.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *PartyMutation) TitleCleared() bool {
	_, ok := m.clearedFields[party.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *PartyMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, party.FieldTitle)
}

// SetType sets the "type" field.
func (m *PartyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PartyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PartyMutation) ResetType() {
	m._type = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PartyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[party.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PartyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[party.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, party.FieldUpdatedAt)
}

// SetWebsite sets the "website" field.
func (m *PartyMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *PartyMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldWebsite(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *PartyMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[party.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *PartyMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[party.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *PartyMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, party.FieldWebsite)
}

// AddCommChannelIDs adds the "comm_channels" edge to the CommChannel entity by ids.
func (m *PartyMutation) AddCommChannelIDs(ids ...string) {
	if m.comm_channels == nil {
		m.comm_channels = make(map[string]struct{})
	}
	for i := range ids {
		m.comm_channels[ids[i]] = struct{}{}
	}
}

// ClearCommChannels clears the "comm_channels" edge to the CommChannel entity.
func (m *PartyMutation) ClearCommChannels() {
	m.clearedcomm_channels = true
}

// CommChannelsCleared reports if the "comm_channels" edge to the CommChannel entity was cleared.
func (m *PartyMutation) CommChannelsCleared() bool {
	return m.clearedcomm_channels
}

// RemoveCommChannelIDs removes the "comm_channels" edge to the CommChannel entity by IDs.
func (m *PartyMutation) RemoveCommChannelIDs(ids ...string) {
	if m.removedcomm_channels == nil {
		m.removedcomm_channels = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comm_channels, ids[i])
		m.removedcomm_channels[ids[i]] = struct{}{}
	}
}

// RemovedCommChannels returns the removed IDs of the "comm_channels" edge to the CommChannel entity.
func (m *PartyMutation) RemovedCommChannelsIDs() (ids []string) {
	for id := range m.removedcomm_channels {
		ids = append(ids, id)
	}
	return
}

// CommChannelsIDs returns the "comm_channels" edge IDs in the mutation.
func (m *PartyMutation) CommChannelsIDs() (ids []string) {
	for id := range m.comm_channels {
		ids = append(ids, id)
	}
	return
}

// ResetCommChannels resets all changes to the "comm_channels" edge.
func (m *PartyMutation) ResetCommChannels() {
	m.comm_channels = nil
	m.clearedcomm_channels = false
	m.removedcomm_channels = nil
}

// AddRelationshipIDs adds the "relationships" edge to the Relationship entity by ids.
func (m *PartyMutation) AddRelationshipIDs(ids ...string) {
	if m.relationships == nil {
		m.relationships = make(map[string]struct{})
	}
	for i := range ids {
		m.relationships[ids[i]] = struct{}{}
	}
}

// ClearRelationships clears the "relationships" edge to the Relationship entity.
func (m *PartyMutation) ClearRelationships() {
	m.clearedrelationships = true
}

// RelationshipsCleared reports if the "relationships" edge to the Relationship entity was cleared.
func (m *PartyMutation) RelationshipsCleared() bool {
	return m.clearedrelationships
}

// RemoveRelationshipIDs removes the "relationships" edge to the Relationship entity by IDs.
func (m *PartyMutation) RemoveRelationshipIDs(ids ...string) {
	if m.removedrelationships == nil {
		m.removedrelationships = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.relationships, ids[i])
		m.removedrelationships[ids[i]] = struct{}{}
	}
}

// RemovedRelationships returns the removed IDs of the "relationships" edge to the Relationship entity.
func (m *PartyMutation) RemovedRelationshipsIDs() (ids []string) {
	for id := range m.removedrelationships {
		ids = append(ids, id)
	}
	return
}

// RelationshipsIDs returns the "relationships" edge IDs in the mutation.
func (m *PartyMutation) RelationshipsIDs() (ids []string) {
	for id := range m.relationships {
		ids = append(ids, id)
	}
	return
}

// ResetRelationships resets all changes to the "relationships" edge.
func (m *PartyMutation) ResetRelationships() {
	m.relationships = nil
	m.clearedrelationships = false
	m.removedrelationships = nil
}

// Where appends a list predicates to the PartyMutation builder.
func (m *PartyMutation) Where(ps ...predicate.Party) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Party, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Party).
func (m *PartyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartyMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.avatar_url != nil {
		fields = append(fields, party.FieldAvatarURL)
	}
	if m.created_at != nil {
		fields = append(fields, party.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, party.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, party.FieldDeletedBy)
	}
	if m.display_name != nil {
		fields = append(fields, party.FieldDisplayName)
	}
	if m.etag != nil {
		fields = append(fields, party.FieldEtag)
	}
	if m.job_position != nil {
		fields = append(fields, party.FieldJobPosition)
	}
	if m.language_id != nil {
		fields = append(fields, party.FieldLanguageID)
	}
	if m.legal_address != nil {
		fields = append(fields, party.FieldLegalAddress)
	}
	if m.legal_name != nil {
		fields = append(fields, party.FieldLegalName)
	}
	if m.nationality_id != nil {
		fields = append(fields, party.FieldNationalityID)
	}
	if m.note != nil {
		fields = append(fields, party.FieldNote)
	}
	if m.tax_id != nil {
		fields = append(fields, party.FieldTaxID)
	}
	if m.title != nil {
		fields = append(fields, party.FieldTitle)
	}
	if m._type != nil {
		fields = append(fields, party.FieldType)
	}
	if m.updated_at != nil {
		fields = append(fields, party.FieldUpdatedAt)
	}
	if m.website != nil {
		fields = append(fields, party.FieldWebsite)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case party.FieldAvatarURL:
		return m.AvatarURL()
	case party.FieldCreatedAt:
		return m.CreatedAt()
	case party.FieldDeletedAt:
		return m.DeletedAt()
	case party.FieldDeletedBy:
		return m.DeletedBy()
	case party.FieldDisplayName:
		return m.DisplayName()
	case party.FieldEtag:
		return m.Etag()
	case party.FieldJobPosition:
		return m.JobPosition()
	case party.FieldLanguageID:
		return m.LanguageID()
	case party.FieldLegalAddress:
		return m.LegalAddress()
	case party.FieldLegalName:
		return m.LegalName()
	case party.FieldNationalityID:
		return m.NationalityID()
	case party.FieldNote:
		return m.Note()
	case party.FieldTaxID:
		return m.TaxID()
	case party.FieldTitle:
		return m.Title()
	case party.FieldType:
		return m.GetType()
	case party.FieldUpdatedAt:
		return m.UpdatedAt()
	case party.FieldWebsite:
		return m.Website()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case party.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case party.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case party.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case party.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case party.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case party.FieldEtag:
		return m.OldEtag(ctx)
	case party.FieldJobPosition:
		return m.OldJobPosition(ctx)
	case party.FieldLanguageID:
		return m.OldLanguageID(ctx)
	case party.FieldLegalAddress:
		return m.OldLegalAddress(ctx)
	case party.FieldLegalName:
		return m.OldLegalName(ctx)
	case party.FieldNationalityID:
		return m.OldNationalityID(ctx)
	case party.FieldNote:
		return m.OldNote(ctx)
	case party.FieldTaxID:
		return m.OldTaxID(ctx)
	case party.FieldTitle:
		return m.OldTitle(ctx)
	case party.FieldType:
		return m.OldType(ctx)
	case party.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case party.FieldWebsite:
		return m.OldWebsite(ctx)
	}
	return nil, fmt.Errorf("unknown Party field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case party.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case party.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case party.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case party.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case party.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case party.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case party.FieldJobPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobPosition(v)
		return nil
	case party.FieldLanguageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageID(v)
		return nil
	case party.FieldLegalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegalAddress(v)
		return nil
	case party.FieldLegalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegalName(v)
		return nil
	case party.FieldNationalityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNationalityID(v)
		return nil
	case party.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case party.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case party.FieldTitle:
		v, ok := value.(party.Title)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case party.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case party.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case party.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	}
	return fmt.Errorf("unknown Party field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Party numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(party.FieldAvatarURL) {
		fields = append(fields, party.FieldAvatarURL)
	}
	if m.FieldCleared(party.FieldDeletedAt) {
		fields = append(fields, party.FieldDeletedAt)
	}
	if m.FieldCleared(party.FieldDeletedBy) {
		fields = append(fields, party.FieldDeletedBy)
	}
	if m.FieldCleared(party.FieldJobPosition) {
		fields = append(fields, party.FieldJobPosition)
	}
	if m.FieldCleared(party.FieldLanguageID) {
		fields = append(fields, party.FieldLanguageID)
	}
	if m.FieldCleared(party.FieldLegalAddress) {
		fields = append(fields, party.FieldLegalAddress)
	}
	if m.FieldCleared(party.FieldLegalName) {
		fields = append(fields, party.FieldLegalName)
	}
	if m.FieldCleared(party.FieldNationalityID) {
		fields = append(fields, party.FieldNationalityID)
	}
	if m.FieldCleared(party.FieldNote) {
		fields = append(fields, party.FieldNote)
	}
	if m.FieldCleared(party.FieldTaxID) {
		fields = append(fields, party.FieldTaxID)
	}
	if m.FieldCleared(party.FieldTitle) {
		fields = append(fields, party.FieldTitle)
	}
	if m.FieldCleared(party.FieldUpdatedAt) {
		fields = append(fields, party.FieldUpdatedAt)
	}
	if m.FieldCleared(party.FieldWebsite) {
		fields = append(fields, party.FieldWebsite)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartyMutation) ClearField(name string) error {
	switch name {
	case party.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case party.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case party.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case party.FieldJobPosition:
		m.ClearJobPosition()
		return nil
	case party.FieldLanguageID:
		m.ClearLanguageID()
		return nil
	case party.FieldLegalAddress:
		m.ClearLegalAddress()
		return nil
	case party.FieldLegalName:
		m.ClearLegalName()
		return nil
	case party.FieldNationalityID:
		m.ClearNationalityID()
		return nil
	case party.FieldNote:
		m.ClearNote()
		return nil
	case party.FieldTaxID:
		m.ClearTaxID()
		return nil
	case party.FieldTitle:
		m.ClearTitle()
		return nil
	case party.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case party.FieldWebsite:
		m.ClearWebsite()
		return nil
	}
	return fmt.Errorf("unknown Party nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartyMutation) ResetField(name string) error {
	switch name {
	case party.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case party.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case party.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case party.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case party.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case party.FieldEtag:
		m.ResetEtag()
		return nil
	case party.FieldJobPosition:
		m.ResetJobPosition()
		return nil
	case party.FieldLanguageID:
		m.ResetLanguageID()
		return nil
	case party.FieldLegalAddress:
		m.ResetLegalAddress()
		return nil
	case party.FieldLegalName:
		m.ResetLegalName()
		return nil
	case party.FieldNationalityID:
		m.ResetNationalityID()
		return nil
	case party.FieldNote:
		m.ResetNote()
		return nil
	case party.FieldTaxID:
		m.ResetTaxID()
		return nil
	case party.FieldTitle:
		m.ResetTitle()
		return nil
	case party.FieldType:
		m.ResetType()
		return nil
	case party.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case party.FieldWebsite:
		m.ResetWebsite()
		return nil
	}
	return fmt.Errorf("unknown Party field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.comm_channels != nil {
		edges = append(edges, party.EdgeCommChannels)
	}
	if m.relationships != nil {
		edges = append(edges, party.EdgeRelationships)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case party.EdgeCommChannels:
		ids := make([]ent.Value, 0, len(m.comm_channels))
		for id := range m.comm_channels {
			ids = append(ids, id)
		}
		return ids
	case party.EdgeRelationships:
		ids := make([]ent.Value, 0, len(m.relationships))
		for id := range m.relationships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcomm_channels != nil {
		edges = append(edges, party.EdgeCommChannels)
	}
	if m.removedrelationships != nil {
		edges = append(edges, party.EdgeRelationships)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case party.EdgeCommChannels:
		ids := make([]ent.Value, 0, len(m.removedcomm_channels))
		for id := range m.removedcomm_channels {
			ids = append(ids, id)
		}
		return ids
	case party.EdgeRelationships:
		ids := make([]ent.Value, 0, len(m.removedrelationships))
		for id := range m.removedrelationships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomm_channels {
		edges = append(edges, party.EdgeCommChannels)
	}
	if m.clearedrelationships {
		edges = append(edges, party.EdgeRelationships)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartyMutation) EdgeCleared(name string) bool {
	switch name {
	case party.EdgeCommChannels:
		return m.clearedcomm_channels
	case party.EdgeRelationships:
		return m.clearedrelationships
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Party unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartyMutation) ResetEdge(name string) error {
	switch name {
	case party.EdgeCommChannels:
		m.ResetCommChannels()
		return nil
	case party.EdgeRelationships:
		m.ResetRelationships()
		return nil
	}
	return fmt.Errorf("unknown Party edge %s", name)
}

// RelationshipMutation represents an operation that mutates the Relationship nodes in the graph.
type RelationshipMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	deleted_at    *time.Time
	deleted_by    *string
	etag          *string
	note          *string
	_type         *relationship.Type
	updated_at    *time.Time
	clearedFields map[string]struct{}
	party         *string
	clearedparty  bool
	done          bool
	oldValue      func(context.Context) (*Relationship, error)
	predicates    []predicate.Relationship
}

var _ ent.Mutation = (*RelationshipMutation)(nil)

// relationshipOption allows management of the mutation configuration using functional options.
type relationshipOption func(*RelationshipMutation)

// newRelationshipMutation creates new mutation for the Relationship entity.
func newRelationshipMutation(c config, op Op, opts ...relationshipOption) *RelationshipMutation {
	m := &RelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRelationshipID sets the ID field of the mutation.
func withRelationshipID(id string) relationshipOption {
	return func(m *RelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Relationship
		)
		m.oldValue = func(ctx context.Context) (*Relationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Relationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRelationship sets the old Relationship of the mutation.
func withRelationship(node *Relationship) relationshipOption {
	return func(m *RelationshipMutation) {
		m.oldValue = func(context.Context) (*Relationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Relationship entities.
func (m *RelationshipMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RelationshipMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RelationshipMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Relationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RelationshipMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RelationshipMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RelationshipMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[relationship.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RelationshipMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[relationship.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RelationshipMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, relationship.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RelationshipMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RelationshipMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldDeletedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RelationshipMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[relationship.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RelationshipMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[relationship.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RelationshipMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, relationship.FieldDeletedBy)
}

// SetEtag sets the "etag" field.
func (m *RelationshipMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *RelationshipMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *RelationshipMutation) ResetEtag() {
	m.etag = nil
}

// SetNote sets the "note" field.
func (m *RelationshipMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *RelationshipMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *RelationshipMutation) ClearNote() {
	m.note = nil
	m.clearedFields[relationship.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *RelationshipMutation) NoteCleared() bool {
	_, ok := m.clearedFields[relationship.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *RelationshipMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, relationship.FieldNote)
}

// SetTargetPartyID sets the "target_party_id" field.
func (m *RelationshipMutation) SetTargetPartyID(s string) {
	m.party = &s
}

// TargetPartyID returns the value of the "target_party_id" field in the mutation.
func (m *RelationshipMutation) TargetPartyID() (r string, exists bool) {
	v := m.party
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetPartyID returns the old "target_party_id" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldTargetPartyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetPartyID: %w", err)
	}
	return oldValue.TargetPartyID, nil
}

// ResetTargetPartyID resets all changes to the "target_party_id" field.
func (m *RelationshipMutation) ResetTargetPartyID() {
	m.party = nil
}

// SetType sets the "type" field.
func (m *RelationshipMutation) SetType(r relationship.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RelationshipMutation) GetType() (r relationship.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldType(ctx context.Context) (v relationship.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RelationshipMutation) ResetType() {
	m._type = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RelationshipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RelationshipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Relationship entity.
// If the Relationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationshipMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RelationshipMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[relationship.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RelationshipMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[relationship.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RelationshipMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, relationship.FieldUpdatedAt)
}

// SetPartyID sets the "party" edge to the Party entity by id.
func (m *RelationshipMutation) SetPartyID(id string) {
	m.party = &id
}

// ClearParty clears the "party" edge to the Party entity.
func (m *RelationshipMutation) ClearParty() {
	m.clearedparty = true
	m.clearedFields[relationship.FieldTargetPartyID] = struct{}{}
}

// PartyCleared reports if the "party" edge to the Party entity was cleared.
func (m *RelationshipMutation) PartyCleared() bool {
	return m.clearedparty
}

// PartyID returns the "party" edge ID in the mutation.
func (m *RelationshipMutation) PartyID() (id string, exists bool) {
	if m.party != nil {
		return *m.party, true
	}
	return
}

// PartyIDs returns the "party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyID instead. It exists only for internal usage by the builders.
func (m *RelationshipMutation) PartyIDs() (ids []string) {
	if id := m.party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParty resets all changes to the "party" edge.
func (m *RelationshipMutation) ResetParty() {
	m.party = nil
	m.clearedparty = false
}

// Where appends a list predicates to the RelationshipMutation builder.
func (m *RelationshipMutation) Where(ps ...predicate.Relationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Relationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Relationship).
func (m *RelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RelationshipMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, relationship.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, relationship.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, relationship.FieldDeletedBy)
	}
	if m.etag != nil {
		fields = append(fields, relationship.FieldEtag)
	}
	if m.note != nil {
		fields = append(fields, relationship.FieldNote)
	}
	if m.party != nil {
		fields = append(fields, relationship.FieldTargetPartyID)
	}
	if m._type != nil {
		fields = append(fields, relationship.FieldType)
	}
	if m.updated_at != nil {
		fields = append(fields, relationship.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case relationship.FieldCreatedAt:
		return m.CreatedAt()
	case relationship.FieldDeletedAt:
		return m.DeletedAt()
	case relationship.FieldDeletedBy:
		return m.DeletedBy()
	case relationship.FieldEtag:
		return m.Etag()
	case relationship.FieldNote:
		return m.Note()
	case relationship.FieldTargetPartyID:
		return m.TargetPartyID()
	case relationship.FieldType:
		return m.GetType()
	case relationship.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case relationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case relationship.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case relationship.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case relationship.FieldEtag:
		return m.OldEtag(ctx)
	case relationship.FieldNote:
		return m.OldNote(ctx)
	case relationship.FieldTargetPartyID:
		return m.OldTargetPartyID(ctx)
	case relationship.FieldType:
		return m.OldType(ctx)
	case relationship.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Relationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case relationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case relationship.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case relationship.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case relationship.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case relationship.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case relationship.FieldTargetPartyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetPartyID(v)
		return nil
	case relationship.FieldType:
		v, ok := value.(relationship.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case relationship.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Relationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Relationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(relationship.FieldDeletedAt) {
		fields = append(fields, relationship.FieldDeletedAt)
	}
	if m.FieldCleared(relationship.FieldDeletedBy) {
		fields = append(fields, relationship.FieldDeletedBy)
	}
	if m.FieldCleared(relationship.FieldNote) {
		fields = append(fields, relationship.FieldNote)
	}
	if m.FieldCleared(relationship.FieldUpdatedAt) {
		fields = append(fields, relationship.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RelationshipMutation) ClearField(name string) error {
	switch name {
	case relationship.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case relationship.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case relationship.FieldNote:
		m.ClearNote()
		return nil
	case relationship.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Relationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RelationshipMutation) ResetField(name string) error {
	switch name {
	case relationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case relationship.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case relationship.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case relationship.FieldEtag:
		m.ResetEtag()
		return nil
	case relationship.FieldNote:
		m.ResetNote()
		return nil
	case relationship.FieldTargetPartyID:
		m.ResetTargetPartyID()
		return nil
	case relationship.FieldType:
		m.ResetType()
		return nil
	case relationship.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Relationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.party != nil {
		edges = append(edges, relationship.EdgeParty)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case relationship.EdgeParty:
		if id := m.party; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparty {
		edges = append(edges, relationship.EdgeParty)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case relationship.EdgeParty:
		return m.clearedparty
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RelationshipMutation) ClearEdge(name string) error {
	switch name {
	case relationship.EdgeParty:
		m.ClearParty()
		return nil
	}
	return fmt.Errorf("unknown Relationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RelationshipMutation) ResetEdge(name string) error {
	switch name {
	case relationship.EdgeParty:
		m.ResetParty()
		return nil
	}
	return fmt.Errorf("unknown Relationship edge %s", name)
}
