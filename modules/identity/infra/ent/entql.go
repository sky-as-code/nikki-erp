// Code generated by ent, DO NOT EDIT.

package ent

import (
	"github.com/sky-as-code/nikki-erp/modules/identity/infra/ent/group"
	"github.com/sky-as-code/nikki-erp/modules/identity/infra/ent/hierarchylevel"
	"github.com/sky-as-code/nikki-erp/modules/identity/infra/ent/organization"
	"github.com/sky-as-code/nikki-erp/modules/identity/infra/ent/predicate"
	"github.com/sky-as-code/nikki-erp/modules/identity/infra/ent/user"
	"github.com/sky-as-code/nikki-erp/modules/identity/infra/ent/usergroup"
	"github.com/sky-as-code/nikki-erp/modules/identity/infra/ent/userhierarchy"
	"github.com/sky-as-code/nikki-erp/modules/identity/infra/ent/userorg"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/entql"
	"entgo.io/ent/schema/field"
)

// schemaGraph holds a representation of ent/schema at runtime.
var schemaGraph = func() *sqlgraph.Schema {
	graph := &sqlgraph.Schema{Nodes: make([]*sqlgraph.Node, 7)}
	graph.Nodes[0] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   group.Table,
			Columns: group.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: group.FieldID,
			},
		},
		Type: "Group",
		Fields: map[string]*sqlgraph.FieldSpec{
			group.FieldCreatedAt:   {Type: field.TypeTime, Column: group.FieldCreatedAt},
			group.FieldDescription: {Type: field.TypeString, Column: group.FieldDescription},
			group.FieldEtag:        {Type: field.TypeString, Column: group.FieldEtag},
			group.FieldName:        {Type: field.TypeString, Column: group.FieldName},
			group.FieldOrgID:       {Type: field.TypeString, Column: group.FieldOrgID},
			group.FieldUpdatedAt:   {Type: field.TypeTime, Column: group.FieldUpdatedAt},
		},
	}
	graph.Nodes[1] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   hierarchylevel.Table,
			Columns: hierarchylevel.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: hierarchylevel.FieldID,
			},
		},
		Type: "HierarchyLevel",
		Fields: map[string]*sqlgraph.FieldSpec{
			hierarchylevel.FieldCreatedAt: {Type: field.TypeTime, Column: hierarchylevel.FieldCreatedAt},
			hierarchylevel.FieldDeletedAt: {Type: field.TypeTime, Column: hierarchylevel.FieldDeletedAt},
			hierarchylevel.FieldDeletedBy: {Type: field.TypeString, Column: hierarchylevel.FieldDeletedBy},
			hierarchylevel.FieldEtag:      {Type: field.TypeString, Column: hierarchylevel.FieldEtag},
			hierarchylevel.FieldName:      {Type: field.TypeString, Column: hierarchylevel.FieldName},
			hierarchylevel.FieldOrgID:     {Type: field.TypeString, Column: hierarchylevel.FieldOrgID},
			hierarchylevel.FieldParentID:  {Type: field.TypeString, Column: hierarchylevel.FieldParentID},
			hierarchylevel.FieldUpdatedAt: {Type: field.TypeTime, Column: hierarchylevel.FieldUpdatedAt},
		},
	}
	graph.Nodes[2] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   organization.Table,
			Columns: organization.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: organization.FieldID,
			},
		},
		Type: "Organization",
		Fields: map[string]*sqlgraph.FieldSpec{
			organization.FieldCreatedAt:   {Type: field.TypeTime, Column: organization.FieldCreatedAt},
			organization.FieldDeletedAt:   {Type: field.TypeTime, Column: organization.FieldDeletedAt},
			organization.FieldAddress:     {Type: field.TypeString, Column: organization.FieldAddress},
			organization.FieldDisplayName: {Type: field.TypeString, Column: organization.FieldDisplayName},
			organization.FieldLegalName:   {Type: field.TypeString, Column: organization.FieldLegalName},
			organization.FieldPhoneNumber: {Type: field.TypeString, Column: organization.FieldPhoneNumber},
			organization.FieldEtag:        {Type: field.TypeString, Column: organization.FieldEtag},
			organization.FieldStatus:      {Type: field.TypeString, Column: organization.FieldStatus},
			organization.FieldSlug:        {Type: field.TypeString, Column: organization.FieldSlug},
			organization.FieldUpdatedAt:   {Type: field.TypeTime, Column: organization.FieldUpdatedAt},
		},
	}
	graph.Nodes[3] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: user.FieldID,
			},
		},
		Type: "User",
		Fields: map[string]*sqlgraph.FieldSpec{
			user.FieldAvatarURL:   {Type: field.TypeString, Column: user.FieldAvatarURL},
			user.FieldCreatedAt:   {Type: field.TypeTime, Column: user.FieldCreatedAt},
			user.FieldDisplayName: {Type: field.TypeString, Column: user.FieldDisplayName},
			user.FieldEmail:       {Type: field.TypeString, Column: user.FieldEmail},
			user.FieldEtag:        {Type: field.TypeString, Column: user.FieldEtag},
			user.FieldIsOwner:     {Type: field.TypeBool, Column: user.FieldIsOwner},
			user.FieldStatus:      {Type: field.TypeString, Column: user.FieldStatus},
			user.FieldUpdatedAt:   {Type: field.TypeTime, Column: user.FieldUpdatedAt},
		},
	}
	graph.Nodes[4] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   usergroup.Table,
			Columns: usergroup.Columns,
			CompositeID: []*sqlgraph.FieldSpec{
				{
					Type:   field.TypeString,
					Column: usergroup.FieldUserID,
				},
				{
					Type:   field.TypeString,
					Column: usergroup.FieldGroupID,
				},
			},
		},
		Type: "UserGroup",
		Fields: map[string]*sqlgraph.FieldSpec{
			usergroup.FieldUserID:  {Type: field.TypeString, Column: usergroup.FieldUserID},
			usergroup.FieldGroupID: {Type: field.TypeString, Column: usergroup.FieldGroupID},
		},
	}
	graph.Nodes[5] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   userhierarchy.Table,
			Columns: userhierarchy.Columns,
			CompositeID: []*sqlgraph.FieldSpec{
				{
					Type:   field.TypeString,
					Column: userhierarchy.FieldUserID,
				},
				{
					Type:   field.TypeString,
					Column: userhierarchy.FieldHierarchyID,
				},
			},
		},
		Type: "UserHierarchy",
		Fields: map[string]*sqlgraph.FieldSpec{
			userhierarchy.FieldUserID:      {Type: field.TypeString, Column: userhierarchy.FieldUserID},
			userhierarchy.FieldHierarchyID: {Type: field.TypeString, Column: userhierarchy.FieldHierarchyID},
		},
	}
	graph.Nodes[6] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   userorg.Table,
			Columns: userorg.Columns,
			CompositeID: []*sqlgraph.FieldSpec{
				{
					Type:   field.TypeString,
					Column: userorg.FieldUserID,
				},
				{
					Type:   field.TypeString,
					Column: userorg.FieldOrgID,
				},
			},
		},
		Type: "UserOrg",
		Fields: map[string]*sqlgraph.FieldSpec{
			userorg.FieldUserID: {Type: field.TypeString, Column: userorg.FieldUserID},
			userorg.FieldOrgID:  {Type: field.TypeString, Column: userorg.FieldOrgID},
		},
	}
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   group.UsersTable,
			Columns: group.UsersPrimaryKey,
			Bidi:    false,
		},
		"Group",
		"User",
	)
	graph.MustAddE(
		"org",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   group.OrgTable,
			Columns: []string{group.OrgColumn},
			Bidi:    false,
		},
		"Group",
		"Organization",
	)
	graph.MustAddE(
		"user_groups",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   group.UserGroupsTable,
			Columns: []string{group.UserGroupsColumn},
			Bidi:    false,
		},
		"Group",
		"UserGroup",
	)
	graph.MustAddE(
		"children",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   hierarchylevel.ChildrenTable,
			Columns: []string{hierarchylevel.ChildrenColumn},
			Bidi:    false,
		},
		"HierarchyLevel",
		"HierarchyLevel",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   hierarchylevel.UsersTable,
			Columns: hierarchylevel.UsersPrimaryKey,
			Bidi:    false,
		},
		"HierarchyLevel",
		"User",
	)
	graph.MustAddE(
		"parent",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   hierarchylevel.ParentTable,
			Columns: []string{hierarchylevel.ParentColumn},
			Bidi:    false,
		},
		"HierarchyLevel",
		"HierarchyLevel",
	)
	graph.MustAddE(
		"org",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   hierarchylevel.OrgTable,
			Columns: []string{hierarchylevel.OrgColumn},
			Bidi:    false,
		},
		"HierarchyLevel",
		"Organization",
	)
	graph.MustAddE(
		"user_hierarchy",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   hierarchylevel.UserHierarchyTable,
			Columns: []string{hierarchylevel.UserHierarchyColumn},
			Bidi:    false,
		},
		"HierarchyLevel",
		"UserHierarchy",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   organization.UsersTable,
			Columns: organization.UsersPrimaryKey,
			Bidi:    false,
		},
		"Organization",
		"User",
	)
	graph.MustAddE(
		"hierarchies",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   organization.HierarchiesTable,
			Columns: []string{organization.HierarchiesColumn},
			Bidi:    false,
		},
		"Organization",
		"HierarchyLevel",
	)
	graph.MustAddE(
		"groups",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   organization.GroupsTable,
			Columns: []string{organization.GroupsColumn},
			Bidi:    false,
		},
		"Organization",
		"Group",
	)
	graph.MustAddE(
		"user_orgs",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   organization.UserOrgsTable,
			Columns: []string{organization.UserOrgsColumn},
			Bidi:    false,
		},
		"Organization",
		"UserOrg",
	)
	graph.MustAddE(
		"groups",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.GroupsTable,
			Columns: user.GroupsPrimaryKey,
			Bidi:    false,
		},
		"User",
		"Group",
	)
	graph.MustAddE(
		"hierarchy",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.HierarchyTable,
			Columns: user.HierarchyPrimaryKey,
			Bidi:    false,
		},
		"User",
		"HierarchyLevel",
	)
	graph.MustAddE(
		"orgs",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.OrgsTable,
			Columns: user.OrgsPrimaryKey,
			Bidi:    false,
		},
		"User",
		"Organization",
	)
	graph.MustAddE(
		"user_groups",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UserGroupsTable,
			Columns: []string{user.UserGroupsColumn},
			Bidi:    false,
		},
		"User",
		"UserGroup",
	)
	graph.MustAddE(
		"user_hierarchy",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UserHierarchyTable,
			Columns: []string{user.UserHierarchyColumn},
			Bidi:    false,
		},
		"User",
		"UserHierarchy",
	)
	graph.MustAddE(
		"user_orgs",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UserOrgsTable,
			Columns: []string{user.UserOrgsColumn},
			Bidi:    false,
		},
		"User",
		"UserOrg",
	)
	graph.MustAddE(
		"user",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usergroup.UserTable,
			Columns: []string{usergroup.UserColumn},
			Bidi:    false,
		},
		"UserGroup",
		"User",
	)
	graph.MustAddE(
		"group",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usergroup.GroupTable,
			Columns: []string{usergroup.GroupColumn},
			Bidi:    false,
		},
		"UserGroup",
		"Group",
	)
	graph.MustAddE(
		"user",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   userhierarchy.UserTable,
			Columns: []string{userhierarchy.UserColumn},
			Bidi:    false,
		},
		"UserHierarchy",
		"User",
	)
	graph.MustAddE(
		"hierarchy",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   userhierarchy.HierarchyTable,
			Columns: []string{userhierarchy.HierarchyColumn},
			Bidi:    false,
		},
		"UserHierarchy",
		"HierarchyLevel",
	)
	graph.MustAddE(
		"user",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   userorg.UserTable,
			Columns: []string{userorg.UserColumn},
			Bidi:    false,
		},
		"UserOrg",
		"User",
	)
	graph.MustAddE(
		"org",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   userorg.OrgTable,
			Columns: []string{userorg.OrgColumn},
			Bidi:    false,
		},
		"UserOrg",
		"Organization",
	)
	return graph
}()

// predicateAdder wraps the addPredicate method.
// All update, update-one and query builders implement this interface.
type predicateAdder interface {
	addPredicate(func(s *sql.Selector))
}

// addPredicate implements the predicateAdder interface.
func (gq *GroupQuery) addPredicate(pred func(s *sql.Selector)) {
	gq.predicates = append(gq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the GroupQuery builder.
func (gq *GroupQuery) Filter() *GroupFilter {
	return &GroupFilter{config: gq.config, predicateAdder: gq}
}

// addPredicate implements the predicateAdder interface.
func (m *GroupMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the GroupMutation builder.
func (m *GroupMutation) Filter() *GroupFilter {
	return &GroupFilter{config: m.config, predicateAdder: m}
}

// GroupFilter provides a generic filtering capability at runtime for GroupQuery.
type GroupFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *GroupFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[0].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *GroupFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(group.FieldID))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *GroupFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(group.FieldCreatedAt))
}

// WhereDescription applies the entql string predicate on the description field.
func (f *GroupFilter) WhereDescription(p entql.StringP) {
	f.Where(p.Field(group.FieldDescription))
}

// WhereEtag applies the entql string predicate on the etag field.
func (f *GroupFilter) WhereEtag(p entql.StringP) {
	f.Where(p.Field(group.FieldEtag))
}

// WhereName applies the entql string predicate on the name field.
func (f *GroupFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(group.FieldName))
}

// WhereOrgID applies the entql string predicate on the org_id field.
func (f *GroupFilter) WhereOrgID(p entql.StringP) {
	f.Where(p.Field(group.FieldOrgID))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *GroupFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(group.FieldUpdatedAt))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *GroupFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *GroupFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasOrg applies a predicate to check if query has an edge org.
func (f *GroupFilter) WhereHasOrg() {
	f.Where(entql.HasEdge("org"))
}

// WhereHasOrgWith applies a predicate to check if query has an edge org with a given conditions (other predicates).
func (f *GroupFilter) WhereHasOrgWith(preds ...predicate.Organization) {
	f.Where(entql.HasEdgeWith("org", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUserGroups applies a predicate to check if query has an edge user_groups.
func (f *GroupFilter) WhereHasUserGroups() {
	f.Where(entql.HasEdge("user_groups"))
}

// WhereHasUserGroupsWith applies a predicate to check if query has an edge user_groups with a given conditions (other predicates).
func (f *GroupFilter) WhereHasUserGroupsWith(preds ...predicate.UserGroup) {
	f.Where(entql.HasEdgeWith("user_groups", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (hlq *HierarchyLevelQuery) addPredicate(pred func(s *sql.Selector)) {
	hlq.predicates = append(hlq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the HierarchyLevelQuery builder.
func (hlq *HierarchyLevelQuery) Filter() *HierarchyLevelFilter {
	return &HierarchyLevelFilter{config: hlq.config, predicateAdder: hlq}
}

// addPredicate implements the predicateAdder interface.
func (m *HierarchyLevelMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the HierarchyLevelMutation builder.
func (m *HierarchyLevelMutation) Filter() *HierarchyLevelFilter {
	return &HierarchyLevelFilter{config: m.config, predicateAdder: m}
}

// HierarchyLevelFilter provides a generic filtering capability at runtime for HierarchyLevelQuery.
type HierarchyLevelFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *HierarchyLevelFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[1].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *HierarchyLevelFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(hierarchylevel.FieldID))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *HierarchyLevelFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(hierarchylevel.FieldCreatedAt))
}

// WhereDeletedAt applies the entql time.Time predicate on the deleted_at field.
func (f *HierarchyLevelFilter) WhereDeletedAt(p entql.TimeP) {
	f.Where(p.Field(hierarchylevel.FieldDeletedAt))
}

// WhereDeletedBy applies the entql string predicate on the deleted_by field.
func (f *HierarchyLevelFilter) WhereDeletedBy(p entql.StringP) {
	f.Where(p.Field(hierarchylevel.FieldDeletedBy))
}

// WhereEtag applies the entql string predicate on the etag field.
func (f *HierarchyLevelFilter) WhereEtag(p entql.StringP) {
	f.Where(p.Field(hierarchylevel.FieldEtag))
}

// WhereName applies the entql string predicate on the name field.
func (f *HierarchyLevelFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(hierarchylevel.FieldName))
}

// WhereOrgID applies the entql string predicate on the org_id field.
func (f *HierarchyLevelFilter) WhereOrgID(p entql.StringP) {
	f.Where(p.Field(hierarchylevel.FieldOrgID))
}

// WhereParentID applies the entql string predicate on the parent_id field.
func (f *HierarchyLevelFilter) WhereParentID(p entql.StringP) {
	f.Where(p.Field(hierarchylevel.FieldParentID))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *HierarchyLevelFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(hierarchylevel.FieldUpdatedAt))
}

// WhereHasChildren applies a predicate to check if query has an edge children.
func (f *HierarchyLevelFilter) WhereHasChildren() {
	f.Where(entql.HasEdge("children"))
}

// WhereHasChildrenWith applies a predicate to check if query has an edge children with a given conditions (other predicates).
func (f *HierarchyLevelFilter) WhereHasChildrenWith(preds ...predicate.HierarchyLevel) {
	f.Where(entql.HasEdgeWith("children", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *HierarchyLevelFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *HierarchyLevelFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasParent applies a predicate to check if query has an edge parent.
func (f *HierarchyLevelFilter) WhereHasParent() {
	f.Where(entql.HasEdge("parent"))
}

// WhereHasParentWith applies a predicate to check if query has an edge parent with a given conditions (other predicates).
func (f *HierarchyLevelFilter) WhereHasParentWith(preds ...predicate.HierarchyLevel) {
	f.Where(entql.HasEdgeWith("parent", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasOrg applies a predicate to check if query has an edge org.
func (f *HierarchyLevelFilter) WhereHasOrg() {
	f.Where(entql.HasEdge("org"))
}

// WhereHasOrgWith applies a predicate to check if query has an edge org with a given conditions (other predicates).
func (f *HierarchyLevelFilter) WhereHasOrgWith(preds ...predicate.Organization) {
	f.Where(entql.HasEdgeWith("org", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUserHierarchy applies a predicate to check if query has an edge user_hierarchy.
func (f *HierarchyLevelFilter) WhereHasUserHierarchy() {
	f.Where(entql.HasEdge("user_hierarchy"))
}

// WhereHasUserHierarchyWith applies a predicate to check if query has an edge user_hierarchy with a given conditions (other predicates).
func (f *HierarchyLevelFilter) WhereHasUserHierarchyWith(preds ...predicate.UserHierarchy) {
	f.Where(entql.HasEdgeWith("user_hierarchy", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (oq *OrganizationQuery) addPredicate(pred func(s *sql.Selector)) {
	oq.predicates = append(oq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the OrganizationQuery builder.
func (oq *OrganizationQuery) Filter() *OrganizationFilter {
	return &OrganizationFilter{config: oq.config, predicateAdder: oq}
}

// addPredicate implements the predicateAdder interface.
func (m *OrganizationMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the OrganizationMutation builder.
func (m *OrganizationMutation) Filter() *OrganizationFilter {
	return &OrganizationFilter{config: m.config, predicateAdder: m}
}

// OrganizationFilter provides a generic filtering capability at runtime for OrganizationQuery.
type OrganizationFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *OrganizationFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[2].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *OrganizationFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(organization.FieldID))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *OrganizationFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(organization.FieldCreatedAt))
}

// WhereDeletedAt applies the entql time.Time predicate on the deleted_at field.
func (f *OrganizationFilter) WhereDeletedAt(p entql.TimeP) {
	f.Where(p.Field(organization.FieldDeletedAt))
}

// WhereAddress applies the entql string predicate on the address field.
func (f *OrganizationFilter) WhereAddress(p entql.StringP) {
	f.Where(p.Field(organization.FieldAddress))
}

// WhereDisplayName applies the entql string predicate on the display_name field.
func (f *OrganizationFilter) WhereDisplayName(p entql.StringP) {
	f.Where(p.Field(organization.FieldDisplayName))
}

// WhereLegalName applies the entql string predicate on the legal_name field.
func (f *OrganizationFilter) WhereLegalName(p entql.StringP) {
	f.Where(p.Field(organization.FieldLegalName))
}

// WherePhoneNumber applies the entql string predicate on the phone_number field.
func (f *OrganizationFilter) WherePhoneNumber(p entql.StringP) {
	f.Where(p.Field(organization.FieldPhoneNumber))
}

// WhereEtag applies the entql string predicate on the etag field.
func (f *OrganizationFilter) WhereEtag(p entql.StringP) {
	f.Where(p.Field(organization.FieldEtag))
}

// WhereStatus applies the entql string predicate on the status field.
func (f *OrganizationFilter) WhereStatus(p entql.StringP) {
	f.Where(p.Field(organization.FieldStatus))
}

// WhereSlug applies the entql string predicate on the slug field.
func (f *OrganizationFilter) WhereSlug(p entql.StringP) {
	f.Where(p.Field(organization.FieldSlug))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *OrganizationFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(organization.FieldUpdatedAt))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *OrganizationFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *OrganizationFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHierarchies applies a predicate to check if query has an edge hierarchies.
func (f *OrganizationFilter) WhereHasHierarchies() {
	f.Where(entql.HasEdge("hierarchies"))
}

// WhereHasHierarchiesWith applies a predicate to check if query has an edge hierarchies with a given conditions (other predicates).
func (f *OrganizationFilter) WhereHasHierarchiesWith(preds ...predicate.HierarchyLevel) {
	f.Where(entql.HasEdgeWith("hierarchies", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasGroups applies a predicate to check if query has an edge groups.
func (f *OrganizationFilter) WhereHasGroups() {
	f.Where(entql.HasEdge("groups"))
}

// WhereHasGroupsWith applies a predicate to check if query has an edge groups with a given conditions (other predicates).
func (f *OrganizationFilter) WhereHasGroupsWith(preds ...predicate.Group) {
	f.Where(entql.HasEdgeWith("groups", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUserOrgs applies a predicate to check if query has an edge user_orgs.
func (f *OrganizationFilter) WhereHasUserOrgs() {
	f.Where(entql.HasEdge("user_orgs"))
}

// WhereHasUserOrgsWith applies a predicate to check if query has an edge user_orgs with a given conditions (other predicates).
func (f *OrganizationFilter) WhereHasUserOrgsWith(preds ...predicate.UserOrg) {
	f.Where(entql.HasEdgeWith("user_orgs", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (uq *UserQuery) addPredicate(pred func(s *sql.Selector)) {
	uq.predicates = append(uq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserQuery builder.
func (uq *UserQuery) Filter() *UserFilter {
	return &UserFilter{config: uq.config, predicateAdder: uq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserMutation builder.
func (m *UserMutation) Filter() *UserFilter {
	return &UserFilter{config: m.config, predicateAdder: m}
}

// UserFilter provides a generic filtering capability at runtime for UserQuery.
type UserFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[3].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *UserFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(user.FieldID))
}

// WhereAvatarURL applies the entql string predicate on the avatar_url field.
func (f *UserFilter) WhereAvatarURL(p entql.StringP) {
	f.Where(p.Field(user.FieldAvatarURL))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *UserFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(user.FieldCreatedAt))
}

// WhereDisplayName applies the entql string predicate on the display_name field.
func (f *UserFilter) WhereDisplayName(p entql.StringP) {
	f.Where(p.Field(user.FieldDisplayName))
}

// WhereEmail applies the entql string predicate on the email field.
func (f *UserFilter) WhereEmail(p entql.StringP) {
	f.Where(p.Field(user.FieldEmail))
}

// WhereEtag applies the entql string predicate on the etag field.
func (f *UserFilter) WhereEtag(p entql.StringP) {
	f.Where(p.Field(user.FieldEtag))
}

// WhereIsOwner applies the entql bool predicate on the is_owner field.
func (f *UserFilter) WhereIsOwner(p entql.BoolP) {
	f.Where(p.Field(user.FieldIsOwner))
}

// WhereStatus applies the entql string predicate on the status field.
func (f *UserFilter) WhereStatus(p entql.StringP) {
	f.Where(p.Field(user.FieldStatus))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *UserFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(user.FieldUpdatedAt))
}

// WhereHasGroups applies a predicate to check if query has an edge groups.
func (f *UserFilter) WhereHasGroups() {
	f.Where(entql.HasEdge("groups"))
}

// WhereHasGroupsWith applies a predicate to check if query has an edge groups with a given conditions (other predicates).
func (f *UserFilter) WhereHasGroupsWith(preds ...predicate.Group) {
	f.Where(entql.HasEdgeWith("groups", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHierarchy applies a predicate to check if query has an edge hierarchy.
func (f *UserFilter) WhereHasHierarchy() {
	f.Where(entql.HasEdge("hierarchy"))
}

// WhereHasHierarchyWith applies a predicate to check if query has an edge hierarchy with a given conditions (other predicates).
func (f *UserFilter) WhereHasHierarchyWith(preds ...predicate.HierarchyLevel) {
	f.Where(entql.HasEdgeWith("hierarchy", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasOrgs applies a predicate to check if query has an edge orgs.
func (f *UserFilter) WhereHasOrgs() {
	f.Where(entql.HasEdge("orgs"))
}

// WhereHasOrgsWith applies a predicate to check if query has an edge orgs with a given conditions (other predicates).
func (f *UserFilter) WhereHasOrgsWith(preds ...predicate.Organization) {
	f.Where(entql.HasEdgeWith("orgs", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUserGroups applies a predicate to check if query has an edge user_groups.
func (f *UserFilter) WhereHasUserGroups() {
	f.Where(entql.HasEdge("user_groups"))
}

// WhereHasUserGroupsWith applies a predicate to check if query has an edge user_groups with a given conditions (other predicates).
func (f *UserFilter) WhereHasUserGroupsWith(preds ...predicate.UserGroup) {
	f.Where(entql.HasEdgeWith("user_groups", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUserHierarchy applies a predicate to check if query has an edge user_hierarchy.
func (f *UserFilter) WhereHasUserHierarchy() {
	f.Where(entql.HasEdge("user_hierarchy"))
}

// WhereHasUserHierarchyWith applies a predicate to check if query has an edge user_hierarchy with a given conditions (other predicates).
func (f *UserFilter) WhereHasUserHierarchyWith(preds ...predicate.UserHierarchy) {
	f.Where(entql.HasEdgeWith("user_hierarchy", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUserOrgs applies a predicate to check if query has an edge user_orgs.
func (f *UserFilter) WhereHasUserOrgs() {
	f.Where(entql.HasEdge("user_orgs"))
}

// WhereHasUserOrgsWith applies a predicate to check if query has an edge user_orgs with a given conditions (other predicates).
func (f *UserFilter) WhereHasUserOrgsWith(preds ...predicate.UserOrg) {
	f.Where(entql.HasEdgeWith("user_orgs", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (ugq *UserGroupQuery) addPredicate(pred func(s *sql.Selector)) {
	ugq.predicates = append(ugq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserGroupQuery builder.
func (ugq *UserGroupQuery) Filter() *UserGroupFilter {
	return &UserGroupFilter{config: ugq.config, predicateAdder: ugq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserGroupMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserGroupMutation builder.
func (m *UserGroupMutation) Filter() *UserGroupFilter {
	return &UserGroupFilter{config: m.config, predicateAdder: m}
}

// UserGroupFilter provides a generic filtering capability at runtime for UserGroupQuery.
type UserGroupFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserGroupFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[4].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *UserGroupFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(usergroup.FieldUserID))
}

// WhereGroupID applies the entql string predicate on the group_id field.
func (f *UserGroupFilter) WhereGroupID(p entql.StringP) {
	f.Where(p.Field(usergroup.FieldGroupID))
}

// WhereHasUser applies a predicate to check if query has an edge user.
func (f *UserGroupFilter) WhereHasUser() {
	f.Where(entql.HasEdge("user"))
}

// WhereHasUserWith applies a predicate to check if query has an edge user with a given conditions (other predicates).
func (f *UserGroupFilter) WhereHasUserWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("user", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasGroup applies a predicate to check if query has an edge group.
func (f *UserGroupFilter) WhereHasGroup() {
	f.Where(entql.HasEdge("group"))
}

// WhereHasGroupWith applies a predicate to check if query has an edge group with a given conditions (other predicates).
func (f *UserGroupFilter) WhereHasGroupWith(preds ...predicate.Group) {
	f.Where(entql.HasEdgeWith("group", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (uhq *UserHierarchyQuery) addPredicate(pred func(s *sql.Selector)) {
	uhq.predicates = append(uhq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserHierarchyQuery builder.
func (uhq *UserHierarchyQuery) Filter() *UserHierarchyFilter {
	return &UserHierarchyFilter{config: uhq.config, predicateAdder: uhq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserHierarchyMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserHierarchyMutation builder.
func (m *UserHierarchyMutation) Filter() *UserHierarchyFilter {
	return &UserHierarchyFilter{config: m.config, predicateAdder: m}
}

// UserHierarchyFilter provides a generic filtering capability at runtime for UserHierarchyQuery.
type UserHierarchyFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserHierarchyFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[5].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *UserHierarchyFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(userhierarchy.FieldUserID))
}

// WhereHierarchyID applies the entql string predicate on the hierarchy_id field.
func (f *UserHierarchyFilter) WhereHierarchyID(p entql.StringP) {
	f.Where(p.Field(userhierarchy.FieldHierarchyID))
}

// WhereHasUser applies a predicate to check if query has an edge user.
func (f *UserHierarchyFilter) WhereHasUser() {
	f.Where(entql.HasEdge("user"))
}

// WhereHasUserWith applies a predicate to check if query has an edge user with a given conditions (other predicates).
func (f *UserHierarchyFilter) WhereHasUserWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("user", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHierarchy applies a predicate to check if query has an edge hierarchy.
func (f *UserHierarchyFilter) WhereHasHierarchy() {
	f.Where(entql.HasEdge("hierarchy"))
}

// WhereHasHierarchyWith applies a predicate to check if query has an edge hierarchy with a given conditions (other predicates).
func (f *UserHierarchyFilter) WhereHasHierarchyWith(preds ...predicate.HierarchyLevel) {
	f.Where(entql.HasEdgeWith("hierarchy", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (uoq *UserOrgQuery) addPredicate(pred func(s *sql.Selector)) {
	uoq.predicates = append(uoq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserOrgQuery builder.
func (uoq *UserOrgQuery) Filter() *UserOrgFilter {
	return &UserOrgFilter{config: uoq.config, predicateAdder: uoq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserOrgMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserOrgMutation builder.
func (m *UserOrgMutation) Filter() *UserOrgFilter {
	return &UserOrgFilter{config: m.config, predicateAdder: m}
}

// UserOrgFilter provides a generic filtering capability at runtime for UserOrgQuery.
type UserOrgFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserOrgFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[6].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *UserOrgFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(userorg.FieldUserID))
}

// WhereOrgID applies the entql string predicate on the org_id field.
func (f *UserOrgFilter) WhereOrgID(p entql.StringP) {
	f.Where(p.Field(userorg.FieldOrgID))
}

// WhereHasUser applies a predicate to check if query has an edge user.
func (f *UserOrgFilter) WhereHasUser() {
	f.Where(entql.HasEdge("user"))
}

// WhereHasUserWith applies a predicate to check if query has an edge user with a given conditions (other predicates).
func (f *UserOrgFilter) WhereHasUserWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("user", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasOrg applies a predicate to check if query has an edge org.
func (f *UserOrgFilter) WhereHasOrg() {
	f.Where(entql.HasEdge("org"))
}

// WhereHasOrgWith applies a predicate to check if query has an edge org with a given conditions (other predicates).
func (f *UserOrgFilter) WhereHasOrgWith(preds ...predicate.Organization) {
	f.Where(entql.HasEdgeWith("org", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}
