// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/sky-as-code/nikki-erp/common/model"
	"github.com/sky-as-code/nikki-erp/modules/authenticate/infra/ent/authnenum"
	"github.com/sky-as-code/nikki-erp/modules/authenticate/infra/ent/loginattempt"
	"github.com/sky-as-code/nikki-erp/modules/authenticate/infra/ent/methodsetting"
	"github.com/sky-as-code/nikki-erp/modules/authenticate/infra/ent/passwordstore"
	"github.com/sky-as-code/nikki-erp/modules/authenticate/infra/ent/predicate"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthNEnum     = "AuthNEnum"
	TypeLoginAttempt  = "LoginAttempt"
	TypeMethodSetting = "MethodSetting"
	TypePasswordStore = "PasswordStore"
)

// AuthNEnumMutation represents an operation that mutates the AuthNEnum nodes in the graph.
type AuthNEnumMutation struct {
	config
	op            Op
	typ           string
	id            *string
	etag          *string
	label         *model.LangJson
	value         *string
	_type         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthNEnum, error)
	predicates    []predicate.AuthNEnum
}

var _ ent.Mutation = (*AuthNEnumMutation)(nil)

// authnenumOption allows management of the mutation configuration using functional options.
type authnenumOption func(*AuthNEnumMutation)

// newAuthNEnumMutation creates new mutation for the AuthNEnum entity.
func newAuthNEnumMutation(c config, op Op, opts ...authnenumOption) *AuthNEnumMutation {
	m := &AuthNEnumMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthNEnum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthNEnumID sets the ID field of the mutation.
func withAuthNEnumID(id string) authnenumOption {
	return func(m *AuthNEnumMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthNEnum
		)
		m.oldValue = func(ctx context.Context) (*AuthNEnum, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthNEnum.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthNEnum sets the old AuthNEnum of the mutation.
func withAuthNEnum(node *AuthNEnum) authnenumOption {
	return func(m *AuthNEnumMutation) {
		m.oldValue = func(context.Context) (*AuthNEnum, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthNEnumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthNEnumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthNEnum entities.
func (m *AuthNEnumMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthNEnumMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthNEnumMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthNEnum.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEtag sets the "etag" field.
func (m *AuthNEnumMutation) SetEtag(s string) {
	m.etag = &s
}

// Etag returns the value of the "etag" field in the mutation.
func (m *AuthNEnumMutation) Etag() (r string, exists bool) {
	v := m.etag
	if v == nil {
		return
	}
	return *v, true
}

// OldEtag returns the old "etag" field's value of the AuthNEnum entity.
// If the AuthNEnum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNEnumMutation) OldEtag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtag: %w", err)
	}
	return oldValue.Etag, nil
}

// ResetEtag resets all changes to the "etag" field.
func (m *AuthNEnumMutation) ResetEtag() {
	m.etag = nil
}

// SetLabel sets the "label" field.
func (m *AuthNEnumMutation) SetLabel(mj model.LangJson) {
	m.label = &mj
}

// Label returns the value of the "label" field in the mutation.
func (m *AuthNEnumMutation) Label() (r model.LangJson, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the AuthNEnum entity.
// If the AuthNEnum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNEnumMutation) OldLabel(ctx context.Context) (v model.LangJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *AuthNEnumMutation) ResetLabel() {
	m.label = nil
}

// SetValue sets the "value" field.
func (m *AuthNEnumMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *AuthNEnumMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the AuthNEnum entity.
// If the AuthNEnum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNEnumMutation) OldValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *AuthNEnumMutation) ClearValue() {
	m.value = nil
	m.clearedFields[authnenum.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *AuthNEnumMutation) ValueCleared() bool {
	_, ok := m.clearedFields[authnenum.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *AuthNEnumMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, authnenum.FieldValue)
}

// SetType sets the "type" field.
func (m *AuthNEnumMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AuthNEnumMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AuthNEnum entity.
// If the AuthNEnum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNEnumMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AuthNEnumMutation) ResetType() {
	m._type = nil
}

// Where appends a list predicates to the AuthNEnumMutation builder.
func (m *AuthNEnumMutation) Where(ps ...predicate.AuthNEnum) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthNEnumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthNEnumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthNEnum, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthNEnumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthNEnumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthNEnum).
func (m *AuthNEnumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthNEnumMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.etag != nil {
		fields = append(fields, authnenum.FieldEtag)
	}
	if m.label != nil {
		fields = append(fields, authnenum.FieldLabel)
	}
	if m.value != nil {
		fields = append(fields, authnenum.FieldValue)
	}
	if m._type != nil {
		fields = append(fields, authnenum.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthNEnumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authnenum.FieldEtag:
		return m.Etag()
	case authnenum.FieldLabel:
		return m.Label()
	case authnenum.FieldValue:
		return m.Value()
	case authnenum.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthNEnumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authnenum.FieldEtag:
		return m.OldEtag(ctx)
	case authnenum.FieldLabel:
		return m.OldLabel(ctx)
	case authnenum.FieldValue:
		return m.OldValue(ctx)
	case authnenum.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown AuthNEnum field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthNEnumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authnenum.FieldEtag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtag(v)
		return nil
	case authnenum.FieldLabel:
		v, ok := value.(model.LangJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case authnenum.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case authnenum.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown AuthNEnum field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthNEnumMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthNEnumMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthNEnumMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthNEnum numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthNEnumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authnenum.FieldValue) {
		fields = append(fields, authnenum.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthNEnumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthNEnumMutation) ClearField(name string) error {
	switch name {
	case authnenum.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown AuthNEnum nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthNEnumMutation) ResetField(name string) error {
	switch name {
	case authnenum.FieldEtag:
		m.ResetEtag()
		return nil
	case authnenum.FieldLabel:
		m.ResetLabel()
		return nil
	case authnenum.FieldValue:
		m.ResetValue()
		return nil
	case authnenum.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown AuthNEnum field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthNEnumMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthNEnumMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthNEnumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthNEnumMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthNEnumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthNEnumMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthNEnumMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthNEnum unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthNEnumMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthNEnum edge %s", name)
}

// LoginAttemptMutation represents an operation that mutates the LoginAttempt nodes in the graph.
type LoginAttemptMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	methods            *[]string
	appendmethods      []string
	current_method     *string
	device_ip          *string
	device_name        *string
	device_location    *string
	expired_at         *time.Time
	is_genuine         *bool
	subject_type       *string
	subject_ref        *string
	subject_source_ref *string
	status             *string
	username           *string
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*LoginAttempt, error)
	predicates         []predicate.LoginAttempt
}

var _ ent.Mutation = (*LoginAttemptMutation)(nil)

// loginattemptOption allows management of the mutation configuration using functional options.
type loginattemptOption func(*LoginAttemptMutation)

// newLoginAttemptMutation creates new mutation for the LoginAttempt entity.
func newLoginAttemptMutation(c config, op Op, opts ...loginattemptOption) *LoginAttemptMutation {
	m := &LoginAttemptMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginAttempt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginAttemptID sets the ID field of the mutation.
func withLoginAttemptID(id string) loginattemptOption {
	return func(m *LoginAttemptMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginAttempt
		)
		m.oldValue = func(ctx context.Context) (*LoginAttempt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginAttempt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginAttempt sets the old LoginAttempt of the mutation.
func withLoginAttempt(node *LoginAttempt) loginattemptOption {
	return func(m *LoginAttemptMutation) {
		m.oldValue = func(context.Context) (*LoginAttempt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginAttemptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginAttemptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoginAttempt entities.
func (m *LoginAttemptMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginAttemptMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginAttemptMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginAttempt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LoginAttemptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoginAttemptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoginAttemptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMethods sets the "methods" field.
func (m *LoginAttemptMutation) SetMethods(s []string) {
	m.methods = &s
	m.appendmethods = nil
}

// Methods returns the value of the "methods" field in the mutation.
func (m *LoginAttemptMutation) Methods() (r []string, exists bool) {
	v := m.methods
	if v == nil {
		return
	}
	return *v, true
}

// OldMethods returns the old "methods" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethods: %w", err)
	}
	return oldValue.Methods, nil
}

// AppendMethods adds s to the "methods" field.
func (m *LoginAttemptMutation) AppendMethods(s []string) {
	m.appendmethods = append(m.appendmethods, s...)
}

// AppendedMethods returns the list of values that were appended to the "methods" field in this mutation.
func (m *LoginAttemptMutation) AppendedMethods() ([]string, bool) {
	if len(m.appendmethods) == 0 {
		return nil, false
	}
	return m.appendmethods, true
}

// ResetMethods resets all changes to the "methods" field.
func (m *LoginAttemptMutation) ResetMethods() {
	m.methods = nil
	m.appendmethods = nil
}

// SetCurrentMethod sets the "current_method" field.
func (m *LoginAttemptMutation) SetCurrentMethod(s string) {
	m.current_method = &s
}

// CurrentMethod returns the value of the "current_method" field in the mutation.
func (m *LoginAttemptMutation) CurrentMethod() (r string, exists bool) {
	v := m.current_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentMethod returns the old "current_method" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldCurrentMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentMethod: %w", err)
	}
	return oldValue.CurrentMethod, nil
}

// ClearCurrentMethod clears the value of the "current_method" field.
func (m *LoginAttemptMutation) ClearCurrentMethod() {
	m.current_method = nil
	m.clearedFields[loginattempt.FieldCurrentMethod] = struct{}{}
}

// CurrentMethodCleared returns if the "current_method" field was cleared in this mutation.
func (m *LoginAttemptMutation) CurrentMethodCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldCurrentMethod]
	return ok
}

// ResetCurrentMethod resets all changes to the "current_method" field.
func (m *LoginAttemptMutation) ResetCurrentMethod() {
	m.current_method = nil
	delete(m.clearedFields, loginattempt.FieldCurrentMethod)
}

// SetDeviceIP sets the "device_ip" field.
func (m *LoginAttemptMutation) SetDeviceIP(s string) {
	m.device_ip = &s
}

// DeviceIP returns the value of the "device_ip" field in the mutation.
func (m *LoginAttemptMutation) DeviceIP() (r string, exists bool) {
	v := m.device_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceIP returns the old "device_ip" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldDeviceIP(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceIP: %w", err)
	}
	return oldValue.DeviceIP, nil
}

// ClearDeviceIP clears the value of the "device_ip" field.
func (m *LoginAttemptMutation) ClearDeviceIP() {
	m.device_ip = nil
	m.clearedFields[loginattempt.FieldDeviceIP] = struct{}{}
}

// DeviceIPCleared returns if the "device_ip" field was cleared in this mutation.
func (m *LoginAttemptMutation) DeviceIPCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldDeviceIP]
	return ok
}

// ResetDeviceIP resets all changes to the "device_ip" field.
func (m *LoginAttemptMutation) ResetDeviceIP() {
	m.device_ip = nil
	delete(m.clearedFields, loginattempt.FieldDeviceIP)
}

// SetDeviceName sets the "device_name" field.
func (m *LoginAttemptMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *LoginAttemptMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldDeviceName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ClearDeviceName clears the value of the "device_name" field.
func (m *LoginAttemptMutation) ClearDeviceName() {
	m.device_name = nil
	m.clearedFields[loginattempt.FieldDeviceName] = struct{}{}
}

// DeviceNameCleared returns if the "device_name" field was cleared in this mutation.
func (m *LoginAttemptMutation) DeviceNameCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldDeviceName]
	return ok
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *LoginAttemptMutation) ResetDeviceName() {
	m.device_name = nil
	delete(m.clearedFields, loginattempt.FieldDeviceName)
}

// SetDeviceLocation sets the "device_location" field.
func (m *LoginAttemptMutation) SetDeviceLocation(s string) {
	m.device_location = &s
}

// DeviceLocation returns the value of the "device_location" field in the mutation.
func (m *LoginAttemptMutation) DeviceLocation() (r string, exists bool) {
	v := m.device_location
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceLocation returns the old "device_location" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldDeviceLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceLocation: %w", err)
	}
	return oldValue.DeviceLocation, nil
}

// ClearDeviceLocation clears the value of the "device_location" field.
func (m *LoginAttemptMutation) ClearDeviceLocation() {
	m.device_location = nil
	m.clearedFields[loginattempt.FieldDeviceLocation] = struct{}{}
}

// DeviceLocationCleared returns if the "device_location" field was cleared in this mutation.
func (m *LoginAttemptMutation) DeviceLocationCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldDeviceLocation]
	return ok
}

// ResetDeviceLocation resets all changes to the "device_location" field.
func (m *LoginAttemptMutation) ResetDeviceLocation() {
	m.device_location = nil
	delete(m.clearedFields, loginattempt.FieldDeviceLocation)
}

// SetExpiredAt sets the "expired_at" field.
func (m *LoginAttemptMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *LoginAttemptMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *LoginAttemptMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetIsGenuine sets the "is_genuine" field.
func (m *LoginAttemptMutation) SetIsGenuine(b bool) {
	m.is_genuine = &b
}

// IsGenuine returns the value of the "is_genuine" field in the mutation.
func (m *LoginAttemptMutation) IsGenuine() (r bool, exists bool) {
	v := m.is_genuine
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGenuine returns the old "is_genuine" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldIsGenuine(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGenuine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGenuine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGenuine: %w", err)
	}
	return oldValue.IsGenuine, nil
}

// ResetIsGenuine resets all changes to the "is_genuine" field.
func (m *LoginAttemptMutation) ResetIsGenuine() {
	m.is_genuine = nil
}

// SetSubjectType sets the "subject_type" field.
func (m *LoginAttemptMutation) SetSubjectType(s string) {
	m.subject_type = &s
}

// SubjectType returns the value of the "subject_type" field in the mutation.
func (m *LoginAttemptMutation) SubjectType() (r string, exists bool) {
	v := m.subject_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectType returns the old "subject_type" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldSubjectType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectType: %w", err)
	}
	return oldValue.SubjectType, nil
}

// ResetSubjectType resets all changes to the "subject_type" field.
func (m *LoginAttemptMutation) ResetSubjectType() {
	m.subject_type = nil
}

// SetSubjectRef sets the "subject_ref" field.
func (m *LoginAttemptMutation) SetSubjectRef(s string) {
	m.subject_ref = &s
}

// SubjectRef returns the value of the "subject_ref" field in the mutation.
func (m *LoginAttemptMutation) SubjectRef() (r string, exists bool) {
	v := m.subject_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectRef returns the old "subject_ref" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldSubjectRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectRef: %w", err)
	}
	return oldValue.SubjectRef, nil
}

// ResetSubjectRef resets all changes to the "subject_ref" field.
func (m *LoginAttemptMutation) ResetSubjectRef() {
	m.subject_ref = nil
}

// SetSubjectSourceRef sets the "subject_source_ref" field.
func (m *LoginAttemptMutation) SetSubjectSourceRef(s string) {
	m.subject_source_ref = &s
}

// SubjectSourceRef returns the value of the "subject_source_ref" field in the mutation.
func (m *LoginAttemptMutation) SubjectSourceRef() (r string, exists bool) {
	v := m.subject_source_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectSourceRef returns the old "subject_source_ref" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldSubjectSourceRef(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectSourceRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectSourceRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectSourceRef: %w", err)
	}
	return oldValue.SubjectSourceRef, nil
}

// ClearSubjectSourceRef clears the value of the "subject_source_ref" field.
func (m *LoginAttemptMutation) ClearSubjectSourceRef() {
	m.subject_source_ref = nil
	m.clearedFields[loginattempt.FieldSubjectSourceRef] = struct{}{}
}

// SubjectSourceRefCleared returns if the "subject_source_ref" field was cleared in this mutation.
func (m *LoginAttemptMutation) SubjectSourceRefCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldSubjectSourceRef]
	return ok
}

// ResetSubjectSourceRef resets all changes to the "subject_source_ref" field.
func (m *LoginAttemptMutation) ResetSubjectSourceRef() {
	m.subject_source_ref = nil
	delete(m.clearedFields, loginattempt.FieldSubjectSourceRef)
}

// SetStatus sets the "status" field.
func (m *LoginAttemptMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *LoginAttemptMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LoginAttemptMutation) ResetStatus() {
	m.status = nil
}

// SetUsername sets the "username" field.
func (m *LoginAttemptMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *LoginAttemptMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *LoginAttemptMutation) ResetUsername() {
	m.username = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LoginAttemptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LoginAttemptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *LoginAttemptMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[loginattempt.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *LoginAttemptMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LoginAttemptMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, loginattempt.FieldUpdatedAt)
}

// Where appends a list predicates to the LoginAttemptMutation builder.
func (m *LoginAttemptMutation) Where(ps ...predicate.LoginAttempt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginAttemptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginAttemptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginAttempt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginAttemptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginAttemptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginAttempt).
func (m *LoginAttemptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginAttemptMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, loginattempt.FieldCreatedAt)
	}
	if m.methods != nil {
		fields = append(fields, loginattempt.FieldMethods)
	}
	if m.current_method != nil {
		fields = append(fields, loginattempt.FieldCurrentMethod)
	}
	if m.device_ip != nil {
		fields = append(fields, loginattempt.FieldDeviceIP)
	}
	if m.device_name != nil {
		fields = append(fields, loginattempt.FieldDeviceName)
	}
	if m.device_location != nil {
		fields = append(fields, loginattempt.FieldDeviceLocation)
	}
	if m.expired_at != nil {
		fields = append(fields, loginattempt.FieldExpiredAt)
	}
	if m.is_genuine != nil {
		fields = append(fields, loginattempt.FieldIsGenuine)
	}
	if m.subject_type != nil {
		fields = append(fields, loginattempt.FieldSubjectType)
	}
	if m.subject_ref != nil {
		fields = append(fields, loginattempt.FieldSubjectRef)
	}
	if m.subject_source_ref != nil {
		fields = append(fields, loginattempt.FieldSubjectSourceRef)
	}
	if m.status != nil {
		fields = append(fields, loginattempt.FieldStatus)
	}
	if m.username != nil {
		fields = append(fields, loginattempt.FieldUsername)
	}
	if m.updated_at != nil {
		fields = append(fields, loginattempt.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginAttemptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginattempt.FieldCreatedAt:
		return m.CreatedAt()
	case loginattempt.FieldMethods:
		return m.Methods()
	case loginattempt.FieldCurrentMethod:
		return m.CurrentMethod()
	case loginattempt.FieldDeviceIP:
		return m.DeviceIP()
	case loginattempt.FieldDeviceName:
		return m.DeviceName()
	case loginattempt.FieldDeviceLocation:
		return m.DeviceLocation()
	case loginattempt.FieldExpiredAt:
		return m.ExpiredAt()
	case loginattempt.FieldIsGenuine:
		return m.IsGenuine()
	case loginattempt.FieldSubjectType:
		return m.SubjectType()
	case loginattempt.FieldSubjectRef:
		return m.SubjectRef()
	case loginattempt.FieldSubjectSourceRef:
		return m.SubjectSourceRef()
	case loginattempt.FieldStatus:
		return m.Status()
	case loginattempt.FieldUsername:
		return m.Username()
	case loginattempt.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginAttemptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginattempt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loginattempt.FieldMethods:
		return m.OldMethods(ctx)
	case loginattempt.FieldCurrentMethod:
		return m.OldCurrentMethod(ctx)
	case loginattempt.FieldDeviceIP:
		return m.OldDeviceIP(ctx)
	case loginattempt.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case loginattempt.FieldDeviceLocation:
		return m.OldDeviceLocation(ctx)
	case loginattempt.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case loginattempt.FieldIsGenuine:
		return m.OldIsGenuine(ctx)
	case loginattempt.FieldSubjectType:
		return m.OldSubjectType(ctx)
	case loginattempt.FieldSubjectRef:
		return m.OldSubjectRef(ctx)
	case loginattempt.FieldSubjectSourceRef:
		return m.OldSubjectSourceRef(ctx)
	case loginattempt.FieldStatus:
		return m.OldStatus(ctx)
	case loginattempt.FieldUsername:
		return m.OldUsername(ctx)
	case loginattempt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LoginAttempt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginAttemptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginattempt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loginattempt.FieldMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethods(v)
		return nil
	case loginattempt.FieldCurrentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentMethod(v)
		return nil
	case loginattempt.FieldDeviceIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceIP(v)
		return nil
	case loginattempt.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case loginattempt.FieldDeviceLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceLocation(v)
		return nil
	case loginattempt.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case loginattempt.FieldIsGenuine:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGenuine(v)
		return nil
	case loginattempt.FieldSubjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectType(v)
		return nil
	case loginattempt.FieldSubjectRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectRef(v)
		return nil
	case loginattempt.FieldSubjectSourceRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectSourceRef(v)
		return nil
	case loginattempt.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case loginattempt.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case loginattempt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LoginAttempt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginAttemptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginAttemptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginAttemptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LoginAttempt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginAttemptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loginattempt.FieldCurrentMethod) {
		fields = append(fields, loginattempt.FieldCurrentMethod)
	}
	if m.FieldCleared(loginattempt.FieldDeviceIP) {
		fields = append(fields, loginattempt.FieldDeviceIP)
	}
	if m.FieldCleared(loginattempt.FieldDeviceName) {
		fields = append(fields, loginattempt.FieldDeviceName)
	}
	if m.FieldCleared(loginattempt.FieldDeviceLocation) {
		fields = append(fields, loginattempt.FieldDeviceLocation)
	}
	if m.FieldCleared(loginattempt.FieldSubjectSourceRef) {
		fields = append(fields, loginattempt.FieldSubjectSourceRef)
	}
	if m.FieldCleared(loginattempt.FieldUpdatedAt) {
		fields = append(fields, loginattempt.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginAttemptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginAttemptMutation) ClearField(name string) error {
	switch name {
	case loginattempt.FieldCurrentMethod:
		m.ClearCurrentMethod()
		return nil
	case loginattempt.FieldDeviceIP:
		m.ClearDeviceIP()
		return nil
	case loginattempt.FieldDeviceName:
		m.ClearDeviceName()
		return nil
	case loginattempt.FieldDeviceLocation:
		m.ClearDeviceLocation()
		return nil
	case loginattempt.FieldSubjectSourceRef:
		m.ClearSubjectSourceRef()
		return nil
	case loginattempt.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown LoginAttempt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginAttemptMutation) ResetField(name string) error {
	switch name {
	case loginattempt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loginattempt.FieldMethods:
		m.ResetMethods()
		return nil
	case loginattempt.FieldCurrentMethod:
		m.ResetCurrentMethod()
		return nil
	case loginattempt.FieldDeviceIP:
		m.ResetDeviceIP()
		return nil
	case loginattempt.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case loginattempt.FieldDeviceLocation:
		m.ResetDeviceLocation()
		return nil
	case loginattempt.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case loginattempt.FieldIsGenuine:
		m.ResetIsGenuine()
		return nil
	case loginattempt.FieldSubjectType:
		m.ResetSubjectType()
		return nil
	case loginattempt.FieldSubjectRef:
		m.ResetSubjectRef()
		return nil
	case loginattempt.FieldSubjectSourceRef:
		m.ResetSubjectSourceRef()
		return nil
	case loginattempt.FieldStatus:
		m.ResetStatus()
		return nil
	case loginattempt.FieldUsername:
		m.ResetUsername()
		return nil
	case loginattempt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown LoginAttempt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginAttemptMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginAttemptMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginAttemptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginAttemptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginAttemptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginAttemptMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginAttemptMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LoginAttempt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginAttemptMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LoginAttempt edge %s", name)
}

// MethodSettingMutation represents an operation that mutates the MethodSetting nodes in the graph.
type MethodSettingMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	method                *string
	_order                *int
	add_order             *int
	max_failures          *int
	addmax_failures       *int
	lock_duration_secs    *int
	addlock_duration_secs *int
	subject_type          *string
	subject_ref           *string
	subject_source_ref    *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*MethodSetting, error)
	predicates            []predicate.MethodSetting
}

var _ ent.Mutation = (*MethodSettingMutation)(nil)

// methodsettingOption allows management of the mutation configuration using functional options.
type methodsettingOption func(*MethodSettingMutation)

// newMethodSettingMutation creates new mutation for the MethodSetting entity.
func newMethodSettingMutation(c config, op Op, opts ...methodsettingOption) *MethodSettingMutation {
	m := &MethodSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeMethodSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMethodSettingID sets the ID field of the mutation.
func withMethodSettingID(id string) methodsettingOption {
	return func(m *MethodSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *MethodSetting
		)
		m.oldValue = func(ctx context.Context) (*MethodSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MethodSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMethodSetting sets the old MethodSetting of the mutation.
func withMethodSetting(node *MethodSetting) methodsettingOption {
	return func(m *MethodSettingMutation) {
		m.oldValue = func(context.Context) (*MethodSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MethodSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MethodSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MethodSetting entities.
func (m *MethodSettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MethodSettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MethodSettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MethodSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMethod sets the "method" field.
func (m *MethodSettingMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *MethodSettingMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the MethodSetting entity.
// If the MethodSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MethodSettingMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *MethodSettingMutation) ResetMethod() {
	m.method = nil
}

// SetOrder sets the "order" field.
func (m *MethodSettingMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *MethodSettingMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the MethodSetting entity.
// If the MethodSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MethodSettingMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *MethodSettingMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *MethodSettingMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *MethodSettingMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetMaxFailures sets the "max_failures" field.
func (m *MethodSettingMutation) SetMaxFailures(i int) {
	m.max_failures = &i
	m.addmax_failures = nil
}

// MaxFailures returns the value of the "max_failures" field in the mutation.
func (m *MethodSettingMutation) MaxFailures() (r int, exists bool) {
	v := m.max_failures
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxFailures returns the old "max_failures" field's value of the MethodSetting entity.
// If the MethodSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MethodSettingMutation) OldMaxFailures(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxFailures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxFailures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxFailures: %w", err)
	}
	return oldValue.MaxFailures, nil
}

// AddMaxFailures adds i to the "max_failures" field.
func (m *MethodSettingMutation) AddMaxFailures(i int) {
	if m.addmax_failures != nil {
		*m.addmax_failures += i
	} else {
		m.addmax_failures = &i
	}
}

// AddedMaxFailures returns the value that was added to the "max_failures" field in this mutation.
func (m *MethodSettingMutation) AddedMaxFailures() (r int, exists bool) {
	v := m.addmax_failures
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxFailures resets all changes to the "max_failures" field.
func (m *MethodSettingMutation) ResetMaxFailures() {
	m.max_failures = nil
	m.addmax_failures = nil
}

// SetLockDurationSecs sets the "lock_duration_secs" field.
func (m *MethodSettingMutation) SetLockDurationSecs(i int) {
	m.lock_duration_secs = &i
	m.addlock_duration_secs = nil
}

// LockDurationSecs returns the value of the "lock_duration_secs" field in the mutation.
func (m *MethodSettingMutation) LockDurationSecs() (r int, exists bool) {
	v := m.lock_duration_secs
	if v == nil {
		return
	}
	return *v, true
}

// OldLockDurationSecs returns the old "lock_duration_secs" field's value of the MethodSetting entity.
// If the MethodSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MethodSettingMutation) OldLockDurationSecs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockDurationSecs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockDurationSecs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockDurationSecs: %w", err)
	}
	return oldValue.LockDurationSecs, nil
}

// AddLockDurationSecs adds i to the "lock_duration_secs" field.
func (m *MethodSettingMutation) AddLockDurationSecs(i int) {
	if m.addlock_duration_secs != nil {
		*m.addlock_duration_secs += i
	} else {
		m.addlock_duration_secs = &i
	}
}

// AddedLockDurationSecs returns the value that was added to the "lock_duration_secs" field in this mutation.
func (m *MethodSettingMutation) AddedLockDurationSecs() (r int, exists bool) {
	v := m.addlock_duration_secs
	if v == nil {
		return
	}
	return *v, true
}

// ClearLockDurationSecs clears the value of the "lock_duration_secs" field.
func (m *MethodSettingMutation) ClearLockDurationSecs() {
	m.lock_duration_secs = nil
	m.addlock_duration_secs = nil
	m.clearedFields[methodsetting.FieldLockDurationSecs] = struct{}{}
}

// LockDurationSecsCleared returns if the "lock_duration_secs" field was cleared in this mutation.
func (m *MethodSettingMutation) LockDurationSecsCleared() bool {
	_, ok := m.clearedFields[methodsetting.FieldLockDurationSecs]
	return ok
}

// ResetLockDurationSecs resets all changes to the "lock_duration_secs" field.
func (m *MethodSettingMutation) ResetLockDurationSecs() {
	m.lock_duration_secs = nil
	m.addlock_duration_secs = nil
	delete(m.clearedFields, methodsetting.FieldLockDurationSecs)
}

// SetSubjectType sets the "subject_type" field.
func (m *MethodSettingMutation) SetSubjectType(s string) {
	m.subject_type = &s
}

// SubjectType returns the value of the "subject_type" field in the mutation.
func (m *MethodSettingMutation) SubjectType() (r string, exists bool) {
	v := m.subject_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectType returns the old "subject_type" field's value of the MethodSetting entity.
// If the MethodSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MethodSettingMutation) OldSubjectType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectType: %w", err)
	}
	return oldValue.SubjectType, nil
}

// ResetSubjectType resets all changes to the "subject_type" field.
func (m *MethodSettingMutation) ResetSubjectType() {
	m.subject_type = nil
}

// SetSubjectRef sets the "subject_ref" field.
func (m *MethodSettingMutation) SetSubjectRef(s string) {
	m.subject_ref = &s
}

// SubjectRef returns the value of the "subject_ref" field in the mutation.
func (m *MethodSettingMutation) SubjectRef() (r string, exists bool) {
	v := m.subject_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectRef returns the old "subject_ref" field's value of the MethodSetting entity.
// If the MethodSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MethodSettingMutation) OldSubjectRef(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectRef: %w", err)
	}
	return oldValue.SubjectRef, nil
}

// ClearSubjectRef clears the value of the "subject_ref" field.
func (m *MethodSettingMutation) ClearSubjectRef() {
	m.subject_ref = nil
	m.clearedFields[methodsetting.FieldSubjectRef] = struct{}{}
}

// SubjectRefCleared returns if the "subject_ref" field was cleared in this mutation.
func (m *MethodSettingMutation) SubjectRefCleared() bool {
	_, ok := m.clearedFields[methodsetting.FieldSubjectRef]
	return ok
}

// ResetSubjectRef resets all changes to the "subject_ref" field.
func (m *MethodSettingMutation) ResetSubjectRef() {
	m.subject_ref = nil
	delete(m.clearedFields, methodsetting.FieldSubjectRef)
}

// SetSubjectSourceRef sets the "subject_source_ref" field.
func (m *MethodSettingMutation) SetSubjectSourceRef(s string) {
	m.subject_source_ref = &s
}

// SubjectSourceRef returns the value of the "subject_source_ref" field in the mutation.
func (m *MethodSettingMutation) SubjectSourceRef() (r string, exists bool) {
	v := m.subject_source_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectSourceRef returns the old "subject_source_ref" field's value of the MethodSetting entity.
// If the MethodSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MethodSettingMutation) OldSubjectSourceRef(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectSourceRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectSourceRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectSourceRef: %w", err)
	}
	return oldValue.SubjectSourceRef, nil
}

// ClearSubjectSourceRef clears the value of the "subject_source_ref" field.
func (m *MethodSettingMutation) ClearSubjectSourceRef() {
	m.subject_source_ref = nil
	m.clearedFields[methodsetting.FieldSubjectSourceRef] = struct{}{}
}

// SubjectSourceRefCleared returns if the "subject_source_ref" field was cleared in this mutation.
func (m *MethodSettingMutation) SubjectSourceRefCleared() bool {
	_, ok := m.clearedFields[methodsetting.FieldSubjectSourceRef]
	return ok
}

// ResetSubjectSourceRef resets all changes to the "subject_source_ref" field.
func (m *MethodSettingMutation) ResetSubjectSourceRef() {
	m.subject_source_ref = nil
	delete(m.clearedFields, methodsetting.FieldSubjectSourceRef)
}

// Where appends a list predicates to the MethodSettingMutation builder.
func (m *MethodSettingMutation) Where(ps ...predicate.MethodSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MethodSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MethodSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MethodSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MethodSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MethodSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MethodSetting).
func (m *MethodSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MethodSettingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.method != nil {
		fields = append(fields, methodsetting.FieldMethod)
	}
	if m._order != nil {
		fields = append(fields, methodsetting.FieldOrder)
	}
	if m.max_failures != nil {
		fields = append(fields, methodsetting.FieldMaxFailures)
	}
	if m.lock_duration_secs != nil {
		fields = append(fields, methodsetting.FieldLockDurationSecs)
	}
	if m.subject_type != nil {
		fields = append(fields, methodsetting.FieldSubjectType)
	}
	if m.subject_ref != nil {
		fields = append(fields, methodsetting.FieldSubjectRef)
	}
	if m.subject_source_ref != nil {
		fields = append(fields, methodsetting.FieldSubjectSourceRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MethodSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case methodsetting.FieldMethod:
		return m.Method()
	case methodsetting.FieldOrder:
		return m.Order()
	case methodsetting.FieldMaxFailures:
		return m.MaxFailures()
	case methodsetting.FieldLockDurationSecs:
		return m.LockDurationSecs()
	case methodsetting.FieldSubjectType:
		return m.SubjectType()
	case methodsetting.FieldSubjectRef:
		return m.SubjectRef()
	case methodsetting.FieldSubjectSourceRef:
		return m.SubjectSourceRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MethodSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case methodsetting.FieldMethod:
		return m.OldMethod(ctx)
	case methodsetting.FieldOrder:
		return m.OldOrder(ctx)
	case methodsetting.FieldMaxFailures:
		return m.OldMaxFailures(ctx)
	case methodsetting.FieldLockDurationSecs:
		return m.OldLockDurationSecs(ctx)
	case methodsetting.FieldSubjectType:
		return m.OldSubjectType(ctx)
	case methodsetting.FieldSubjectRef:
		return m.OldSubjectRef(ctx)
	case methodsetting.FieldSubjectSourceRef:
		return m.OldSubjectSourceRef(ctx)
	}
	return nil, fmt.Errorf("unknown MethodSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MethodSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case methodsetting.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case methodsetting.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case methodsetting.FieldMaxFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxFailures(v)
		return nil
	case methodsetting.FieldLockDurationSecs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockDurationSecs(v)
		return nil
	case methodsetting.FieldSubjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectType(v)
		return nil
	case methodsetting.FieldSubjectRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectRef(v)
		return nil
	case methodsetting.FieldSubjectSourceRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectSourceRef(v)
		return nil
	}
	return fmt.Errorf("unknown MethodSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MethodSettingMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, methodsetting.FieldOrder)
	}
	if m.addmax_failures != nil {
		fields = append(fields, methodsetting.FieldMaxFailures)
	}
	if m.addlock_duration_secs != nil {
		fields = append(fields, methodsetting.FieldLockDurationSecs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MethodSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case methodsetting.FieldOrder:
		return m.AddedOrder()
	case methodsetting.FieldMaxFailures:
		return m.AddedMaxFailures()
	case methodsetting.FieldLockDurationSecs:
		return m.AddedLockDurationSecs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MethodSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case methodsetting.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case methodsetting.FieldMaxFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxFailures(v)
		return nil
	case methodsetting.FieldLockDurationSecs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLockDurationSecs(v)
		return nil
	}
	return fmt.Errorf("unknown MethodSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MethodSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(methodsetting.FieldLockDurationSecs) {
		fields = append(fields, methodsetting.FieldLockDurationSecs)
	}
	if m.FieldCleared(methodsetting.FieldSubjectRef) {
		fields = append(fields, methodsetting.FieldSubjectRef)
	}
	if m.FieldCleared(methodsetting.FieldSubjectSourceRef) {
		fields = append(fields, methodsetting.FieldSubjectSourceRef)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MethodSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MethodSettingMutation) ClearField(name string) error {
	switch name {
	case methodsetting.FieldLockDurationSecs:
		m.ClearLockDurationSecs()
		return nil
	case methodsetting.FieldSubjectRef:
		m.ClearSubjectRef()
		return nil
	case methodsetting.FieldSubjectSourceRef:
		m.ClearSubjectSourceRef()
		return nil
	}
	return fmt.Errorf("unknown MethodSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MethodSettingMutation) ResetField(name string) error {
	switch name {
	case methodsetting.FieldMethod:
		m.ResetMethod()
		return nil
	case methodsetting.FieldOrder:
		m.ResetOrder()
		return nil
	case methodsetting.FieldMaxFailures:
		m.ResetMaxFailures()
		return nil
	case methodsetting.FieldLockDurationSecs:
		m.ResetLockDurationSecs()
		return nil
	case methodsetting.FieldSubjectType:
		m.ResetSubjectType()
		return nil
	case methodsetting.FieldSubjectRef:
		m.ResetSubjectRef()
		return nil
	case methodsetting.FieldSubjectSourceRef:
		m.ResetSubjectSourceRef()
		return nil
	}
	return fmt.Errorf("unknown MethodSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MethodSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MethodSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MethodSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MethodSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MethodSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MethodSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MethodSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MethodSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MethodSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MethodSetting edge %s", name)
}

// PasswordStoreMutation represents an operation that mutates the PasswordStore nodes in the graph.
type PasswordStoreMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	password                   *string
	password_expired_at        *time.Time
	password_updated_at        *time.Time
	passwordtmp                *string
	passwordtmp_expired_at     *time.Time
	passwordotp                *string
	passwordotp_expired_at     *time.Time
	passwordotp_recovery       *[]string
	appendpasswordotp_recovery []string
	subject_type               *string
	subject_ref                *string
	subject_source_ref         *string
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*PasswordStore, error)
	predicates                 []predicate.PasswordStore
}

var _ ent.Mutation = (*PasswordStoreMutation)(nil)

// passwordstoreOption allows management of the mutation configuration using functional options.
type passwordstoreOption func(*PasswordStoreMutation)

// newPasswordStoreMutation creates new mutation for the PasswordStore entity.
func newPasswordStoreMutation(c config, op Op, opts ...passwordstoreOption) *PasswordStoreMutation {
	m := &PasswordStoreMutation{
		config:        c,
		op:            op,
		typ:           TypePasswordStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordStoreID sets the ID field of the mutation.
func withPasswordStoreID(id string) passwordstoreOption {
	return func(m *PasswordStoreMutation) {
		var (
			err   error
			once  sync.Once
			value *PasswordStore
		)
		m.oldValue = func(ctx context.Context) (*PasswordStore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PasswordStore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasswordStore sets the old PasswordStore of the mutation.
func withPasswordStore(node *PasswordStore) passwordstoreOption {
	return func(m *PasswordStoreMutation) {
		m.oldValue = func(context.Context) (*PasswordStore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordStoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordStoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PasswordStore entities.
func (m *PasswordStoreMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordStoreMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordStoreMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PasswordStore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPassword sets the "password" field.
func (m *PasswordStoreMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *PasswordStoreMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *PasswordStoreMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[passwordstore.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *PasswordStoreMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[passwordstore.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *PasswordStoreMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, passwordstore.FieldPassword)
}

// SetPasswordExpiredAt sets the "password_expired_at" field.
func (m *PasswordStoreMutation) SetPasswordExpiredAt(t time.Time) {
	m.password_expired_at = &t
}

// PasswordExpiredAt returns the value of the "password_expired_at" field in the mutation.
func (m *PasswordStoreMutation) PasswordExpiredAt() (r time.Time, exists bool) {
	v := m.password_expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordExpiredAt returns the old "password_expired_at" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldPasswordExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordExpiredAt: %w", err)
	}
	return oldValue.PasswordExpiredAt, nil
}

// ClearPasswordExpiredAt clears the value of the "password_expired_at" field.
func (m *PasswordStoreMutation) ClearPasswordExpiredAt() {
	m.password_expired_at = nil
	m.clearedFields[passwordstore.FieldPasswordExpiredAt] = struct{}{}
}

// PasswordExpiredAtCleared returns if the "password_expired_at" field was cleared in this mutation.
func (m *PasswordStoreMutation) PasswordExpiredAtCleared() bool {
	_, ok := m.clearedFields[passwordstore.FieldPasswordExpiredAt]
	return ok
}

// ResetPasswordExpiredAt resets all changes to the "password_expired_at" field.
func (m *PasswordStoreMutation) ResetPasswordExpiredAt() {
	m.password_expired_at = nil
	delete(m.clearedFields, passwordstore.FieldPasswordExpiredAt)
}

// SetPasswordUpdatedAt sets the "password_updated_at" field.
func (m *PasswordStoreMutation) SetPasswordUpdatedAt(t time.Time) {
	m.password_updated_at = &t
}

// PasswordUpdatedAt returns the value of the "password_updated_at" field in the mutation.
func (m *PasswordStoreMutation) PasswordUpdatedAt() (r time.Time, exists bool) {
	v := m.password_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordUpdatedAt returns the old "password_updated_at" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldPasswordUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordUpdatedAt: %w", err)
	}
	return oldValue.PasswordUpdatedAt, nil
}

// ClearPasswordUpdatedAt clears the value of the "password_updated_at" field.
func (m *PasswordStoreMutation) ClearPasswordUpdatedAt() {
	m.password_updated_at = nil
	m.clearedFields[passwordstore.FieldPasswordUpdatedAt] = struct{}{}
}

// PasswordUpdatedAtCleared returns if the "password_updated_at" field was cleared in this mutation.
func (m *PasswordStoreMutation) PasswordUpdatedAtCleared() bool {
	_, ok := m.clearedFields[passwordstore.FieldPasswordUpdatedAt]
	return ok
}

// ResetPasswordUpdatedAt resets all changes to the "password_updated_at" field.
func (m *PasswordStoreMutation) ResetPasswordUpdatedAt() {
	m.password_updated_at = nil
	delete(m.clearedFields, passwordstore.FieldPasswordUpdatedAt)
}

// SetPasswordtmp sets the "passwordtmp" field.
func (m *PasswordStoreMutation) SetPasswordtmp(s string) {
	m.passwordtmp = &s
}

// Passwordtmp returns the value of the "passwordtmp" field in the mutation.
func (m *PasswordStoreMutation) Passwordtmp() (r string, exists bool) {
	v := m.passwordtmp
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordtmp returns the old "passwordtmp" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldPasswordtmp(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordtmp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordtmp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordtmp: %w", err)
	}
	return oldValue.Passwordtmp, nil
}

// ClearPasswordtmp clears the value of the "passwordtmp" field.
func (m *PasswordStoreMutation) ClearPasswordtmp() {
	m.passwordtmp = nil
	m.clearedFields[passwordstore.FieldPasswordtmp] = struct{}{}
}

// PasswordtmpCleared returns if the "passwordtmp" field was cleared in this mutation.
func (m *PasswordStoreMutation) PasswordtmpCleared() bool {
	_, ok := m.clearedFields[passwordstore.FieldPasswordtmp]
	return ok
}

// ResetPasswordtmp resets all changes to the "passwordtmp" field.
func (m *PasswordStoreMutation) ResetPasswordtmp() {
	m.passwordtmp = nil
	delete(m.clearedFields, passwordstore.FieldPasswordtmp)
}

// SetPasswordtmpExpiredAt sets the "passwordtmp_expired_at" field.
func (m *PasswordStoreMutation) SetPasswordtmpExpiredAt(t time.Time) {
	m.passwordtmp_expired_at = &t
}

// PasswordtmpExpiredAt returns the value of the "passwordtmp_expired_at" field in the mutation.
func (m *PasswordStoreMutation) PasswordtmpExpiredAt() (r time.Time, exists bool) {
	v := m.passwordtmp_expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordtmpExpiredAt returns the old "passwordtmp_expired_at" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldPasswordtmpExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordtmpExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordtmpExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordtmpExpiredAt: %w", err)
	}
	return oldValue.PasswordtmpExpiredAt, nil
}

// ClearPasswordtmpExpiredAt clears the value of the "passwordtmp_expired_at" field.
func (m *PasswordStoreMutation) ClearPasswordtmpExpiredAt() {
	m.passwordtmp_expired_at = nil
	m.clearedFields[passwordstore.FieldPasswordtmpExpiredAt] = struct{}{}
}

// PasswordtmpExpiredAtCleared returns if the "passwordtmp_expired_at" field was cleared in this mutation.
func (m *PasswordStoreMutation) PasswordtmpExpiredAtCleared() bool {
	_, ok := m.clearedFields[passwordstore.FieldPasswordtmpExpiredAt]
	return ok
}

// ResetPasswordtmpExpiredAt resets all changes to the "passwordtmp_expired_at" field.
func (m *PasswordStoreMutation) ResetPasswordtmpExpiredAt() {
	m.passwordtmp_expired_at = nil
	delete(m.clearedFields, passwordstore.FieldPasswordtmpExpiredAt)
}

// SetPasswordotp sets the "passwordotp" field.
func (m *PasswordStoreMutation) SetPasswordotp(s string) {
	m.passwordotp = &s
}

// Passwordotp returns the value of the "passwordotp" field in the mutation.
func (m *PasswordStoreMutation) Passwordotp() (r string, exists bool) {
	v := m.passwordotp
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordotp returns the old "passwordotp" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldPasswordotp(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordotp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordotp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordotp: %w", err)
	}
	return oldValue.Passwordotp, nil
}

// ClearPasswordotp clears the value of the "passwordotp" field.
func (m *PasswordStoreMutation) ClearPasswordotp() {
	m.passwordotp = nil
	m.clearedFields[passwordstore.FieldPasswordotp] = struct{}{}
}

// PasswordotpCleared returns if the "passwordotp" field was cleared in this mutation.
func (m *PasswordStoreMutation) PasswordotpCleared() bool {
	_, ok := m.clearedFields[passwordstore.FieldPasswordotp]
	return ok
}

// ResetPasswordotp resets all changes to the "passwordotp" field.
func (m *PasswordStoreMutation) ResetPasswordotp() {
	m.passwordotp = nil
	delete(m.clearedFields, passwordstore.FieldPasswordotp)
}

// SetPasswordotpExpiredAt sets the "passwordotp_expired_at" field.
func (m *PasswordStoreMutation) SetPasswordotpExpiredAt(t time.Time) {
	m.passwordotp_expired_at = &t
}

// PasswordotpExpiredAt returns the value of the "passwordotp_expired_at" field in the mutation.
func (m *PasswordStoreMutation) PasswordotpExpiredAt() (r time.Time, exists bool) {
	v := m.passwordotp_expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordotpExpiredAt returns the old "passwordotp_expired_at" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldPasswordotpExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordotpExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordotpExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordotpExpiredAt: %w", err)
	}
	return oldValue.PasswordotpExpiredAt, nil
}

// ClearPasswordotpExpiredAt clears the value of the "passwordotp_expired_at" field.
func (m *PasswordStoreMutation) ClearPasswordotpExpiredAt() {
	m.passwordotp_expired_at = nil
	m.clearedFields[passwordstore.FieldPasswordotpExpiredAt] = struct{}{}
}

// PasswordotpExpiredAtCleared returns if the "passwordotp_expired_at" field was cleared in this mutation.
func (m *PasswordStoreMutation) PasswordotpExpiredAtCleared() bool {
	_, ok := m.clearedFields[passwordstore.FieldPasswordotpExpiredAt]
	return ok
}

// ResetPasswordotpExpiredAt resets all changes to the "passwordotp_expired_at" field.
func (m *PasswordStoreMutation) ResetPasswordotpExpiredAt() {
	m.passwordotp_expired_at = nil
	delete(m.clearedFields, passwordstore.FieldPasswordotpExpiredAt)
}

// SetPasswordotpRecovery sets the "passwordotp_recovery" field.
func (m *PasswordStoreMutation) SetPasswordotpRecovery(s []string) {
	m.passwordotp_recovery = &s
	m.appendpasswordotp_recovery = nil
}

// PasswordotpRecovery returns the value of the "passwordotp_recovery" field in the mutation.
func (m *PasswordStoreMutation) PasswordotpRecovery() (r []string, exists bool) {
	v := m.passwordotp_recovery
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordotpRecovery returns the old "passwordotp_recovery" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldPasswordotpRecovery(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordotpRecovery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordotpRecovery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordotpRecovery: %w", err)
	}
	return oldValue.PasswordotpRecovery, nil
}

// AppendPasswordotpRecovery adds s to the "passwordotp_recovery" field.
func (m *PasswordStoreMutation) AppendPasswordotpRecovery(s []string) {
	m.appendpasswordotp_recovery = append(m.appendpasswordotp_recovery, s...)
}

// AppendedPasswordotpRecovery returns the list of values that were appended to the "passwordotp_recovery" field in this mutation.
func (m *PasswordStoreMutation) AppendedPasswordotpRecovery() ([]string, bool) {
	if len(m.appendpasswordotp_recovery) == 0 {
		return nil, false
	}
	return m.appendpasswordotp_recovery, true
}

// ClearPasswordotpRecovery clears the value of the "passwordotp_recovery" field.
func (m *PasswordStoreMutation) ClearPasswordotpRecovery() {
	m.passwordotp_recovery = nil
	m.appendpasswordotp_recovery = nil
	m.clearedFields[passwordstore.FieldPasswordotpRecovery] = struct{}{}
}

// PasswordotpRecoveryCleared returns if the "passwordotp_recovery" field was cleared in this mutation.
func (m *PasswordStoreMutation) PasswordotpRecoveryCleared() bool {
	_, ok := m.clearedFields[passwordstore.FieldPasswordotpRecovery]
	return ok
}

// ResetPasswordotpRecovery resets all changes to the "passwordotp_recovery" field.
func (m *PasswordStoreMutation) ResetPasswordotpRecovery() {
	m.passwordotp_recovery = nil
	m.appendpasswordotp_recovery = nil
	delete(m.clearedFields, passwordstore.FieldPasswordotpRecovery)
}

// SetSubjectType sets the "subject_type" field.
func (m *PasswordStoreMutation) SetSubjectType(s string) {
	m.subject_type = &s
}

// SubjectType returns the value of the "subject_type" field in the mutation.
func (m *PasswordStoreMutation) SubjectType() (r string, exists bool) {
	v := m.subject_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectType returns the old "subject_type" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldSubjectType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectType: %w", err)
	}
	return oldValue.SubjectType, nil
}

// ResetSubjectType resets all changes to the "subject_type" field.
func (m *PasswordStoreMutation) ResetSubjectType() {
	m.subject_type = nil
}

// SetSubjectRef sets the "subject_ref" field.
func (m *PasswordStoreMutation) SetSubjectRef(s string) {
	m.subject_ref = &s
}

// SubjectRef returns the value of the "subject_ref" field in the mutation.
func (m *PasswordStoreMutation) SubjectRef() (r string, exists bool) {
	v := m.subject_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectRef returns the old "subject_ref" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldSubjectRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectRef: %w", err)
	}
	return oldValue.SubjectRef, nil
}

// ResetSubjectRef resets all changes to the "subject_ref" field.
func (m *PasswordStoreMutation) ResetSubjectRef() {
	m.subject_ref = nil
}

// SetSubjectSourceRef sets the "subject_source_ref" field.
func (m *PasswordStoreMutation) SetSubjectSourceRef(s string) {
	m.subject_source_ref = &s
}

// SubjectSourceRef returns the value of the "subject_source_ref" field in the mutation.
func (m *PasswordStoreMutation) SubjectSourceRef() (r string, exists bool) {
	v := m.subject_source_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectSourceRef returns the old "subject_source_ref" field's value of the PasswordStore entity.
// If the PasswordStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordStoreMutation) OldSubjectSourceRef(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectSourceRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectSourceRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectSourceRef: %w", err)
	}
	return oldValue.SubjectSourceRef, nil
}

// ClearSubjectSourceRef clears the value of the "subject_source_ref" field.
func (m *PasswordStoreMutation) ClearSubjectSourceRef() {
	m.subject_source_ref = nil
	m.clearedFields[passwordstore.FieldSubjectSourceRef] = struct{}{}
}

// SubjectSourceRefCleared returns if the "subject_source_ref" field was cleared in this mutation.
func (m *PasswordStoreMutation) SubjectSourceRefCleared() bool {
	_, ok := m.clearedFields[passwordstore.FieldSubjectSourceRef]
	return ok
}

// ResetSubjectSourceRef resets all changes to the "subject_source_ref" field.
func (m *PasswordStoreMutation) ResetSubjectSourceRef() {
	m.subject_source_ref = nil
	delete(m.clearedFields, passwordstore.FieldSubjectSourceRef)
}

// Where appends a list predicates to the PasswordStoreMutation builder.
func (m *PasswordStoreMutation) Where(ps ...predicate.PasswordStore) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordStoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordStoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PasswordStore, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordStoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordStoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PasswordStore).
func (m *PasswordStoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordStoreMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.password != nil {
		fields = append(fields, passwordstore.FieldPassword)
	}
	if m.password_expired_at != nil {
		fields = append(fields, passwordstore.FieldPasswordExpiredAt)
	}
	if m.password_updated_at != nil {
		fields = append(fields, passwordstore.FieldPasswordUpdatedAt)
	}
	if m.passwordtmp != nil {
		fields = append(fields, passwordstore.FieldPasswordtmp)
	}
	if m.passwordtmp_expired_at != nil {
		fields = append(fields, passwordstore.FieldPasswordtmpExpiredAt)
	}
	if m.passwordotp != nil {
		fields = append(fields, passwordstore.FieldPasswordotp)
	}
	if m.passwordotp_expired_at != nil {
		fields = append(fields, passwordstore.FieldPasswordotpExpiredAt)
	}
	if m.passwordotp_recovery != nil {
		fields = append(fields, passwordstore.FieldPasswordotpRecovery)
	}
	if m.subject_type != nil {
		fields = append(fields, passwordstore.FieldSubjectType)
	}
	if m.subject_ref != nil {
		fields = append(fields, passwordstore.FieldSubjectRef)
	}
	if m.subject_source_ref != nil {
		fields = append(fields, passwordstore.FieldSubjectSourceRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordStoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passwordstore.FieldPassword:
		return m.Password()
	case passwordstore.FieldPasswordExpiredAt:
		return m.PasswordExpiredAt()
	case passwordstore.FieldPasswordUpdatedAt:
		return m.PasswordUpdatedAt()
	case passwordstore.FieldPasswordtmp:
		return m.Passwordtmp()
	case passwordstore.FieldPasswordtmpExpiredAt:
		return m.PasswordtmpExpiredAt()
	case passwordstore.FieldPasswordotp:
		return m.Passwordotp()
	case passwordstore.FieldPasswordotpExpiredAt:
		return m.PasswordotpExpiredAt()
	case passwordstore.FieldPasswordotpRecovery:
		return m.PasswordotpRecovery()
	case passwordstore.FieldSubjectType:
		return m.SubjectType()
	case passwordstore.FieldSubjectRef:
		return m.SubjectRef()
	case passwordstore.FieldSubjectSourceRef:
		return m.SubjectSourceRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordStoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passwordstore.FieldPassword:
		return m.OldPassword(ctx)
	case passwordstore.FieldPasswordExpiredAt:
		return m.OldPasswordExpiredAt(ctx)
	case passwordstore.FieldPasswordUpdatedAt:
		return m.OldPasswordUpdatedAt(ctx)
	case passwordstore.FieldPasswordtmp:
		return m.OldPasswordtmp(ctx)
	case passwordstore.FieldPasswordtmpExpiredAt:
		return m.OldPasswordtmpExpiredAt(ctx)
	case passwordstore.FieldPasswordotp:
		return m.OldPasswordotp(ctx)
	case passwordstore.FieldPasswordotpExpiredAt:
		return m.OldPasswordotpExpiredAt(ctx)
	case passwordstore.FieldPasswordotpRecovery:
		return m.OldPasswordotpRecovery(ctx)
	case passwordstore.FieldSubjectType:
		return m.OldSubjectType(ctx)
	case passwordstore.FieldSubjectRef:
		return m.OldSubjectRef(ctx)
	case passwordstore.FieldSubjectSourceRef:
		return m.OldSubjectSourceRef(ctx)
	}
	return nil, fmt.Errorf("unknown PasswordStore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordStoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passwordstore.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case passwordstore.FieldPasswordExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordExpiredAt(v)
		return nil
	case passwordstore.FieldPasswordUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordUpdatedAt(v)
		return nil
	case passwordstore.FieldPasswordtmp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordtmp(v)
		return nil
	case passwordstore.FieldPasswordtmpExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordtmpExpiredAt(v)
		return nil
	case passwordstore.FieldPasswordotp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordotp(v)
		return nil
	case passwordstore.FieldPasswordotpExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordotpExpiredAt(v)
		return nil
	case passwordstore.FieldPasswordotpRecovery:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordotpRecovery(v)
		return nil
	case passwordstore.FieldSubjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectType(v)
		return nil
	case passwordstore.FieldSubjectRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectRef(v)
		return nil
	case passwordstore.FieldSubjectSourceRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectSourceRef(v)
		return nil
	}
	return fmt.Errorf("unknown PasswordStore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordStoreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordStoreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordStoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PasswordStore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordStoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passwordstore.FieldPassword) {
		fields = append(fields, passwordstore.FieldPassword)
	}
	if m.FieldCleared(passwordstore.FieldPasswordExpiredAt) {
		fields = append(fields, passwordstore.FieldPasswordExpiredAt)
	}
	if m.FieldCleared(passwordstore.FieldPasswordUpdatedAt) {
		fields = append(fields, passwordstore.FieldPasswordUpdatedAt)
	}
	if m.FieldCleared(passwordstore.FieldPasswordtmp) {
		fields = append(fields, passwordstore.FieldPasswordtmp)
	}
	if m.FieldCleared(passwordstore.FieldPasswordtmpExpiredAt) {
		fields = append(fields, passwordstore.FieldPasswordtmpExpiredAt)
	}
	if m.FieldCleared(passwordstore.FieldPasswordotp) {
		fields = append(fields, passwordstore.FieldPasswordotp)
	}
	if m.FieldCleared(passwordstore.FieldPasswordotpExpiredAt) {
		fields = append(fields, passwordstore.FieldPasswordotpExpiredAt)
	}
	if m.FieldCleared(passwordstore.FieldPasswordotpRecovery) {
		fields = append(fields, passwordstore.FieldPasswordotpRecovery)
	}
	if m.FieldCleared(passwordstore.FieldSubjectSourceRef) {
		fields = append(fields, passwordstore.FieldSubjectSourceRef)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordStoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordStoreMutation) ClearField(name string) error {
	switch name {
	case passwordstore.FieldPassword:
		m.ClearPassword()
		return nil
	case passwordstore.FieldPasswordExpiredAt:
		m.ClearPasswordExpiredAt()
		return nil
	case passwordstore.FieldPasswordUpdatedAt:
		m.ClearPasswordUpdatedAt()
		return nil
	case passwordstore.FieldPasswordtmp:
		m.ClearPasswordtmp()
		return nil
	case passwordstore.FieldPasswordtmpExpiredAt:
		m.ClearPasswordtmpExpiredAt()
		return nil
	case passwordstore.FieldPasswordotp:
		m.ClearPasswordotp()
		return nil
	case passwordstore.FieldPasswordotpExpiredAt:
		m.ClearPasswordotpExpiredAt()
		return nil
	case passwordstore.FieldPasswordotpRecovery:
		m.ClearPasswordotpRecovery()
		return nil
	case passwordstore.FieldSubjectSourceRef:
		m.ClearSubjectSourceRef()
		return nil
	}
	return fmt.Errorf("unknown PasswordStore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordStoreMutation) ResetField(name string) error {
	switch name {
	case passwordstore.FieldPassword:
		m.ResetPassword()
		return nil
	case passwordstore.FieldPasswordExpiredAt:
		m.ResetPasswordExpiredAt()
		return nil
	case passwordstore.FieldPasswordUpdatedAt:
		m.ResetPasswordUpdatedAt()
		return nil
	case passwordstore.FieldPasswordtmp:
		m.ResetPasswordtmp()
		return nil
	case passwordstore.FieldPasswordtmpExpiredAt:
		m.ResetPasswordtmpExpiredAt()
		return nil
	case passwordstore.FieldPasswordotp:
		m.ResetPasswordotp()
		return nil
	case passwordstore.FieldPasswordotpExpiredAt:
		m.ResetPasswordotpExpiredAt()
		return nil
	case passwordstore.FieldPasswordotpRecovery:
		m.ResetPasswordotpRecovery()
		return nil
	case passwordstore.FieldSubjectType:
		m.ResetSubjectType()
		return nil
	case passwordstore.FieldSubjectRef:
		m.ResetSubjectRef()
		return nil
	case passwordstore.FieldSubjectSourceRef:
		m.ResetSubjectSourceRef()
		return nil
	}
	return fmt.Errorf("unknown PasswordStore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordStoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordStoreMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordStoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordStoreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordStoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordStoreMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordStoreMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PasswordStore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordStoreMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PasswordStore edge %s", name)
}
