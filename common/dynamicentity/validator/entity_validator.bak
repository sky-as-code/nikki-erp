package validator

import (
	"fmt"
	"reflect"
	"strings"

	dschema "github.com/sky-as-code/nikki-erp/common/dynamicentity/schema"
	ft "github.com/sky-as-code/nikki-erp/common/fault"
	"github.com/sky-as-code/nikki-erp/common/model"
	val "github.com/sky-as-code/nikki-erp/common/validator"
)

type EntityValidator struct {
	fields map[string]*dschema.EntityField
}

func NewEntityValidator(schemaFields map[string]*dschema.EntityField) *EntityValidator {
	for _, field := range schemaFields {
		if err := validateEntityFieldName(field); err != nil {
			panic(err)
		}
	}
	return &EntityValidator{
		fields: schemaFields,
	}
}

func (this *EntityValidator) ValidateStruct(entity any, forEdit bool, isQuick bool) ft.ValidationErrors {
	fieldRulesList := make([]*val.FieldRules, 0, len(this.fields))

	for fieldName, field := range this.fields {
		fieldPtr, err := getFieldPointerByTag(entity, fieldName)
		if err != nil {
			continue
		}

		rules := this.buildStructFieldRules(fieldPtr, field, forEdit, isQuick)
		fieldRulesList = append(fieldRulesList, rules)
	}

	return val.ApiBased.ValidateStruct(entity, fieldRulesList...)
}

func (this *EntityValidator) ValidateMap(data map[string]any, forEdit bool, isQuick bool) ft.ValidationErrors {
	keyRulesList := make([]*val.KeyRules, 0, len(this.fields))
	targetMap := make(map[string]any)

	for fieldName, field := range this.fields {
		// Copy from `data` to `targetMap` to set nil to missing key, so that the validator will return the isNil's error
		// instead of the map's "Key missing" error.
		targetMap[fieldName] = data[fieldName]
		rules := buildFieldRules(field, forEdit, isQuick)
		keyRulesList = append(keyRulesList, val.Key(fieldName, rules...))
	}

	mapRule := val.Map(keyRulesList...).AllowExtraKeys()
	return val.ApiBased.Validate(targetMap, mapRule)
}

func (this *EntityValidator) buildStructFieldRules(fieldPtr any, fieldDef *dschema.EntityField, forEdit bool, isQuick bool) *val.FieldRules {
	rules := buildFieldRules(fieldDef, forEdit, isQuick)
	return val.Field(fieldPtr, rules...)
}

func buildFieldRules(fieldDef *dschema.EntityField, forEdit bool, isQuick bool) []val.Rule {
	commonRules := buildIsRequiredRules(fieldDef, forEdit)

	var rules []val.Rule
	minLength, maxLength := extractLengthOpts(fieldDef.Rules())
	rules = buildCustomTypeRules(fieldDef, forEdit, minLength, maxLength, isQuick)
	if rules == nil { // Not a custom type
		rules = buildCoreRules(fieldDef, forEdit, isQuick)
	}

	return append(commonRules, rules...)
}

func validateEntityFieldName(fieldDef *dschema.EntityField) error {
	if strings.TrimSpace(fieldDef.Name()) == "" {
		return fmt.Errorf("field name is required")
	}
	return nil
}

func getFieldPointerByTag(entity any, fieldName string) (any, error) {
	rv := reflect.ValueOf(entity)
	if rv.Kind() == reflect.Ptr {
		rv = rv.Elem()
	}

	if rv.Kind() != reflect.Struct {
		return nil, fmt.Errorf("entity must be a struct or pointer to struct")
	}

	rt := rv.Type()
	for i := 0; i < rt.NumField(); i++ {
		field := rt.Field(i)
		tagVal := field.Tag.Get(dschema.SchemaStructTag)
		if tagVal == "" {
			continue
		}

		dbTagName := strings.Split(tagVal, ",")[0]
		if dbTagName == fieldName {
			fieldValue := rv.Field(i)
			if !fieldValue.CanAddr() {
				return nil, fmt.Errorf("field %s cannot be addressed", fieldName)
			}
			return fieldValue.Addr().Interface(), nil
		}
	}

	return nil, fmt.Errorf("field %s not found with %s tag", fieldName, dschema.SchemaStructTag)
}

func extractLengthOpts(rulesDef []*dschema.FieldRule) (minLength int, maxLength int) {
	for _, rule := range rulesDef {
		ruleName := rule.RuleName()
		if ruleName == dschema.FieldRuleLengthType {
			ruleOptions := rule.RuleOptions()
			lengthArr := ruleOptions.([]int)
			return lengthArr[0], lengthArr[1]
		}
	}
	// Default fallback
	return 1, model.MODEL_RULE_DESC_LENGTH
}

func extractArrayLengthRule(rulesDef []*dschema.FieldRule) val.Rule {
	for _, rule := range rulesDef {
		ruleName := rule.RuleName()
		if ruleName == dschema.FieldRuleArrayLengthType {
			ruleOptions := rule.RuleOptions()
			lengthArr := ruleOptions.([]int)
			return val.Length(lengthArr[0], lengthArr[1])
		}
	}
	return nil
}

func buildCoreRules(fieldDef *dschema.EntityField, forEdit bool, isQuick bool) []val.Rule {
	rules := buildSpecialTypeRules(fieldDef.DataType(), isQuick)
	rules = append(rules, buildNormalRules(fieldDef)...)

	if fieldDef.IsArray() {
		rules = buildArrayRules(fieldDef, forEdit, rules)
	}

	return rules
}

func buildIsRequiredRules(fieldDef *dschema.EntityField, forEdit bool) []val.Rule {
	rules := make([]val.Rule, 0)

	if fieldDef.IsRequired() {
		rules = append(rules,
			val.NotNilWhen(!forEdit),
			val.NotEmptyWhen(!forEdit),
		)
	}

	return rules
}

func buildCustomTypeRules(fieldDef *dschema.EntityField, forEdit bool, minLength int, maxLength int, isQuick bool) []val.Rule {
	dataType := fieldDef.DataType()
	isRequired := fieldDef.IsRequired() && !forEdit

	var rules []val.Rule
	switch dataType {
	case dschema.FieldDataTypeEtag:
		if isQuick {
			rules = model.EtagRuleQuick(isRequired)
		} else {
			rules = model.EtagRule(isRequired)
		}

	case dschema.FieldDataTypeLangJson:
		if isQuick {
			rules = model.LangJsonRuleQuick(isRequired)
		} else {
			rules = model.LangJsonRule(isRequired, minLength, maxLength)
		}

	case dschema.FieldDataTypeLangCode:
		if isQuick {
			rules = model.LanguageCodeRuleQuick(isRequired)
		} else {
			rules = model.LanguageCodeRule(isRequired)
		}

	case dschema.FieldDataTypeModelId, dschema.FieldDataTypeUlid:
		if isQuick {
			rules = model.IdRuleQuick(isRequired)
		} else {
			rules = model.IdRule(isRequired)
		}

	case dschema.FieldDataTypeSlug:
		if isQuick {
			rules = model.SlugRuleQuick(isRequired)
		} else {
			rules = model.SlugRule(isRequired)
		}

	default:
		rules = nil // Not a special data type
	}

	if fieldDef.IsArray() {
		return buildArrayRules(fieldDef, forEdit, rules)
	}
	return rules
}

func buildSpecialTypeRules(dataType dschema.FieldDataType, isQuick bool) []val.Rule {
	rules := make([]val.Rule, 0)

	switch dataType {
	case dschema.FieldDataTypeEmail:
		if isQuick {
			rules = append(rules, val.Length(5, model.MODEL_RULE_USERNAME_LENGTH))
		} else {
			rules = append(rules, val.IsEmail)
		}
	case dschema.FieldDataTypeUrl:
		if isQuick {
			rules = append(rules, val.Length(1, model.MODEL_RULE_URL_LENGTH))
		} else {
			rules = append(rules, val.IsUrl)
		}
	case dschema.FieldDataTypeUuid:
		if isQuick {
			rules = append(rules, val.IsUuid)
		} else {
			rules = append(rules, val.Length(36, 36))
		}
	}

	return rules
}

func buildNormalRules(fieldDef *dschema.EntityField) []val.Rule {
	rules := make([]val.Rule, 0)

	for _, rule := range fieldDef.Rules() {
		ruleName := rule.RuleName()
		if ruleName == "" {
			continue
		}

		ruleOptions := rule.RuleOptions()
		switch ruleName {
		case dschema.FieldRuleLengthType:
			lengthArr := ruleOptions.([]int)
			rules = append(rules, val.Length(lengthArr[0], lengthArr[1]))
		case dschema.FieldRuleMaxType:
			rules = append(rules, val.Max(ruleOptions))
		case dschema.FieldRuleMinType:
			rules = append(rules, val.Min(ruleOptions))
		case dschema.FieldRuleOneOfType:
			values := ruleOptions.([]any)
			rules = append(rules, val.OneOf(values...))
		}
	}

	return rules
}

func buildArrayRules(fieldDef *dschema.EntityField, forEdit bool, itemRules []val.Rule) []val.Rule {
	arrayRules := make([]val.Rule, 0)

	// Array-level rules
	if fieldDef.IsRequired() {
		arrayRules = append(arrayRules,
			val.NotNilWhen(!forEdit),
			val.NotEmptyWhen(!forEdit),
		)
	}

	arrayLengthRule := extractArrayLengthRule(fieldDef.Rules())
	if arrayLengthRule != nil {
		arrayRules = append(arrayRules, arrayLengthRule)
	}

	// Determine if elementRules are custom type rules or core rules
	// Custom type rules come from buildCustomTypeRules and should be wrapped directly
	// Core rules come from buildCoreRules and need to be rebuilt to avoid duplication
	// isCustomTypeRules := isCustomTypeRulesForField(field)

	// var elementRulesToWrap []val.Rule
	// if isCustomTypeRules {
	// 	// Custom type rules: wrap directly (they already contain element-level validation)
	// 	elementRulesToWrap = elementRules
	// } else {
	// 	// Core rules: rebuild element rules from field schema (excluding array-level rules)
	// 	elementRulesToWrap = buildElementRulesForArray(field, nil)
	// }

	// If we have element rules, wrap them with val.Each
	// if len(elementRulesToWrap) > 0 {
	// 	arrayRules = append(arrayRules, val.Each(elementRulesToWrap...))
	// }

	return append(arrayRules, val.Each(itemRules...))
}
