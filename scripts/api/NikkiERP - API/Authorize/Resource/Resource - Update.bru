meta {
  name: Resource - Update
  type: http
  seq: 2
}

put {
  url: {{api_host}}/v1/authorize/resources/{{resource_id}}
  body: json
  auth: inherit
}

body:json {
  {
      "description": "Description",
      "etag": "{{etag}}"
  }
}

script:post-response {
  const statusCode = res.getStatus();
  let body;
  
  try {
    body = res.getBody();
    console.log(`üì• Response body (status: ${statusCode}):`, body);
  } catch (e) {
    expect.fail("‚ùå Failed to parse response body");
  }
  
  test("Status code is 200 or 400", () => {
    expect([200, 400]).to.include(statusCode);
  });
  
  // ========== üü¢ SUCCESS ==========
  if (statusCode === 200) {
    test("Success: Response contains required fields", () => {
      expect(body).to.be.an("object");
      const requiredFields = ["id", "etag", "updatedAt"];
      requiredFields.forEach(field => {
        expect(body).to.have.property(field);
      });
    });
  
    // Set vars only when all valid
    if (typeof body.etag === "string" && body.etag.length > 0) {
      bru.setVar("etag", body.etag);
      console.log("‚úÖ etag set to:", body.etag);
    } else {
      console.warn("‚ö†Ô∏è etag missing or invalid");
    }
  
    if (typeof body.id === "string" && body.id.length > 0) {
      bru.setVar("resource_id", body.id);
      console.log("‚úÖ resource_id set to:", body.id);
    } else {
      console.warn("‚ö†Ô∏è resource_id missing or invalid");
    }
  }
  
  // ========== üî¥ VALIDATION ERROR ==========
  if (statusCode === 400) {
    const errorSchema = {
      type: "object",
      required: ["code", "details"],
      properties: {
        code: { type: "string", enum: ["validation_error"] },
        details: { type: "object" }
      },
      additionalProperties: true
    };
  
    test("Error: Matches validation_error schema", () => {
      expect(tv4.validate(body, errorSchema)).to.be.true;
    });
  
    test("Error: code is 'validation_error'", () => {
      expect(body.code).to.eql("validation_error");
      expect(body.details).to.be.an("object");
    });
  
    const details = body.details;
  
    // ========== ‚ùå Missing Required Fields ==========
    if (details.etag === "cannot be blank") {
      test("Error: etag is missing", () => {
        expect(details).to.have.property("etag", "cannot be blank");
      });
    }
  
    // ========== ‚ùå Etag Mismatch ==========
    if (details.etag === "etag mismatched") {
      test("Error: etag mismatch", () => {
        expect(details).to.have.property("etag", "etag mismatched");
      });
    }
  
    // ========== ‚ùå Resource Not Found ==========
    if (details.resource_id === "resource not found") {
      test("Error: resource_id not found", () => {
        expect(details).to.have.property("resource_id", "resource not found");
      });
    }
  
    // ========== üß™ Unexpected fields ==========
    test("Error: Does not include unrelated fields", () => {
      expect(details).to.not.have.property("invalid_field");
    });
  
    // ========== ‚ÑπÔ∏è Unknown case fallback ==========
    if (
      !details.etag?.includes("cannot be blank") &&
      !details.etag?.includes("etag mismatched") &&
      !details.resource_id?.includes("resource not found")
    ) {
      console.warn("‚ùì Unexpected validation error details:", details);
    }
  }
  
}

settings {
  encodeUrl: true
}
