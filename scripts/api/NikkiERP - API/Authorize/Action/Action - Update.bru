meta {
  name: Action - Update
  type: http
  seq: 2
}

put {
  url: {{api_host}}/v1/authorize/actions/{{action_id}}
  body: json
  auth: inherit
}

body:json {
  {
      "description": "Description",
      "etag": "{{etag}}"
  }
}

script:post-response {
  const statusCode = res.getStatus();
  let body;
  let isJsonValid = true;
  
  try {
      body = res.getBody();
      console.log(`üì• Parsed response (status: ${statusCode}):`, body);
  } catch (e) {
      isJsonValid = false;
      console.error("‚ùå Failed to parse response body:", e);
      expect.fail("‚ùå Invalid JSON response");
  }
  
  // ========= ‚úÖ CASE 1: SUCCESS =========
  if (statusCode === 200 && isJsonValid) {
      test("‚úÖ Status code is 200", () => {
          expect(statusCode).to.equal(200);
      });
  
      test("‚úÖ Response contains id, etag, updatedAt", () => {
          ["id", "etag", "updatedAt"].forEach(field => {
              expect(body).to.have.property(field);
          });
      });
  
      // Set variables only on success
      if (typeof body.etag === "string" && body.etag.length > 0) {
          bru.setVar("etag", body.etag);
          console.log("‚úÖ etag set to:", body.etag);
      } else {
          console.warn("‚ö†Ô∏è Missing or invalid etag");
      }
  
      if (typeof body.id === "string" && body.id.length > 0) {
          bru.setVar("action_id", body.id);
          console.log("‚úÖ action_id set to:", body.id);
      } else {
          console.warn("‚ö†Ô∏è Missing or invalid action_id");
      }
  }
  
  // ========= ‚ùå CASE 2: INVALID FIELDS (etag blank) =========
  if (statusCode === 400 && body?.details?.etag === "cannot be blank") {
      test("‚ùå Status code is 400 (invalid fields)", () => {
          expect(statusCode).to.equal(400);
      });
  
      test("‚ùå Response has validation_error for etag", () => {
          expect(body.code).to.eql("validation_error");
          expect(body.details).to.have.property("etag", "cannot be blank");
      });
  
      test("üîí Do not update etag when error", () => {
          const etag = bru.getVar("etag");
          expect(etag).to.not.eql(null);
          expect(etag).to.not.eql(undefined);
      });
  
      console.log("‚ö†Ô∏è Validation error response:", body);
  }
  
  // ========= ‚ùå CASE 3: ETag MISMATCH =========
  if (statusCode === 400 && body?.details?.etag === "etag mismatched") {
      test("‚ùå Status code is 400 (etag mismatch)", () => {
          expect(statusCode).to.equal(400);
      });
  
      test("‚ùå Returns etag mismatch error", () => {
          expect(body.code).to.eql("validation_error");
          expect(body.details).to.have.property("etag", "etag mismatched");
      });
  
      test("üîí Do not update etag when mismatched", () => {
          const etag = bru.getVar("etag");
          expect(etag).to.not.eql(null);
          expect(etag).to.not.eql(undefined);
      });
  
      console.log("‚ö†Ô∏è ETag mismatch error:", body.details);
  }
  
  // ========= ‚ùå CASE 4: NOT FOUND =========
  if (statusCode === 400 && body?.details?.action_id?.includes("not found")) {
      test("‚ùå Status code is 400 (not found)", () => {
          expect(statusCode).to.equal(400);
      });
  
      test("‚ùå Response includes 'action_id: not found'", () => {
          expect(body.code).to.eql("validation_error");
          expect(body.details).to.have.property("action_id");
          expect(body.details.action_id).to.include("not found");
      });
  
      test("üîí Do not update etag when action not found", () => {
          const etag = bru.getVar("etag");
          expect(etag).to.not.eql(null);
          expect(etag).to.not.eql(undefined);
      });
  
      console.log("‚ö†Ô∏è Not found error:", body.details);
  }
  
}

settings {
  encodeUrl: true
}
