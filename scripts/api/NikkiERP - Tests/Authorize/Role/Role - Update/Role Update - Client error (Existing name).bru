meta {
  name: Role Update - Client error (Existing name)
  type: http
  seq: 2
}

put {
  url: {{api_host}}/v1/authorize/roles/{{role_id}}
  body: json
  auth: inherit
}

body:json {
  {
    "name": "{{role_name}}",
    "description": "description",
    "entitlementIds": [
      "01JWP8KP39GKAH67FEAC7TZ631",
      "{{entitlement_id}}"
    ],
    "etag": "{{etag}}"
  }
}

script:post-response {
  const status = res.getStatus();
  let body;
  let isJsonValid = true;
  
  try {
    body = res.getBody();
    console.log("üì• Response body:", body);
  } catch (err) {
    isJsonValid = false;
    expect.fail("‚ùå Response is not valid JSON");
  }
  
  // ================== Case 1: Success ==================
  if (status === 200 && isJsonValid) {
    test("Status code is 200", function () {
      expect(status).to.equal(200);
    });
  
    test("Response contains required fields", function () {
      ["id", "etag", "updatedAt"].forEach(field => {
        expect(body).to.have.property(field);
      });
    });
  
    // ‚úÖ Set variables
    if (typeof body.etag === "string" && body.etag.length > 0) {
      bru.setVar("etag", body.etag);
      console.log("‚úÖ etag set to:", body.etag);
    } else {
      console.warn("‚ö†Ô∏è etag missing or invalid");
    }
  
    if (typeof body.id === "string" && body.id.length > 0) {
      bru.setVar("role_id", body.id);
      console.log("‚úÖ role_id set to:", body.id);
    } else {
      console.warn("‚ö†Ô∏è id missing or invalid");
    }
  }
  
  // ================== Validation Error Cases ==================
  if (status === 400 && isJsonValid) {
    test("Should contain validation error details", function () {
      expect(body).to.have.property("code", "validation_error");
      expect(body).to.have.property("details").that.is.an("object");
    });
  
    const details = body.details || {};
  
    // Case 2: Existing name
    if (details.name) {
      test("Should catch existing name conflict", function () {
        expect(details.name).to.be.a("string");
        console.warn("‚ö†Ô∏è Name conflict:", details.name);
      });
    }
  
    // Case 3: Invalid fields - blank etag
    if (details.etag === "cannot be blank") {
      test("Should catch blank etag field", function () {
        expect(details.etag).to.equal("cannot be blank");
      });
    }
  
    // Case 4: No match etag
    if (details.etag === "etag mismatched") {
      test("Should catch mismatched etag", function () {
        expect(details.etag).to.equal("etag mismatched");
      });
    }
  
    // Case 5: Not found role
    if (details.role_id === "role not found") {
      test("Should catch non-existent role", function () {
        expect(details.role_id).to.equal("role not found");
      });
    }
  
    // Case 6: Not found entitlement(s)
    const missingEntitlements = Object.entries(details).filter(([key, val]) =>
      key.startsWith("entitlements[") && val === "entitlement not found"
    );
    if (missingEntitlements.length > 0) {
      test("Should catch missing entitlements", function () {
        missingEntitlements.forEach(([key, val]) => {
          expect(val).to.equal("entitlement not found");
          console.warn(`‚ùå ${key}: ${val}`);
        });
      });
    }
  
    // Case 7: Duplicate entitlement ID(s)
    const duplicates = Object.entries(details).filter(([key, val]) =>
      key.startsWith("entitlements[") && val.includes("duplicate entitlement id")
    );
    if (duplicates.length > 0) {
      test("Should catch duplicate entitlement IDs", function () {
        duplicates.forEach(([key, val]) => {
          expect(val).to.include("duplicate entitlement id");
          console.warn(`‚ö†Ô∏è Duplicate: ${key}: ${val}`);
        });
      });
    }
  
    // ‚ùå Do not update etag when failed
    test("Do not update 'etag' on error", function () {
      const currentEtag = bru.getVar("etag");
      expect(currentEtag).to.not.eql(null);
      expect(currentEtag).to.not.eql(undefined);
    });
  }
  
}

settings {
  encodeUrl: true
}
